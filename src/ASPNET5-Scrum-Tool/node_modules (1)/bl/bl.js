var DuplexStream = require('readable-stream/duplex')
  , util         = require('util')

function BufferList (callback) ***REMOVED***
  if (!(this instanceof BufferList))
    return new BufferList(callback)

  this._bufs  = []
  this.length = 0

  if (typeof callback == 'function') ***REMOVED***
    this._callback = callback

    var piper = function (err) ***REMOVED***
      if (this._callback) ***REMOVED***
        this._callback(err)
        this._callback = null
  ***REMOVED***
***REMOVED***.bind(this)

    this.on('pipe', function (src) ***REMOVED***
      src.on('error', piper)
***REMOVED***)
    this.on('unpipe', function (src) ***REMOVED***
      src.removeListener('error', piper)
***REMOVED***)
  ***REMOVED***
  else if (Buffer.isBuffer(callback))
    this.append(callback)
  else if (Array.isArray(callback)) ***REMOVED***
    callback.forEach(function (b) ***REMOVED***
      Buffer.isBuffer(b) && this.append(b)
***REMOVED***.bind(this))
  ***REMOVED***

  DuplexStream.call(this)
***REMOVED***

util.inherits(BufferList, DuplexStream)

BufferList.prototype._offset = function (offset) ***REMOVED***
  var tot = 0, i = 0, _t
  for (; i < this._bufs.length; i++) ***REMOVED***
    _t = tot + this._bufs[i].length
    if (offset < _t)
      return [ i, offset - tot ]
    tot = _t
  ***REMOVED***
***REMOVED***

BufferList.prototype.append = function (buf) ***REMOVED***
  var isBuffer = Buffer.isBuffer(buf) ||
                 buf instanceof BufferList

  // coerce number arguments to strings, since Buffer(number) does
  // uninitialized memory allocation
  if (typeof buf == 'number')
    buf = buf.toString()

  if (buf instanceof BufferList) ***REMOVED***
    this._bufs.push.apply(this._bufs, buf._bufs)
    this.length += buf.length
  ***REMOVED*** else ***REMOVED***
    this._bufs.push(isBuffer ? buf : new Buffer(buf))
    this.length += buf.length
  ***REMOVED***

  return this
***REMOVED***

BufferList.prototype._write = function (buf, encoding, callback) ***REMOVED***
  this.append(buf)
  if (callback)
    callback()
***REMOVED***

BufferList.prototype._read = function (size) ***REMOVED***
  if (!this.length)
    return this.push(null)
  size = Math.min(size, this.length)
  this.push(this.slice(0, size))
  this.consume(size)
***REMOVED***

BufferList.prototype.end = function (chunk) ***REMOVED***
  DuplexStream.prototype.end.call(this, chunk)

  if (this._callback) ***REMOVED***
    this._callback(null, this.slice())
    this._callback = null
  ***REMOVED***
***REMOVED***

BufferList.prototype.get = function (index) ***REMOVED***
  return this.slice(index, index + 1)[0]
***REMOVED***

BufferList.prototype.slice = function (start, end) ***REMOVED***
  return this.copy(null, 0, start, end)
***REMOVED***

BufferList.prototype.copy = function (dst, dstStart, srcStart, srcEnd) ***REMOVED***
  if (typeof srcStart != 'number' || srcStart < 0)
    srcStart = 0
  if (typeof srcEnd != 'number' || srcEnd > this.length)
    srcEnd = this.length
  if (srcStart >= this.length)
    return dst || new Buffer(0)
  if (srcEnd <= 0)
    return dst || new Buffer(0)

  var copy   = !!dst
    , off    = this._offset(srcStart)
    , len    = srcEnd - srcStart
    , bytes  = len
    , bufoff = (copy && dstStart) || 0
    , start  = off[1]
    , l
    , i

  // copy/slice everything
  if (srcStart === 0 && srcEnd == this.length) ***REMOVED***
    if (!copy) // slice, just return a full concat
      return Buffer.concat(this._bufs)

    // copy, need to copy individual buffers
    for (i = 0; i < this._bufs.length; i++) ***REMOVED***
      this._bufs[i].copy(dst, bufoff)
      bufoff += this._bufs[i].length
***REMOVED***

    return dst
  ***REMOVED***

  // easy, cheap case where it's a subset of one of the buffers
  if (bytes <= this._bufs[off[0]].length - start) ***REMOVED***
    return copy
      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
      : this._bufs[off[0]].slice(start, start + bytes)
  ***REMOVED***

  if (!copy) // a slice, we need something to copy in to
    dst = new Buffer(len)

  for (i = off[0]; i < this._bufs.length; i++) ***REMOVED***
    l = this._bufs[i].length - start

    if (bytes > l) ***REMOVED***
      this._bufs[i].copy(dst, bufoff, start)
***REMOVED*** else ***REMOVED***
      this._bufs[i].copy(dst, bufoff, start, start + bytes)
      break
***REMOVED***

    bufoff += l
    bytes -= l

    if (start)
      start = 0
  ***REMOVED***

  return dst
***REMOVED***

BufferList.prototype.toString = function (encoding, start, end) ***REMOVED***
  return this.slice(start, end).toString(encoding)
***REMOVED***

BufferList.prototype.consume = function (bytes) ***REMOVED***
  while (this._bufs.length) ***REMOVED***
    if (bytes >= this._bufs[0].length) ***REMOVED***
      bytes -= this._bufs[0].length
      this.length -= this._bufs[0].length
      this._bufs.shift()
***REMOVED*** else ***REMOVED***
      this._bufs[0] = this._bufs[0].slice(bytes)
      this.length -= bytes
      break
***REMOVED***
  ***REMOVED***
  return this
***REMOVED***

BufferList.prototype.duplicate = function () ***REMOVED***
  var i = 0
    , copy = new BufferList()

  for (; i < this._bufs.length; i++)
    copy.append(this._bufs[i])

  return copy
***REMOVED***

BufferList.prototype.destroy = function () ***REMOVED***
  this._bufs.length = 0;
  this.length = 0;
  this.push(null);
***REMOVED***

;(function () ***REMOVED***
  var methods = ***REMOVED***
      'readDoubleBE' : 8
    , 'readDoubleLE' : 8
    , 'readFloatBE'  : 4
    , 'readFloatLE'  : 4
    , 'readInt32BE'  : 4
    , 'readInt32LE'  : 4
    , 'readUInt32BE' : 4
    , 'readUInt32LE' : 4
    , 'readInt16BE'  : 2
    , 'readInt16LE'  : 2
    , 'readUInt16BE' : 2
    , 'readUInt16LE' : 2
    , 'readInt8'     : 1
    , 'readUInt8'    : 1
  ***REMOVED***

  for (var m in methods) ***REMOVED***
    (function (m) ***REMOVED***
      BufferList.prototype[m] = function (offset) ***REMOVED***
        return this.slice(offset, offset + methods[m])[m](0)
  ***REMOVED***
***REMOVED***(m))
  ***REMOVED***
***REMOVED***())

module.exports = BufferList
