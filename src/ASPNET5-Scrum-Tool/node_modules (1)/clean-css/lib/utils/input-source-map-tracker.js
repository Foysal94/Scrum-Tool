var SourceMapConsumer = require('source-map').SourceMapConsumer;

var fs = require('fs');
var path = require('path');
var http = require('http');
var https = require('https');
var url = require('url');

var override = require('../utils/object.js').override;

var MAP_MARKER = /\/\*# sourceMappingURL=(\S+) \*\//;
var REMOTE_RESOURCE = /^(https?:)?\/\//;
var DATA_URI = /^data:(\S*?)?(;charset=[^;]+)?(;[^,]+?)?,(.+)/;

var unescape = global.unescape;

function InputSourceMapStore(outerContext) ***REMOVED***
  this.options = outerContext.options;
  this.errors = outerContext.errors;
  this.warnings = outerContext.warnings;
  this.sourceTracker = outerContext.sourceTracker;
  this.timeout = this.options.inliner.timeout;
  this.requestOptions = this.options.inliner.request;
  this.localOnly = outerContext.localOnly;
  this.relativeTo = outerContext.options.target || process.cwd();

  this.maps = ***REMOVED******REMOVED***;
  this.sourcesContent = ***REMOVED******REMOVED***;
***REMOVED***

function fromString(self, _, whenDone) ***REMOVED***
  self.trackLoaded(undefined, undefined, self.options.sourceMap);
  return whenDone();
***REMOVED***

function fromSource(self, data, whenDone, context) ***REMOVED***
  var nextAt = 0;

  function proceedToNext() ***REMOVED***
    context.cursor += nextAt + 1;
    fromSource(self, data, whenDone, context);
  ***REMOVED***

  while (context.cursor < data.length) ***REMOVED***
    var fragment = data.substring(context.cursor);

    var markerStartMatch = self.sourceTracker.nextStart(fragment) || ***REMOVED*** index: -1 ***REMOVED***;
    var markerEndMatch = self.sourceTracker.nextEnd(fragment) || ***REMOVED*** index: -1 ***REMOVED***;
    var mapMatch = MAP_MARKER.exec(fragment) || ***REMOVED*** index: -1 ***REMOVED***;
    var sourceMapFile = mapMatch[1];

    nextAt = data.length;
    if (markerStartMatch.index > -1)
      nextAt = markerStartMatch.index;
    if (markerEndMatch.index > -1 && markerEndMatch.index < nextAt)
      nextAt = markerEndMatch.index;
    if (mapMatch.index > -1 && mapMatch.index < nextAt)
      nextAt = mapMatch.index;

    if (nextAt == data.length)
      break;

    if (nextAt == markerStartMatch.index) ***REMOVED***
      context.files.push(markerStartMatch.filename);
***REMOVED*** else if (nextAt == markerEndMatch.index) ***REMOVED***
      context.files.pop();
***REMOVED*** else if (nextAt == mapMatch.index) ***REMOVED***
      var isRemote = /^https?:\/\//.test(sourceMapFile) || /^\/\//.test(sourceMapFile);
      var isDataUri = DATA_URI.test(sourceMapFile);

      if (isRemote) ***REMOVED***
        return fetchMapFile(self, sourceMapFile, context, proceedToNext);
  ***REMOVED*** else ***REMOVED***
        var sourceFile = context.files[context.files.length - 1];
        var sourceMapPath, sourceMapData;
        var sourceDir = sourceFile ? path.dirname(sourceFile) : self.options.relativeTo;

        if (isDataUri) ***REMOVED***
          // source map's path is the same as the source file it comes from
          sourceMapPath = path.resolve(self.options.root, sourceFile || '');
          sourceMapData = fromDataUri(sourceMapFile);
***REMOVED*** else ***REMOVED***
          sourceMapPath = path.resolve(self.options.root, path.join(sourceDir || '', sourceMapFile));
          sourceMapData = fs.readFileSync(sourceMapPath, 'utf-8');
***REMOVED***
        self.trackLoaded(sourceFile || undefined, sourceMapPath, sourceMapData);
  ***REMOVED***
***REMOVED***

    context.cursor += nextAt + 1;
  ***REMOVED***

  return whenDone();
***REMOVED***

function fromDataUri(uriString) ***REMOVED***
  var match = DATA_URI.exec(uriString);
  var charset = match[2] ? match[2].split(/[=;]/)[2] : 'us-ascii';
  var encoding = match[3] ? match[3].split(';')[1] : 'utf8';
  var data = encoding == 'utf8' ? unescape(match[4]) : match[4];

  var buffer = new Buffer(data, encoding);
  buffer.charset = charset;

  return buffer.toString();
***REMOVED***

function fetchMapFile(self, sourceUrl, context, done) ***REMOVED***
  fetch(self, sourceUrl, function (data) ***REMOVED***
    self.trackLoaded(context.files[context.files.length - 1] || undefined, sourceUrl, data);
    done();
  ***REMOVED***, function (message) ***REMOVED***
    context.errors.push('Broken source map at "' + sourceUrl + '" - ' + message);
    return done();
  ***REMOVED***);
***REMOVED***

function fetch(self, path, onSuccess, onFailure) ***REMOVED***
  var protocol = path.indexOf('https') === 0 ? https : http;
  var requestOptions = override(url.parse(path), self.requestOptions);
  var errorHandled = false;

  protocol
    .get(requestOptions, function (res) ***REMOVED***
      if (res.statusCode < 200 || res.statusCode > 299)
        return onFailure(res.statusCode);

      var chunks = [];
      res.on('data', function (chunk) ***REMOVED***
        chunks.push(chunk.toString());
  ***REMOVED***);
      res.on('end', function () ***REMOVED***
        onSuccess(chunks.join(''));
  ***REMOVED***);
***REMOVED***)
    .on('error', function (res) ***REMOVED***
      if (errorHandled)
        return;

      onFailure(res.message);
      errorHandled = true;
***REMOVED***)
    .on('timeout', function () ***REMOVED***
      if (errorHandled)
        return;

      onFailure('timeout');
      errorHandled = true;
***REMOVED***)
    .setTimeout(self.timeout);
***REMOVED***

function originalPositionIn(trackedSource, line, column, token, allowNFallbacks) ***REMOVED***
  var originalPosition;
  var maxRange = token.length;
  var position = ***REMOVED***
    line: line,
    column: column + maxRange
  ***REMOVED***;

  while (maxRange-- > 0) ***REMOVED***
    position.column--;
    originalPosition = trackedSource.data.originalPositionFor(position);

    if (originalPosition)
      break;
  ***REMOVED***

  if (originalPosition.line === null && line > 1 && allowNFallbacks > 0)
    return originalPositionIn(trackedSource, line - 1, column, token, allowNFallbacks - 1);

  if (trackedSource.path && originalPosition.source) ***REMOVED***
    originalPosition.source = REMOTE_RESOURCE.test(trackedSource.path) ?
      url.resolve(trackedSource.path, originalPosition.source) :
      path.join(trackedSource.path, originalPosition.source);

    originalPosition.sourceResolved = true;
  ***REMOVED***

  return originalPosition;
***REMOVED***

function trackContentSources(self, sourceFile) ***REMOVED***
  var consumer = self.maps[sourceFile].data;
  var isRemote = REMOTE_RESOURCE.test(sourceFile);
  var sourcesMapping = ***REMOVED******REMOVED***;

  consumer.sources.forEach(function (file, index) ***REMOVED***
    var uniquePath = isRemote ?
      url.resolve(path.dirname(sourceFile), file) :
      path.relative(self.relativeTo, path.resolve(path.dirname(sourceFile), file));

    sourcesMapping[uniquePath] = consumer.sourcesContent && consumer.sourcesContent[index];
  ***REMOVED***);
  self.sourcesContent[sourceFile] = sourcesMapping;
***REMOVED***

function _resolveSources(self, remaining, whenDone) ***REMOVED***
  function processNext() ***REMOVED***
    return _resolveSources(self, remaining, whenDone);
  ***REMOVED***

  if (remaining.length === 0)
    return whenDone();

  var current = remaining.shift();
  var sourceFile = current[0];
  var originalFile = current[1];
  var isRemote = REMOTE_RESOURCE.test(sourceFile);

  if (isRemote && self.localOnly) ***REMOVED***
    self.warnings.push('No callback given to `#minify` method, cannot fetch a remote file from "' + originalFile + '"');
    return processNext();
  ***REMOVED***

  if (isRemote) ***REMOVED***
    fetch(self, originalFile, function (data) ***REMOVED***
      self.sourcesContent[sourceFile][originalFile] = data;
      processNext();
***REMOVED***, function (message) ***REMOVED***
      self.warnings.push('Broken original source file at "' + originalFile + '" - ' + message);
      processNext();
***REMOVED***);
  ***REMOVED*** else ***REMOVED***
    var fullPath = path.join(self.options.root, originalFile);
    if (fs.existsSync(fullPath))
      self.sourcesContent[sourceFile][originalFile] = fs.readFileSync(fullPath, 'utf-8');
    else
      self.warnings.push('Missing original source file at "' + fullPath + '".');
    return processNext();
  ***REMOVED***
***REMOVED***

InputSourceMapStore.prototype.track = function (data, whenDone) ***REMOVED***
  return typeof this.options.sourceMap == 'string' ?
    fromString(this, data, whenDone) :
    fromSource(this, data, whenDone, ***REMOVED*** files: [], cursor: 0, errors: this.errors ***REMOVED***);
***REMOVED***;

InputSourceMapStore.prototype.trackLoaded = function (sourcePath, mapPath, mapData) ***REMOVED***
  var relativeTo = this.options.explicitTarget ? this.options.target : this.options.root;
  var isRemote = REMOTE_RESOURCE.test(sourcePath);

  if (mapPath) ***REMOVED***
    mapPath = isRemote ?
      path.dirname(mapPath) :
      path.dirname(path.relative(relativeTo, mapPath));
  ***REMOVED***

  this.maps[sourcePath] = ***REMOVED***
    path: mapPath,
    data: new SourceMapConsumer(mapData)
  ***REMOVED***;

  trackContentSources(this, sourcePath);
***REMOVED***;

InputSourceMapStore.prototype.isTracking = function (source) ***REMOVED***
  return !!this.maps[source];
***REMOVED***;

InputSourceMapStore.prototype.originalPositionFor = function (sourceInfo, token, allowNFallbacks) ***REMOVED***
  return originalPositionIn(this.maps[sourceInfo.source], sourceInfo.line, sourceInfo.column, token, allowNFallbacks);
***REMOVED***;

InputSourceMapStore.prototype.sourcesContentFor = function (contextSource) ***REMOVED***
  return this.sourcesContent[contextSource];
***REMOVED***;

InputSourceMapStore.prototype.resolveSources = function (whenDone) ***REMOVED***
  var toResolve = [];

  for (var sourceFile in this.sourcesContent) ***REMOVED***
    var contents = this.sourcesContent[sourceFile];
    for (var originalFile in contents) ***REMOVED***
      if (!contents[originalFile])
        toResolve.push([sourceFile, originalFile]);
***REMOVED***
  ***REMOVED***

  return _resolveSources(this, toResolve, whenDone);
***REMOVED***;

module.exports = InputSourceMapStore;
