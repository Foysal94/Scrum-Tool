// Generated by CoffeeScript 1.10.0
(function() ***REMOVED***
  var Lexer, SourceMap, base, compile, ext, formatSourcePosition, fs, getSourceMap, helpers, i, len, lexer, parser, path, ref, sourceMaps, vm, withPrettyErrors,
    hasProp = ***REMOVED******REMOVED***.hasOwnProperty,
    indexOf = [].indexOf || function(item) ***REMOVED*** for (var i = 0, l = this.length; i < l; i++) ***REMOVED*** if (i in this && this[i] === item) return i; ***REMOVED*** return -1; ***REMOVED***;

  fs = require('fs');

  vm = require('vm');

  path = require('path');

  Lexer = require('./lexer').Lexer;

  parser = require('./parser').parser;

  helpers = require('./helpers');

  SourceMap = require('./sourcemap');

  exports.VERSION = '1.10.0';

  exports.FILE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md'];

  exports.helpers = helpers;

  withPrettyErrors = function(fn) ***REMOVED***
    return function(code, options) ***REMOVED***
      var err, error;
      if (options == null) ***REMOVED***
        options = ***REMOVED******REMOVED***;
  ***REMOVED***
      try ***REMOVED***
        return fn.call(this, code, options);
  ***REMOVED*** catch (error) ***REMOVED***
        err = error;
        if (typeof code !== 'string') ***REMOVED***
          throw err;
***REMOVED***
        throw helpers.updateSyntaxError(err, code, options.filename);
  ***REMOVED***
***REMOVED***;
  ***REMOVED***;

  exports.compile = compile = withPrettyErrors(function(code, options) ***REMOVED***
    var answer, currentColumn, currentLine, extend, fragment, fragments, header, i, js, len, map, merge, newLines, token, tokens;
    merge = helpers.merge, extend = helpers.extend;
    options = extend(***REMOVED******REMOVED***, options);
    if (options.sourceMap) ***REMOVED***
      map = new SourceMap;
***REMOVED***
    tokens = lexer.tokenize(code, options);
    options.referencedVars = (function() ***REMOVED***
      var i, len, results;
      results = [];
      for (i = 0, len = tokens.length; i < len; i++) ***REMOVED***
        token = tokens[i];
        if (token.variable) ***REMOVED***
          results.push(token[1]);
***REMOVED***
  ***REMOVED***
      return results;
***REMOVED***)();
    fragments = parser.parse(tokens).compileToFragments(options);
    currentLine = 0;
    if (options.header) ***REMOVED***
      currentLine += 1;
***REMOVED***
    if (options.shiftLine) ***REMOVED***
      currentLine += 1;
***REMOVED***
    currentColumn = 0;
    js = "";
    for (i = 0, len = fragments.length; i < len; i++) ***REMOVED***
      fragment = fragments[i];
      if (options.sourceMap) ***REMOVED***
        if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) ***REMOVED***
          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], ***REMOVED***
            noReplace: true
  ***REMOVED***);
***REMOVED***
        newLines = helpers.count(fragment.code, "\n");
        currentLine += newLines;
        if (newLines) ***REMOVED***
          currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
***REMOVED*** else ***REMOVED***
          currentColumn += fragment.code.length;
***REMOVED***
  ***REMOVED***
      js += fragment.code;
***REMOVED***
    if (options.header) ***REMOVED***
      header = "Generated by CoffeeScript " + this.VERSION;
      js = "// " + header + "\n" + js;
***REMOVED***
    if (options.sourceMap) ***REMOVED***
      answer = ***REMOVED***
        js: js
  ***REMOVED***;
      answer.sourceMap = map;
      answer.v3SourceMap = map.generate(options, code);
      return answer;
***REMOVED*** else ***REMOVED***
      return js;
***REMOVED***
  ***REMOVED***);

  exports.tokens = withPrettyErrors(function(code, options) ***REMOVED***
    return lexer.tokenize(code, options);
  ***REMOVED***);

  exports.nodes = withPrettyErrors(function(source, options) ***REMOVED***
    if (typeof source === 'string') ***REMOVED***
      return parser.parse(lexer.tokenize(source, options));
***REMOVED*** else ***REMOVED***
      return parser.parse(source);
***REMOVED***
  ***REMOVED***);

  exports.run = function(code, options) ***REMOVED***
    var answer, dir, mainModule, ref;
    if (options == null) ***REMOVED***
      options = ***REMOVED******REMOVED***;
***REMOVED***
    mainModule = require.main;
    mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : '.';
    mainModule.moduleCache && (mainModule.moduleCache = ***REMOVED******REMOVED***);
    dir = options.filename ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync('.');
    mainModule.paths = require('module')._nodeModulePaths(dir);
    if (!helpers.isCoffee(mainModule.filename) || require.extensions) ***REMOVED***
      answer = compile(code, options);
      code = (ref = answer.js) != null ? ref : answer;
***REMOVED***
    return mainModule._compile(code, mainModule.filename);
  ***REMOVED***;

  exports["eval"] = function(code, options) ***REMOVED***
    var Module, _module, _require, createContext, i, isContext, js, k, len, o, r, ref, ref1, ref2, ref3, sandbox, v;
    if (options == null) ***REMOVED***
      options = ***REMOVED******REMOVED***;
***REMOVED***
    if (!(code = code.trim())) ***REMOVED***
      return;
***REMOVED***
    createContext = (ref = vm.Script.createContext) != null ? ref : vm.createContext;
    isContext = (ref1 = vm.isContext) != null ? ref1 : function(ctx) ***REMOVED***
      return options.sandbox instanceof createContext().constructor;
***REMOVED***;
    if (createContext) ***REMOVED***
      if (options.sandbox != null) ***REMOVED***
        if (isContext(options.sandbox)) ***REMOVED***
          sandbox = options.sandbox;
***REMOVED*** else ***REMOVED***
          sandbox = createContext();
          ref2 = options.sandbox;
          for (k in ref2) ***REMOVED***
            if (!hasProp.call(ref2, k)) continue;
            v = ref2[k];
            sandbox[k] = v;
  ***REMOVED***
***REMOVED***
        sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
  ***REMOVED*** else ***REMOVED***
        sandbox = global;
  ***REMOVED***
      sandbox.__filename = options.filename || 'eval';
      sandbox.__dirname = path.dirname(sandbox.__filename);
      if (!(sandbox !== global || sandbox.module || sandbox.require)) ***REMOVED***
        Module = require('module');
        sandbox.module = _module = new Module(options.modulename || 'eval');
        sandbox.require = _require = function(path) ***REMOVED***
          return Module._load(path, _module, true);
***REMOVED***;
        _module.filename = sandbox.__filename;
        ref3 = Object.getOwnPropertyNames(require);
        for (i = 0, len = ref3.length; i < len; i++) ***REMOVED***
          r = ref3[i];
          if (r !== 'paths' && r !== 'arguments' && r !== 'caller') ***REMOVED***
            _require[r] = require[r];
  ***REMOVED***
***REMOVED***
        _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());
        _require.resolve = function(request) ***REMOVED***
          return Module._resolveFilename(request, _module);
***REMOVED***;
  ***REMOVED***
***REMOVED***
    o = ***REMOVED******REMOVED***;
    for (k in options) ***REMOVED***
      if (!hasProp.call(options, k)) continue;
      v = options[k];
      o[k] = v;
***REMOVED***
    o.bare = true;
    js = compile(code, o);
    if (sandbox === global) ***REMOVED***
      return vm.runInThisContext(js);
***REMOVED*** else ***REMOVED***
      return vm.runInContext(js, sandbox);
***REMOVED***
  ***REMOVED***;

  exports.register = function() ***REMOVED***
    return require('./register');
  ***REMOVED***;

  if (require.extensions) ***REMOVED***
    ref = this.FILE_EXTENSIONS;
    for (i = 0, len = ref.length; i < len; i++) ***REMOVED***
      ext = ref[i];
      if ((base = require.extensions)[ext] == null) ***REMOVED***
        base[ext] = function() ***REMOVED***
          throw new Error("Use CoffeeScript.register() or require the coffee-script/register module to require " + ext + " files.");
***REMOVED***;
  ***REMOVED***
***REMOVED***
  ***REMOVED***

  exports._compileFile = function(filename, sourceMap) ***REMOVED***
    var answer, err, error, raw, stripped;
    if (sourceMap == null) ***REMOVED***
      sourceMap = false;
***REMOVED***
    raw = fs.readFileSync(filename, 'utf8');
    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
    try ***REMOVED***
      answer = compile(stripped, ***REMOVED***
        filename: filename,
        sourceMap: sourceMap,
        literate: helpers.isLiterate(filename)
  ***REMOVED***);
***REMOVED*** catch (error) ***REMOVED***
      err = error;
      throw helpers.updateSyntaxError(err, stripped, filename);
***REMOVED***
    return answer;
  ***REMOVED***;

  lexer = new Lexer;

  parser.lexer = ***REMOVED***
    lex: function() ***REMOVED***
      var tag, token;
      token = parser.tokens[this.pos++];
      if (token) ***REMOVED***
        tag = token[0], this.yytext = token[1], this.yylloc = token[2];
        parser.errorToken = token.origin || token;
        this.yylineno = this.yylloc.first_line;
  ***REMOVED*** else ***REMOVED***
        tag = '';
  ***REMOVED***
      return tag;
***REMOVED***,
    setInput: function(tokens) ***REMOVED***
      parser.tokens = tokens;
      return this.pos = 0;
***REMOVED***,
    upcomingInput: function() ***REMOVED***
      return "";
***REMOVED***
  ***REMOVED***;

  parser.yy = require('./nodes');

  parser.yy.parseError = function(message, arg) ***REMOVED***
    var errorLoc, errorTag, errorText, errorToken, token, tokens;
    token = arg.token;
    errorToken = parser.errorToken, tokens = parser.tokens;
    errorTag = errorToken[0], errorText = errorToken[1], errorLoc = errorToken[2];
    errorText = (function() ***REMOVED***
      switch (false) ***REMOVED***
        case errorToken !== tokens[tokens.length - 1]:
          return 'end of input';
        case errorTag !== 'INDENT' && errorTag !== 'OUTDENT':
          return 'indentation';
        case errorTag !== 'IDENTIFIER' && errorTag !== 'NUMBER' && errorTag !== 'STRING' && errorTag !== 'STRING_START' && errorTag !== 'REGEX' && errorTag !== 'REGEX_START':
          return errorTag.replace(/_START$/, '').toLowerCase();
        default:
          return helpers.nameWhitespaceCharacter(errorText);
  ***REMOVED***
***REMOVED***)();
    return helpers.throwSyntaxError("unexpected " + errorText, errorLoc);
  ***REMOVED***;

  formatSourcePosition = function(frame, getSourceMapping) ***REMOVED***
    var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
    fileName = void 0;
    fileLocation = '';
    if (frame.isNative()) ***REMOVED***
      fileLocation = "native";
***REMOVED*** else ***REMOVED***
      if (frame.isEval()) ***REMOVED***
        fileName = frame.getScriptNameOrSourceURL();
        if (!fileName) ***REMOVED***
          fileLocation = (frame.getEvalOrigin()) + ", ";
***REMOVED***
  ***REMOVED*** else ***REMOVED***
        fileName = frame.getFileName();
  ***REMOVED***
      fileName || (fileName = "<anonymous>");
      line = frame.getLineNumber();
      column = frame.getColumnNumber();
      source = getSourceMapping(fileName, line, column);
      fileLocation = source ? fileName + ":" + source[0] + ":" + source[1] : fileName + ":" + line + ":" + column;
***REMOVED***
    functionName = frame.getFunctionName();
    isConstructor = frame.isConstructor();
    isMethodCall = !(frame.isToplevel() || isConstructor);
    if (isMethodCall) ***REMOVED***
      methodName = frame.getMethodName();
      typeName = frame.getTypeName();
      if (functionName) ***REMOVED***
        tp = as = '';
        if (typeName && functionName.indexOf(typeName)) ***REMOVED***
          tp = typeName + ".";
***REMOVED***
        if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) ***REMOVED***
          as = " [as " + methodName + "]";
***REMOVED***
        return "" + tp + functionName + as + " (" + fileLocation + ")";
  ***REMOVED*** else ***REMOVED***
        return typeName + "." + (methodName || '<anonymous>') + " (" + fileLocation + ")";
  ***REMOVED***
***REMOVED*** else if (isConstructor) ***REMOVED***
      return "new " + (functionName || '<anonymous>') + " (" + fileLocation + ")";
***REMOVED*** else if (functionName) ***REMOVED***
      return functionName + " (" + fileLocation + ")";
***REMOVED*** else ***REMOVED***
      return fileLocation;
***REMOVED***
  ***REMOVED***;

  sourceMaps = ***REMOVED******REMOVED***;

  getSourceMap = function(filename) ***REMOVED***
    var answer, ref1;
    if (sourceMaps[filename]) ***REMOVED***
      return sourceMaps[filename];
***REMOVED***
    if (ref1 = path != null ? path.extname(filename) : void 0, indexOf.call(exports.FILE_EXTENSIONS, ref1) < 0) ***REMOVED***
      return;
***REMOVED***
    answer = exports._compileFile(filename, true);
    return sourceMaps[filename] = answer.sourceMap;
  ***REMOVED***;

  Error.prepareStackTrace = function(err, stack) ***REMOVED***
    var frame, frames, getSourceMapping;
    getSourceMapping = function(filename, line, column) ***REMOVED***
      var answer, sourceMap;
      sourceMap = getSourceMap(filename);
      if (sourceMap) ***REMOVED***
        answer = sourceMap.sourceLocation([line - 1, column - 1]);
  ***REMOVED***
      if (answer) ***REMOVED***
        return [answer[0] + 1, answer[1] + 1];
  ***REMOVED*** else ***REMOVED***
        return null;
  ***REMOVED***
***REMOVED***;
    frames = (function() ***REMOVED***
      var j, len1, results;
      results = [];
      for (j = 0, len1 = stack.length; j < len1; j++) ***REMOVED***
        frame = stack[j];
        if (frame.getFunction() === exports.run) ***REMOVED***
          break;
***REMOVED***
        results.push("  at " + (formatSourcePosition(frame, getSourceMapping)));
  ***REMOVED***
      return results;
***REMOVED***)();
    return (err.toString()) + "\n" + (frames.join('\n')) + "\n";
  ***REMOVED***;

***REMOVED***).call(this);
