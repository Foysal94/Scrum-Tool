// Generated by CoffeeScript 1.10.0
(function() ***REMOVED***
  var buildLocationData, extend, flatten, ref, repeat, syntaxErrorToString;

  exports.starts = function(string, literal, start) ***REMOVED***
    return literal === string.substr(start, literal.length);
  ***REMOVED***;

  exports.ends = function(string, literal, back) ***REMOVED***
    var len;
    len = literal.length;
    return literal === string.substr(string.length - len - (back || 0), len);
  ***REMOVED***;

  exports.repeat = repeat = function(str, n) ***REMOVED***
    var res;
    res = '';
    while (n > 0) ***REMOVED***
      if (n & 1) ***REMOVED***
        res += str;
  ***REMOVED***
      n >>>= 1;
      str += str;
***REMOVED***
    return res;
  ***REMOVED***;

  exports.compact = function(array) ***REMOVED***
    var i, item, len1, results;
    results = [];
    for (i = 0, len1 = array.length; i < len1; i++) ***REMOVED***
      item = array[i];
      if (item) ***REMOVED***
        results.push(item);
  ***REMOVED***
***REMOVED***
    return results;
  ***REMOVED***;

  exports.count = function(string, substr) ***REMOVED***
    var num, pos;
    num = pos = 0;
    if (!substr.length) ***REMOVED***
      return 1 / 0;
***REMOVED***
    while (pos = 1 + string.indexOf(substr, pos)) ***REMOVED***
      num++;
***REMOVED***
    return num;
  ***REMOVED***;

  exports.merge = function(options, overrides) ***REMOVED***
    return extend(extend(***REMOVED******REMOVED***, options), overrides);
  ***REMOVED***;

  extend = exports.extend = function(object, properties) ***REMOVED***
    var key, val;
    for (key in properties) ***REMOVED***
      val = properties[key];
      object[key] = val;
***REMOVED***
    return object;
  ***REMOVED***;

  exports.flatten = flatten = function(array) ***REMOVED***
    var element, flattened, i, len1;
    flattened = [];
    for (i = 0, len1 = array.length; i < len1; i++) ***REMOVED***
      element = array[i];
      if ('[object Array]' === Object.prototype.toString.call(element)) ***REMOVED***
        flattened = flattened.concat(flatten(element));
  ***REMOVED*** else ***REMOVED***
        flattened.push(element);
  ***REMOVED***
***REMOVED***
    return flattened;
  ***REMOVED***;

  exports.del = function(obj, key) ***REMOVED***
    var val;
    val = obj[key];
    delete obj[key];
    return val;
  ***REMOVED***;

  exports.some = (ref = Array.prototype.some) != null ? ref : function(fn) ***REMOVED***
    var e, i, len1;
    for (i = 0, len1 = this.length; i < len1; i++) ***REMOVED***
      e = this[i];
      if (fn(e)) ***REMOVED***
        return true;
  ***REMOVED***
***REMOVED***
    return false;
  ***REMOVED***;

  exports.invertLiterate = function(code) ***REMOVED***
    var line, lines, maybe_code;
    maybe_code = true;
    lines = (function() ***REMOVED***
      var i, len1, ref1, results;
      ref1 = code.split('\n');
      results = [];
      for (i = 0, len1 = ref1.length; i < len1; i++) ***REMOVED***
        line = ref1[i];
        if (maybe_code && /^([ ]***REMOVED***4***REMOVED***|[ ]***REMOVED***0,3***REMOVED***\t)/.test(line)) ***REMOVED***
          results.push(line);
***REMOVED*** else if (maybe_code = /^\s*$/.test(line)) ***REMOVED***
          results.push(line);
***REMOVED*** else ***REMOVED***
          results.push('# ' + line);
***REMOVED***
  ***REMOVED***
      return results;
***REMOVED***)();
    return lines.join('\n');
  ***REMOVED***;

  buildLocationData = function(first, last) ***REMOVED***
    if (!last) ***REMOVED***
      return first;
***REMOVED*** else ***REMOVED***
      return ***REMOVED***
        first_line: first.first_line,
        first_column: first.first_column,
        last_line: last.last_line,
        last_column: last.last_column
  ***REMOVED***;
***REMOVED***
  ***REMOVED***;

  exports.addLocationDataFn = function(first, last) ***REMOVED***
    return function(obj) ***REMOVED***
      if (((typeof obj) === 'object') && (!!obj['updateLocationDataIfMissing'])) ***REMOVED***
        obj.updateLocationDataIfMissing(buildLocationData(first, last));
  ***REMOVED***
      return obj;
***REMOVED***;
  ***REMOVED***;

  exports.locationDataToString = function(obj) ***REMOVED***
    var locationData;
    if (("2" in obj) && ("first_line" in obj[2])) ***REMOVED***
      locationData = obj[2];
***REMOVED*** else if ("first_line" in obj) ***REMOVED***
      locationData = obj;
***REMOVED***
    if (locationData) ***REMOVED***
      return ((locationData.first_line + 1) + ":" + (locationData.first_column + 1) + "-") + ((locationData.last_line + 1) + ":" + (locationData.last_column + 1));
***REMOVED*** else ***REMOVED***
      return "No location data";
***REMOVED***
  ***REMOVED***;

  exports.baseFileName = function(file, stripExt, useWinPathSep) ***REMOVED***
    var parts, pathSep;
    if (stripExt == null) ***REMOVED***
      stripExt = false;
***REMOVED***
    if (useWinPathSep == null) ***REMOVED***
      useWinPathSep = false;
***REMOVED***
    pathSep = useWinPathSep ? /\\|\// : /\//;
    parts = file.split(pathSep);
    file = parts[parts.length - 1];
    if (!(stripExt && file.indexOf('.') >= 0)) ***REMOVED***
      return file;
***REMOVED***
    parts = file.split('.');
    parts.pop();
    if (parts[parts.length - 1] === 'coffee' && parts.length > 1) ***REMOVED***
      parts.pop();
***REMOVED***
    return parts.join('.');
  ***REMOVED***;

  exports.isCoffee = function(file) ***REMOVED***
    return /\.((lit)?coffee|coffee\.md)$/.test(file);
  ***REMOVED***;

  exports.isLiterate = function(file) ***REMOVED***
    return /\.(litcoffee|coffee\.md)$/.test(file);
  ***REMOVED***;

  exports.throwSyntaxError = function(message, location) ***REMOVED***
    var error;
    error = new SyntaxError(message);
    error.location = location;
    error.toString = syntaxErrorToString;
    error.stack = error.toString();
    throw error;
  ***REMOVED***;

  exports.updateSyntaxError = function(error, code, filename) ***REMOVED***
    if (error.toString === syntaxErrorToString) ***REMOVED***
      error.code || (error.code = code);
      error.filename || (error.filename = filename);
      error.stack = error.toString();
***REMOVED***
    return error;
  ***REMOVED***;

  syntaxErrorToString = function() ***REMOVED***
    var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, ref1, ref2, ref3, ref4, start;
    if (!(this.code && this.location)) ***REMOVED***
      return Error.prototype.toString.call(this);
***REMOVED***
    ref1 = this.location, first_line = ref1.first_line, first_column = ref1.first_column, last_line = ref1.last_line, last_column = ref1.last_column;
    if (last_line == null) ***REMOVED***
      last_line = first_line;
***REMOVED***
    if (last_column == null) ***REMOVED***
      last_column = first_column;
***REMOVED***
    filename = this.filename || '[stdin]';
    codeLine = this.code.split('\n')[first_line];
    start = first_column;
    end = first_line === last_line ? last_column + 1 : codeLine.length;
    marker = codeLine.slice(0, start).replace(/[^\s]/g, ' ') + repeat('^', end - start);
    if (typeof process !== "undefined" && process !== null) ***REMOVED***
      colorsEnabled = ((ref2 = process.stdout) != null ? ref2.isTTY : void 0) && !((ref3 = process.env) != null ? ref3.NODE_DISABLE_COLORS : void 0);
***REMOVED***
    if ((ref4 = this.colorful) != null ? ref4 : colorsEnabled) ***REMOVED***
      colorize = function(str) ***REMOVED***
        return "\x1B[1;31m" + str + "\x1B[0m";
  ***REMOVED***;
      codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
      marker = colorize(marker);
***REMOVED***
    return filename + ":" + (first_line + 1) + ":" + (first_column + 1) + ": error: " + this.message + "\n" + codeLine + "\n" + marker;
  ***REMOVED***;

  exports.nameWhitespaceCharacter = function(string) ***REMOVED***
    switch (string) ***REMOVED***
      case ' ':
        return 'space';
      case '\n':
        return 'newline';
      case '\r':
        return 'carriage return';
      case '\t':
        return 'tab';
      default:
        return string;
***REMOVED***
  ***REMOVED***;

***REMOVED***).call(this);
