// Generated by CoffeeScript 1.10.0
(function() ***REMOVED***
  var BOM, BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARE, COMPOUND_ASSIGN, HERECOMMENT_ILLEGAL, HEREDOC_DOUBLE, HEREDOC_INDENT, HEREDOC_SINGLE, HEREGEX, HEREGEX_OMIT, IDENTIFIER, INDENTABLE_CLOSERS, INDEXABLE, INVALID_ESCAPE, INVERSES, JSTOKEN, JS_FORBIDDEN, JS_KEYWORDS, LEADING_BLANK_LINE, LINE_BREAK, LINE_CONTINUER, LOGIC, Lexer, MATH, MULTI_DENT, NOT_REGEX, NUMBER, OPERATOR, POSSIBLY_DIVISION, REGEX, REGEX_FLAGS, REGEX_ILLEGAL, RELATION, RESERVED, Rewriter, SHIFT, SIMPLE_STRING_OMIT, STRICT_PROSCRIBED, STRING_DOUBLE, STRING_OMIT, STRING_SINGLE, STRING_START, TRAILING_BLANK_LINE, TRAILING_SPACES, UNARY, UNARY_MATH, VALID_FLAGS, WHITESPACE, compact, count, invertLiterate, key, locationDataToString, ref, ref1, repeat, starts, throwSyntaxError,
    indexOf = [].indexOf || function(item) ***REMOVED*** for (var i = 0, l = this.length; i < l; i++) ***REMOVED*** if (i in this && this[i] === item) return i; ***REMOVED*** return -1; ***REMOVED***;

  ref = require('./rewriter'), Rewriter = ref.Rewriter, INVERSES = ref.INVERSES;

  ref1 = require('./helpers'), count = ref1.count, starts = ref1.starts, compact = ref1.compact, repeat = ref1.repeat, invertLiterate = ref1.invertLiterate, locationDataToString = ref1.locationDataToString, throwSyntaxError = ref1.throwSyntaxError;

  exports.Lexer = Lexer = (function() ***REMOVED***
    function Lexer() ***REMOVED******REMOVED***

    Lexer.prototype.tokenize = function(code, opts) ***REMOVED***
      var consumed, end, i, ref2;
      if (opts == null) ***REMOVED***
        opts = ***REMOVED******REMOVED***;
  ***REMOVED***
      this.literate = opts.literate;
      this.indent = 0;
      this.baseIndent = 0;
      this.indebt = 0;
      this.outdebt = 0;
      this.indents = [];
      this.ends = [];
      this.tokens = [];
      this.seenFor = false;
      this.chunkLine = opts.line || 0;
      this.chunkColumn = opts.column || 0;
      code = this.clean(code);
      i = 0;
      while (this.chunk = code.slice(i)) ***REMOVED***
        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();
        ref2 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = ref2[0], this.chunkColumn = ref2[1];
        i += consumed;
        if (opts.untilBalanced && this.ends.length === 0) ***REMOVED***
          return ***REMOVED***
            tokens: this.tokens,
            index: i
  ***REMOVED***;
***REMOVED***
  ***REMOVED***
      this.closeIndentation();
      if (end = this.ends.pop()) ***REMOVED***
        this.error("missing " + end.tag, end.origin[2]);
  ***REMOVED***
      if (opts.rewrite === false) ***REMOVED***
        return this.tokens;
  ***REMOVED***
      return (new Rewriter).rewrite(this.tokens);
***REMOVED***;

    Lexer.prototype.clean = function(code) ***REMOVED***
      if (code.charCodeAt(0) === BOM) ***REMOVED***
        code = code.slice(1);
  ***REMOVED***
      code = code.replace(/\r/g, '').replace(TRAILING_SPACES, '');
      if (WHITESPACE.test(code)) ***REMOVED***
        code = "\n" + code;
        this.chunkLine--;
  ***REMOVED***
      if (this.literate) ***REMOVED***
        code = invertLiterate(code);
  ***REMOVED***
      return code;
***REMOVED***;

    Lexer.prototype.identifierToken = function() ***REMOVED***
      var alias, colon, colonOffset, forcedIdentifier, id, idLength, input, match, poppedToken, prev, ref2, ref3, ref4, ref5, tag, tagToken;
      if (!(match = IDENTIFIER.exec(this.chunk))) ***REMOVED***
        return 0;
  ***REMOVED***
      input = match[0], id = match[1], colon = match[2];
      idLength = id.length;
      poppedToken = void 0;
      if (id === 'own' && this.tag() === 'FOR') ***REMOVED***
        this.token('OWN', id);
        return id.length;
  ***REMOVED***
      if (id === 'from' && this.tag() === 'YIELD') ***REMOVED***
        this.token('FROM', id);
        return id.length;
  ***REMOVED***
      ref2 = this.tokens, prev = ref2[ref2.length - 1];
      forcedIdentifier = colon || (prev != null) && (((ref3 = prev[0]) === '.' || ref3 === '?.' || ref3 === '::' || ref3 === '?::') || !prev.spaced && prev[0] === '@');
      tag = 'IDENTIFIER';
      if (!forcedIdentifier && (indexOf.call(JS_KEYWORDS, id) >= 0 || indexOf.call(COFFEE_KEYWORDS, id) >= 0)) ***REMOVED***
        tag = id.toUpperCase();
        if (tag === 'WHEN' && (ref4 = this.tag(), indexOf.call(LINE_BREAK, ref4) >= 0)) ***REMOVED***
          tag = 'LEADING_WHEN';
***REMOVED*** else if (tag === 'FOR') ***REMOVED***
          this.seenFor = true;
***REMOVED*** else if (tag === 'UNLESS') ***REMOVED***
          tag = 'IF';
***REMOVED*** else if (indexOf.call(UNARY, tag) >= 0) ***REMOVED***
          tag = 'UNARY';
***REMOVED*** else if (indexOf.call(RELATION, tag) >= 0) ***REMOVED***
          if (tag !== 'INSTANCEOF' && this.seenFor) ***REMOVED***
            tag = 'FOR' + tag;
            this.seenFor = false;
  ***REMOVED*** else ***REMOVED***
            tag = 'RELATION';
            if (this.value() === '!') ***REMOVED***
              poppedToken = this.tokens.pop();
              id = '!' + id;
***REMOVED***
  ***REMOVED***
***REMOVED***
  ***REMOVED***
      if (indexOf.call(JS_FORBIDDEN, id) >= 0) ***REMOVED***
        if (forcedIdentifier) ***REMOVED***
          tag = 'IDENTIFIER';
          id = new String(id);
          id.reserved = true;
***REMOVED*** else if (indexOf.call(RESERVED, id) >= 0) ***REMOVED***
          this.error("reserved word '" + id + "'", ***REMOVED***
            length: id.length
  ***REMOVED***);
***REMOVED***
  ***REMOVED***
      if (!forcedIdentifier) ***REMOVED***
        if (indexOf.call(COFFEE_ALIASES, id) >= 0) ***REMOVED***
          alias = id;
          id = COFFEE_ALIAS_MAP[id];
***REMOVED***
        tag = (function() ***REMOVED***
          switch (id) ***REMOVED***
            case '!':
              return 'UNARY';
            case '==':
            case '!=':
              return 'COMPARE';
            case '&&':
            case '||':
              return 'LOGIC';
            case 'true':
            case 'false':
              return 'BOOL';
            case 'break':
            case 'continue':
              return 'STATEMENT';
            default:
              return tag;
  ***REMOVED***
***REMOVED***)();
  ***REMOVED***
      tagToken = this.token(tag, id, 0, idLength);
      if (alias) ***REMOVED***
        tagToken.origin = [tag, alias, tagToken[2]];
  ***REMOVED***
      tagToken.variable = !forcedIdentifier;
      if (poppedToken) ***REMOVED***
        ref5 = [poppedToken[2].first_line, poppedToken[2].first_column], tagToken[2].first_line = ref5[0], tagToken[2].first_column = ref5[1];
  ***REMOVED***
      if (colon) ***REMOVED***
        colonOffset = input.lastIndexOf(':');
        this.token(':', ':', colonOffset, colon.length);
  ***REMOVED***
      return input.length;
***REMOVED***;

    Lexer.prototype.numberToken = function() ***REMOVED***
      var binaryLiteral, lexedLength, match, number, octalLiteral;
      if (!(match = NUMBER.exec(this.chunk))) ***REMOVED***
        return 0;
  ***REMOVED***
      number = match[0];
      lexedLength = number.length;
      if (/^0[BOX]/.test(number)) ***REMOVED***
        this.error("radix prefix in '" + number + "' must be lowercase", ***REMOVED***
          offset: 1
***REMOVED***);
  ***REMOVED*** else if (/E/.test(number) && !/^0x/.test(number)) ***REMOVED***
        this.error("exponential notation in '" + number + "' must be indicated with a lowercase 'e'", ***REMOVED***
          offset: number.indexOf('E')
***REMOVED***);
  ***REMOVED*** else if (/^0\d*[89]/.test(number)) ***REMOVED***
        this.error("decimal literal '" + number + "' must not be prefixed with '0'", ***REMOVED***
          length: lexedLength
***REMOVED***);
  ***REMOVED*** else if (/^0\d+/.test(number)) ***REMOVED***
        this.error("octal literal '" + number + "' must be prefixed with '0o'", ***REMOVED***
          length: lexedLength
***REMOVED***);
  ***REMOVED***
      if (octalLiteral = /^0o([0-7]+)/.exec(number)) ***REMOVED***
        number = '0x' + parseInt(octalLiteral[1], 8).toString(16);
  ***REMOVED***
      if (binaryLiteral = /^0b([01]+)/.exec(number)) ***REMOVED***
        number = '0x' + parseInt(binaryLiteral[1], 2).toString(16);
  ***REMOVED***
      this.token('NUMBER', number, 0, lexedLength);
      return lexedLength;
***REMOVED***;

    Lexer.prototype.stringToken = function() ***REMOVED***
      var $, attempt, delimiter, doc, end, heredoc, i, indent, indentRegex, match, quote, ref2, ref3, regex, token, tokens;
      quote = (STRING_START.exec(this.chunk) || [])[0];
      if (!quote) ***REMOVED***
        return 0;
  ***REMOVED***
      regex = (function() ***REMOVED***
        switch (quote) ***REMOVED***
          case "'":
            return STRING_SINGLE;
          case '"':
            return STRING_DOUBLE;
          case "'''":
            return HEREDOC_SINGLE;
          case '"""':
            return HEREDOC_DOUBLE;
***REMOVED***
  ***REMOVED***)();
      heredoc = quote.length === 3;
      ref2 = this.matchWithInterpolations(regex, quote), tokens = ref2.tokens, end = ref2.index;
      $ = tokens.length - 1;
      delimiter = quote.charAt(0);
      if (heredoc) ***REMOVED***
        indent = null;
        doc = ((function() ***REMOVED***
          var j, len, results;
          results = [];
          for (i = j = 0, len = tokens.length; j < len; i = ++j) ***REMOVED***
            token = tokens[i];
            if (token[0] === 'NEOSTRING') ***REMOVED***
              results.push(token[1]);
***REMOVED***
  ***REMOVED***
          return results;
***REMOVED***)()).join('#***REMOVED******REMOVED***');
        while (match = HEREDOC_INDENT.exec(doc)) ***REMOVED***
          attempt = match[1];
          if (indent === null || (0 < (ref3 = attempt.length) && ref3 < indent.length)) ***REMOVED***
            indent = attempt;
  ***REMOVED***
***REMOVED***
        if (indent) ***REMOVED***
          indentRegex = RegExp("^" + indent, "gm");
***REMOVED***
        this.mergeInterpolationTokens(tokens, ***REMOVED***
          delimiter: delimiter
***REMOVED***, (function(_this) ***REMOVED***
          return function(value, i) ***REMOVED***
            value = _this.formatString(value);
            if (i === 0) ***REMOVED***
              value = value.replace(LEADING_BLANK_LINE, '');
***REMOVED***
            if (i === $) ***REMOVED***
              value = value.replace(TRAILING_BLANK_LINE, '');
***REMOVED***
            if (indentRegex) ***REMOVED***
              value = value.replace(indentRegex, '');
***REMOVED***
            return value;
  ***REMOVED***;
***REMOVED***)(this));
  ***REMOVED*** else ***REMOVED***
        this.mergeInterpolationTokens(tokens, ***REMOVED***
          delimiter: delimiter
***REMOVED***, (function(_this) ***REMOVED***
          return function(value, i) ***REMOVED***
            value = _this.formatString(value);
            value = value.replace(SIMPLE_STRING_OMIT, function(match, offset) ***REMOVED***
              if ((i === 0 && offset === 0) || (i === $ && offset + match.length === value.length)) ***REMOVED***
                return '';
  ***REMOVED*** else ***REMOVED***
                return ' ';
  ***REMOVED***
***REMOVED***);
            return value;
  ***REMOVED***;
***REMOVED***)(this));
  ***REMOVED***
      return end;
***REMOVED***;

    Lexer.prototype.commentToken = function() ***REMOVED***
      var comment, here, match;
      if (!(match = this.chunk.match(COMMENT))) ***REMOVED***
        return 0;
  ***REMOVED***
      comment = match[0], here = match[1];
      if (here) ***REMOVED***
        if (match = HERECOMMENT_ILLEGAL.exec(comment)) ***REMOVED***
          this.error("block comments cannot contain " + match[0], ***REMOVED***
            offset: match.index,
            length: match[0].length
  ***REMOVED***);
***REMOVED***
        if (here.indexOf('\n') >= 0) ***REMOVED***
          here = here.replace(RegExp("\\n" + (repeat(' ', this.indent)), "g"), '\n');
***REMOVED***
        this.token('HERECOMMENT', here, 0, comment.length);
  ***REMOVED***
      return comment.length;
***REMOVED***;

    Lexer.prototype.jsToken = function() ***REMOVED***
      var match, script;
      if (!(this.chunk.charAt(0) === '`' && (match = JSTOKEN.exec(this.chunk)))) ***REMOVED***
        return 0;
  ***REMOVED***
      this.token('JS', (script = match[0]).slice(1, -1), 0, script.length);
      return script.length;
***REMOVED***;

    Lexer.prototype.regexToken = function() ***REMOVED***
      var body, closed, end, flags, index, match, origin, prev, ref2, ref3, ref4, regex, tokens;
      switch (false) ***REMOVED***
        case !(match = REGEX_ILLEGAL.exec(this.chunk)):
          this.error("regular expressions cannot begin with " + match[2], ***REMOVED***
            offset: match.index + match[1].length
  ***REMOVED***);
          break;
        case !(match = this.matchWithInterpolations(HEREGEX, '///')):
          tokens = match.tokens, index = match.index;
          break;
        case !(match = REGEX.exec(this.chunk)):
          regex = match[0], body = match[1], closed = match[2];
          this.validateEscapes(body, ***REMOVED***
            isRegex: true,
            offsetInChunk: 1
  ***REMOVED***);
          index = regex.length;
          ref2 = this.tokens, prev = ref2[ref2.length - 1];
          if (prev) ***REMOVED***
            if (prev.spaced && (ref3 = prev[0], indexOf.call(CALLABLE, ref3) >= 0)) ***REMOVED***
              if (!closed || POSSIBLY_DIVISION.test(regex)) ***REMOVED***
                return 0;
  ***REMOVED***
***REMOVED*** else if (ref4 = prev[0], indexOf.call(NOT_REGEX, ref4) >= 0) ***REMOVED***
              return 0;
***REMOVED***
  ***REMOVED***
          if (!closed) ***REMOVED***
            this.error('missing / (unclosed regex)');
  ***REMOVED***
          break;
        default:
          return 0;
  ***REMOVED***
      flags = REGEX_FLAGS.exec(this.chunk.slice(index))[0];
      end = index + flags.length;
      origin = this.makeToken('REGEX', null, 0, end);
      switch (false) ***REMOVED***
        case !!VALID_FLAGS.test(flags):
          this.error("invalid regular expression flags " + flags, ***REMOVED***
            offset: index,
            length: flags.length
  ***REMOVED***);
          break;
        case !(regex || tokens.length === 1):
          if (body == null) ***REMOVED***
            body = this.formatHeregex(tokens[0][1]);
  ***REMOVED***
          this.token('REGEX', "" + (this.makeDelimitedLiteral(body, ***REMOVED***
            delimiter: '/'
  ***REMOVED***)) + flags, 0, end, origin);
          break;
        default:
          this.token('REGEX_START', '(', 0, 0, origin);
          this.token('IDENTIFIER', 'RegExp', 0, 0);
          this.token('CALL_START', '(', 0, 0);
          this.mergeInterpolationTokens(tokens, ***REMOVED***
            delimiter: '"',
            double: true
  ***REMOVED***, this.formatHeregex);
          if (flags) ***REMOVED***
            this.token(',', ',', index, 0);
            this.token('STRING', '"' + flags + '"', index, flags.length);
  ***REMOVED***
          this.token(')', ')', end, 0);
          this.token('REGEX_END', ')', end, 0);
  ***REMOVED***
      return end;
***REMOVED***;

    Lexer.prototype.lineToken = function() ***REMOVED***
      var diff, indent, match, noNewlines, size;
      if (!(match = MULTI_DENT.exec(this.chunk))) ***REMOVED***
        return 0;
  ***REMOVED***
      indent = match[0];
      this.seenFor = false;
      size = indent.length - 1 - indent.lastIndexOf('\n');
      noNewlines = this.unfinished();
      if (size - this.indebt === this.indent) ***REMOVED***
        if (noNewlines) ***REMOVED***
          this.suppressNewlines();
***REMOVED*** else ***REMOVED***
          this.newlineToken(0);
***REMOVED***
        return indent.length;
  ***REMOVED***
      if (size > this.indent) ***REMOVED***
        if (noNewlines) ***REMOVED***
          this.indebt = size - this.indent;
          this.suppressNewlines();
          return indent.length;
***REMOVED***
        if (!this.tokens.length) ***REMOVED***
          this.baseIndent = this.indent = size;
          return indent.length;
***REMOVED***
        diff = size - this.indent + this.outdebt;
        this.token('INDENT', diff, indent.length - size, size);
        this.indents.push(diff);
        this.ends.push(***REMOVED***
          tag: 'OUTDENT'
***REMOVED***);
        this.outdebt = this.indebt = 0;
        this.indent = size;
  ***REMOVED*** else if (size < this.baseIndent) ***REMOVED***
        this.error('missing indentation', ***REMOVED***
          offset: indent.length
***REMOVED***);
  ***REMOVED*** else ***REMOVED***
        this.indebt = 0;
        this.outdentToken(this.indent - size, noNewlines, indent.length);
  ***REMOVED***
      return indent.length;
***REMOVED***;

    Lexer.prototype.outdentToken = function(moveOut, noNewlines, outdentLength) ***REMOVED***
      var decreasedIndent, dent, lastIndent, ref2;
      decreasedIndent = this.indent - moveOut;
      while (moveOut > 0) ***REMOVED***
        lastIndent = this.indents[this.indents.length - 1];
        if (!lastIndent) ***REMOVED***
          moveOut = 0;
***REMOVED*** else if (lastIndent === this.outdebt) ***REMOVED***
          moveOut -= this.outdebt;
          this.outdebt = 0;
***REMOVED*** else if (lastIndent < this.outdebt) ***REMOVED***
          this.outdebt -= lastIndent;
          moveOut -= lastIndent;
***REMOVED*** else ***REMOVED***
          dent = this.indents.pop() + this.outdebt;
          if (outdentLength && (ref2 = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref2) >= 0)) ***REMOVED***
            decreasedIndent -= dent - moveOut;
            moveOut = dent;
  ***REMOVED***
          this.outdebt = 0;
          this.pair('OUTDENT');
          this.token('OUTDENT', moveOut, 0, outdentLength);
          moveOut -= dent;
***REMOVED***
  ***REMOVED***
      if (dent) ***REMOVED***
        this.outdebt -= moveOut;
  ***REMOVED***
      while (this.value() === ';') ***REMOVED***
        this.tokens.pop();
  ***REMOVED***
      if (!(this.tag() === 'TERMINATOR' || noNewlines)) ***REMOVED***
        this.token('TERMINATOR', '\n', outdentLength, 0);
  ***REMOVED***
      this.indent = decreasedIndent;
      return this;
***REMOVED***;

    Lexer.prototype.whitespaceToken = function() ***REMOVED***
      var match, nline, prev, ref2;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\n'))) ***REMOVED***
        return 0;
  ***REMOVED***
      ref2 = this.tokens, prev = ref2[ref2.length - 1];
      if (prev) ***REMOVED***
        prev[match ? 'spaced' : 'newLine'] = true;
  ***REMOVED***
      if (match) ***REMOVED***
        return match[0].length;
  ***REMOVED*** else ***REMOVED***
        return 0;
  ***REMOVED***
***REMOVED***;

    Lexer.prototype.newlineToken = function(offset) ***REMOVED***
      while (this.value() === ';') ***REMOVED***
        this.tokens.pop();
  ***REMOVED***
      if (this.tag() !== 'TERMINATOR') ***REMOVED***
        this.token('TERMINATOR', '\n', offset, 0);
  ***REMOVED***
      return this;
***REMOVED***;

    Lexer.prototype.suppressNewlines = function() ***REMOVED***
      if (this.value() === '\\') ***REMOVED***
        this.tokens.pop();
  ***REMOVED***
      return this;
***REMOVED***;

    Lexer.prototype.literalToken = function() ***REMOVED***
      var match, prev, ref2, ref3, ref4, ref5, ref6, tag, token, value;
      if (match = OPERATOR.exec(this.chunk)) ***REMOVED***
        value = match[0];
        if (CODE.test(value)) ***REMOVED***
          this.tagParameters();
***REMOVED***
  ***REMOVED*** else ***REMOVED***
        value = this.chunk.charAt(0);
  ***REMOVED***
      tag = value;
      ref2 = this.tokens, prev = ref2[ref2.length - 1];
      if (value === '=' && prev) ***REMOVED***
        if (!prev[1].reserved && (ref3 = prev[1], indexOf.call(JS_FORBIDDEN, ref3) >= 0)) ***REMOVED***
          if (prev.origin) ***REMOVED***
            prev = prev.origin;
  ***REMOVED***
          this.error("reserved word '" + prev[1] + "' can't be assigned", prev[2]);
***REMOVED***
        if ((ref4 = prev[1]) === '||' || ref4 === '&&') ***REMOVED***
          prev[0] = 'COMPOUND_ASSIGN';
          prev[1] += '=';
          return value.length;
***REMOVED***
  ***REMOVED***
      if (value === ';') ***REMOVED***
        this.seenFor = false;
        tag = 'TERMINATOR';
  ***REMOVED*** else if (indexOf.call(MATH, value) >= 0) ***REMOVED***
        tag = 'MATH';
  ***REMOVED*** else if (indexOf.call(COMPARE, value) >= 0) ***REMOVED***
        tag = 'COMPARE';
  ***REMOVED*** else if (indexOf.call(COMPOUND_ASSIGN, value) >= 0) ***REMOVED***
        tag = 'COMPOUND_ASSIGN';
  ***REMOVED*** else if (indexOf.call(UNARY, value) >= 0) ***REMOVED***
        tag = 'UNARY';
  ***REMOVED*** else if (indexOf.call(UNARY_MATH, value) >= 0) ***REMOVED***
        tag = 'UNARY_MATH';
  ***REMOVED*** else if (indexOf.call(SHIFT, value) >= 0) ***REMOVED***
        tag = 'SHIFT';
  ***REMOVED*** else if (indexOf.call(LOGIC, value) >= 0 || value === '?' && (prev != null ? prev.spaced : void 0)) ***REMOVED***
        tag = 'LOGIC';
  ***REMOVED*** else if (prev && !prev.spaced) ***REMOVED***
        if (value === '(' && (ref5 = prev[0], indexOf.call(CALLABLE, ref5) >= 0)) ***REMOVED***
          if (prev[0] === '?') ***REMOVED***
            prev[0] = 'FUNC_EXIST';
  ***REMOVED***
          tag = 'CALL_START';
***REMOVED*** else if (value === '[' && (ref6 = prev[0], indexOf.call(INDEXABLE, ref6) >= 0)) ***REMOVED***
          tag = 'INDEX_START';
          switch (prev[0]) ***REMOVED***
            case '?':
              prev[0] = 'INDEX_SOAK';
  ***REMOVED***
***REMOVED***
  ***REMOVED***
      token = this.makeToken(tag, value);
      switch (value) ***REMOVED***
        case '(':
        case '***REMOVED***':
        case '[':
          this.ends.push(***REMOVED***
            tag: INVERSES[value],
            origin: token
  ***REMOVED***);
          break;
        case ')':
        case '***REMOVED***':
        case ']':
          this.pair(value);
  ***REMOVED***
      this.tokens.push(token);
      return value.length;
***REMOVED***;

    Lexer.prototype.tagParameters = function() ***REMOVED***
      var i, stack, tok, tokens;
      if (this.tag() !== ')') ***REMOVED***
        return this;
  ***REMOVED***
      stack = [];
      tokens = this.tokens;
      i = tokens.length;
      tokens[--i][0] = 'PARAM_END';
      while (tok = tokens[--i]) ***REMOVED***
        switch (tok[0]) ***REMOVED***
          case ')':
            stack.push(tok);
            break;
          case '(':
          case 'CALL_START':
            if (stack.length) ***REMOVED***
              stack.pop();
***REMOVED*** else if (tok[0] === '(') ***REMOVED***
              tok[0] = 'PARAM_START';
              return this;
***REMOVED*** else ***REMOVED***
              return this;
***REMOVED***
***REMOVED***
  ***REMOVED***
      return this;
***REMOVED***;

    Lexer.prototype.closeIndentation = function() ***REMOVED***
      return this.outdentToken(this.indent);
***REMOVED***;

    Lexer.prototype.matchWithInterpolations = function(regex, delimiter) ***REMOVED***
      var close, column, firstToken, index, lastToken, line, nested, offsetInChunk, open, ref2, ref3, ref4, str, strPart, tokens;
      tokens = [];
      offsetInChunk = delimiter.length;
      if (this.chunk.slice(0, offsetInChunk) !== delimiter) ***REMOVED***
        return null;
  ***REMOVED***
      str = this.chunk.slice(offsetInChunk);
      while (true) ***REMOVED***
        strPart = regex.exec(str)[0];
        this.validateEscapes(strPart, ***REMOVED***
          isRegex: delimiter.charAt(0) === '/',
          offsetInChunk: offsetInChunk
***REMOVED***);
        tokens.push(this.makeToken('NEOSTRING', strPart, offsetInChunk));
        str = str.slice(strPart.length);
        offsetInChunk += strPart.length;
        if (str.slice(0, 2) !== '#***REMOVED***') ***REMOVED***
          break;
***REMOVED***
        ref2 = this.getLineAndColumnFromChunk(offsetInChunk + 1), line = ref2[0], column = ref2[1];
        ref3 = new Lexer().tokenize(str.slice(1), ***REMOVED***
          line: line,
          column: column,
          untilBalanced: true
***REMOVED***), nested = ref3.tokens, index = ref3.index;
        index += 1;
        open = nested[0], close = nested[nested.length - 1];
        open[0] = open[1] = '(';
        close[0] = close[1] = ')';
        close.origin = ['', 'end of interpolation', close[2]];
        if (((ref4 = nested[1]) != null ? ref4[0] : void 0) === 'TERMINATOR') ***REMOVED***
          nested.splice(1, 1);
***REMOVED***
        tokens.push(['TOKENS', nested]);
        str = str.slice(index);
        offsetInChunk += index;
  ***REMOVED***
      if (str.slice(0, delimiter.length) !== delimiter) ***REMOVED***
        this.error("missing " + delimiter, ***REMOVED***
          length: delimiter.length
***REMOVED***);
  ***REMOVED***
      firstToken = tokens[0], lastToken = tokens[tokens.length - 1];
      firstToken[2].first_column -= delimiter.length;
      lastToken[2].last_column += delimiter.length;
      if (lastToken[1].length === 0) ***REMOVED***
        lastToken[2].last_column -= 1;
  ***REMOVED***
      return ***REMOVED***
        tokens: tokens,
        index: offsetInChunk + delimiter.length
  ***REMOVED***;
***REMOVED***;

    Lexer.prototype.mergeInterpolationTokens = function(tokens, options, fn) ***REMOVED***
      var converted, firstEmptyStringIndex, firstIndex, i, j, lastToken, len, locationToken, lparen, plusToken, ref2, rparen, tag, token, tokensToPush, value;
      if (tokens.length > 1) ***REMOVED***
        lparen = this.token('STRING_START', '(', 0, 0);
  ***REMOVED***
      firstIndex = this.tokens.length;
      for (i = j = 0, len = tokens.length; j < len; i = ++j) ***REMOVED***
        token = tokens[i];
        tag = token[0], value = token[1];
        switch (tag) ***REMOVED***
          case 'TOKENS':
            if (value.length === 2) ***REMOVED***
              continue;
***REMOVED***
            locationToken = value[0];
            tokensToPush = value;
            break;
          case 'NEOSTRING':
            converted = fn(token[1], i);
            if (converted.length === 0) ***REMOVED***
              if (i === 0) ***REMOVED***
                firstEmptyStringIndex = this.tokens.length;
  ***REMOVED*** else ***REMOVED***
                continue;
  ***REMOVED***
***REMOVED***
            if (i === 2 && (firstEmptyStringIndex != null)) ***REMOVED***
              this.tokens.splice(firstEmptyStringIndex, 2);
***REMOVED***
            token[0] = 'STRING';
            token[1] = this.makeDelimitedLiteral(converted, options);
            locationToken = token;
            tokensToPush = [token];
***REMOVED***
        if (this.tokens.length > firstIndex) ***REMOVED***
          plusToken = this.token('+', '+');
          plusToken[2] = ***REMOVED***
            first_line: locationToken[2].first_line,
            first_column: locationToken[2].first_column,
            last_line: locationToken[2].first_line,
            last_column: locationToken[2].first_column
  ***REMOVED***;
***REMOVED***
        (ref2 = this.tokens).push.apply(ref2, tokensToPush);
  ***REMOVED***
      if (lparen) ***REMOVED***
        lastToken = tokens[tokens.length - 1];
        lparen.origin = [
          'STRING', null, ***REMOVED***
            first_line: lparen[2].first_line,
            first_column: lparen[2].first_column,
            last_line: lastToken[2].last_line,
            last_column: lastToken[2].last_column
  ***REMOVED***
        ];
        rparen = this.token('STRING_END', ')');
        return rparen[2] = ***REMOVED***
          first_line: lastToken[2].last_line,
          first_column: lastToken[2].last_column,
          last_line: lastToken[2].last_line,
          last_column: lastToken[2].last_column
***REMOVED***;
  ***REMOVED***
***REMOVED***;

    Lexer.prototype.pair = function(tag) ***REMOVED***
      var lastIndent, prev, ref2, ref3, wanted;
      ref2 = this.ends, prev = ref2[ref2.length - 1];
      if (tag !== (wanted = prev != null ? prev.tag : void 0)) ***REMOVED***
        if ('OUTDENT' !== wanted) ***REMOVED***
          this.error("unmatched " + tag);
***REMOVED***
        ref3 = this.indents, lastIndent = ref3[ref3.length - 1];
        this.outdentToken(lastIndent, true);
        return this.pair(tag);
  ***REMOVED***
      return this.ends.pop();
***REMOVED***;

    Lexer.prototype.getLineAndColumnFromChunk = function(offset) ***REMOVED***
      var column, lastLine, lineCount, ref2, string;
      if (offset === 0) ***REMOVED***
        return [this.chunkLine, this.chunkColumn];
  ***REMOVED***
      if (offset >= this.chunk.length) ***REMOVED***
        string = this.chunk;
  ***REMOVED*** else ***REMOVED***
        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);
  ***REMOVED***
      lineCount = count(string, '\n');
      column = this.chunkColumn;
      if (lineCount > 0) ***REMOVED***
        ref2 = string.split('\n'), lastLine = ref2[ref2.length - 1];
        column = lastLine.length;
  ***REMOVED*** else ***REMOVED***
        column += string.length;
  ***REMOVED***
      return [this.chunkLine + lineCount, column];
***REMOVED***;

    Lexer.prototype.makeToken = function(tag, value, offsetInChunk, length) ***REMOVED***
      var lastCharacter, locationData, ref2, ref3, token;
      if (offsetInChunk == null) ***REMOVED***
        offsetInChunk = 0;
  ***REMOVED***
      if (length == null) ***REMOVED***
        length = value.length;
  ***REMOVED***
      locationData = ***REMOVED******REMOVED***;
      ref2 = this.getLineAndColumnFromChunk(offsetInChunk), locationData.first_line = ref2[0], locationData.first_column = ref2[1];
      lastCharacter = Math.max(0, length - 1);
      ref3 = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter), locationData.last_line = ref3[0], locationData.last_column = ref3[1];
      token = [tag, value, locationData];
      return token;
***REMOVED***;

    Lexer.prototype.token = function(tag, value, offsetInChunk, length, origin) ***REMOVED***
      var token;
      token = this.makeToken(tag, value, offsetInChunk, length);
      if (origin) ***REMOVED***
        token.origin = origin;
  ***REMOVED***
      this.tokens.push(token);
      return token;
***REMOVED***;

    Lexer.prototype.tag = function() ***REMOVED***
      var ref2, token;
      ref2 = this.tokens, token = ref2[ref2.length - 1];
      return token != null ? token[0] : void 0;
***REMOVED***;

    Lexer.prototype.value = function() ***REMOVED***
      var ref2, token;
      ref2 = this.tokens, token = ref2[ref2.length - 1];
      return token != null ? token[1] : void 0;
***REMOVED***;

    Lexer.prototype.unfinished = function() ***REMOVED***
      var ref2;
      return LINE_CONTINUER.test(this.chunk) || ((ref2 = this.tag()) === '\\' || ref2 === '.' || ref2 === '?.' || ref2 === '?::' || ref2 === 'UNARY' || ref2 === 'MATH' || ref2 === 'UNARY_MATH' || ref2 === '+' || ref2 === '-' || ref2 === 'YIELD' || ref2 === '**' || ref2 === 'SHIFT' || ref2 === 'RELATION' || ref2 === 'COMPARE' || ref2 === 'LOGIC' || ref2 === 'THROW' || ref2 === 'EXTENDS');
***REMOVED***;

    Lexer.prototype.formatString = function(str) ***REMOVED***
      return str.replace(STRING_OMIT, '$1');
***REMOVED***;

    Lexer.prototype.formatHeregex = function(str) ***REMOVED***
      return str.replace(HEREGEX_OMIT, '$1$2');
***REMOVED***;

    Lexer.prototype.validateEscapes = function(str, options) ***REMOVED***
      var before, hex, invalidEscape, match, message, octal, ref2, unicode;
      if (options == null) ***REMOVED***
        options = ***REMOVED******REMOVED***;
  ***REMOVED***
      match = INVALID_ESCAPE.exec(str);
      if (!match) ***REMOVED***
        return;
  ***REMOVED***
      match[0], before = match[1], octal = match[2], hex = match[3], unicode = match[4];
      if (options.isRegex && octal && octal.charAt(0) !== '0') ***REMOVED***
        return;
  ***REMOVED***
      message = octal ? "octal escape sequences are not allowed" : "invalid escape sequence";
      invalidEscape = "\\" + (octal || hex || unicode);
      return this.error(message + " " + invalidEscape, ***REMOVED***
        offset: ((ref2 = options.offsetInChunk) != null ? ref2 : 0) + match.index + before.length,
        length: invalidEscape.length
  ***REMOVED***);
***REMOVED***;

    Lexer.prototype.makeDelimitedLiteral = function(body, options) ***REMOVED***
      var regex;
      if (options == null) ***REMOVED***
        options = ***REMOVED******REMOVED***;
  ***REMOVED***
      if (body === '' && options.delimiter === '/') ***REMOVED***
        body = '(?:)';
  ***REMOVED***
      regex = RegExp("(\\\\\\\\)|(\\\\0(?=[1-7]))|\\\\?(" + options.delimiter + ")|\\\\?(?:(\\n)|(\\r)|(\\u2028)|(\\u2029))|(\\\\.)", "g");
      body = body.replace(regex, function(match, backslash, nul, delimiter, lf, cr, ls, ps, other) ***REMOVED***
        switch (false) ***REMOVED***
          case !backslash:
            if (options.double) ***REMOVED***
              return backslash + backslash;
***REMOVED*** else ***REMOVED***
              return backslash;
***REMOVED***
          case !nul:
            return '\\x00';
          case !delimiter:
            return "\\" + delimiter;
          case !lf:
            return '\\n';
          case !cr:
            return '\\r';
          case !ls:
            return '\\u2028';
          case !ps:
            return '\\u2029';
          case !other:
            if (options.double) ***REMOVED***
              return "\\" + other;
***REMOVED*** else ***REMOVED***
              return other;
***REMOVED***
***REMOVED***
  ***REMOVED***);
      return "" + options.delimiter + body + options.delimiter;
***REMOVED***;

    Lexer.prototype.error = function(message, options) ***REMOVED***
      var first_column, first_line, location, ref2, ref3, ref4;
      if (options == null) ***REMOVED***
        options = ***REMOVED******REMOVED***;
  ***REMOVED***
      location = 'first_line' in options ? options : ((ref3 = this.getLineAndColumnFromChunk((ref2 = options.offset) != null ? ref2 : 0), first_line = ref3[0], first_column = ref3[1], ref3), ***REMOVED***
        first_line: first_line,
        first_column: first_column,
        last_column: first_column + ((ref4 = options.length) != null ? ref4 : 1) - 1
  ***REMOVED***);
      return throwSyntaxError(message, location);
***REMOVED***;

    return Lexer;

  ***REMOVED***)();

  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super'];

  COFFEE_KEYWORDS = ['undefined', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];

  COFFEE_ALIAS_MAP = ***REMOVED***
    and: '&&',
    or: '||',
    is: '==',
    isnt: '!=',
    not: '!',
    yes: 'true',
    no: 'false',
    on: 'true',
    off: 'false'
  ***REMOVED***;

  COFFEE_ALIASES = (function() ***REMOVED***
    var results;
    results = [];
    for (key in COFFEE_ALIAS_MAP) ***REMOVED***
      results.push(key);
***REMOVED***
    return results;
  ***REMOVED***)();

  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);

  RESERVED = ['case', 'default', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'export', 'import', 'native', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];

  STRICT_PROSCRIBED = ['arguments', 'eval', 'yield*'];

  JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);

  exports.RESERVED = RESERVED.concat(JS_KEYWORDS).concat(COFFEE_KEYWORDS).concat(STRICT_PROSCRIBED);

  exports.STRICT_PROSCRIBED = STRICT_PROSCRIBED;

  BOM = 65279;

  IDENTIFIER = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)([^\n\S]*:(?!:))?/;

  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;

  OPERATOR = /^(?:[-=]>|[-+*\/%<>&|^!?=]=|>>>=?|([-+:])\1|([&|<>*\/%])\2=?|\?(\.|::)|\.***REMOVED***2,3***REMOVED***)/;

  WHITESPACE = /^[^\n\S]+/;

  COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|###$)|^(?:\s*#(?!##[^#]).*)+/;

  CODE = /^[-=]>/;

  MULTI_DENT = /^(?:\n[^\n\S]*)+/;

  JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;

  STRING_START = /^(?:'''|"""|'|")/;

  STRING_SINGLE = /^(?:[^\\']|\\[\s\S])*/;

  STRING_DOUBLE = /^(?:[^\\"#]|\\[\s\S]|\#(?!\***REMOVED***))*/;

  HEREDOC_SINGLE = /^(?:[^\\']|\\[\s\S]|'(?!''))*/;

  HEREDOC_DOUBLE = /^(?:[^\\"#]|\\[\s\S]|"(?!"")|\#(?!\***REMOVED***))*/;

  STRING_OMIT = /((?:\\\\)+)|\\[^\S\n]*\n\s*/g;

  SIMPLE_STRING_OMIT = /\s*\n\s*/g;

  HEREDOC_INDENT = /\n+([^\n\S]*)(?=\S)/g;

  REGEX = /^\/(?!\/)((?:[^[\/\n\\]|\\[^\n]|\[(?:\\[^\n]|[^\]\n\\])*\])*)(\/)?/;

  REGEX_FLAGS = /^\w*/;

  VALID_FLAGS = /^(?!.*(.).*\1)[imgy]*$/;

  HEREGEX = /^(?:[^\\\/#]|\\[\s\S]|\/(?!\/\/)|\#(?!\***REMOVED***))*/;

  HEREGEX_OMIT = /((?:\\\\)+)|\\(\s)|\s+(?:#.*)?/g;

  REGEX_ILLEGAL = /^(\/|\/***REMOVED***3***REMOVED***\s*)(\*)/;

  POSSIBLY_DIVISION = /^\/=?\s/;

  HERECOMMENT_ILLEGAL = /\*\//;

  LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;

  INVALID_ESCAPE = /((?:^|[^\\])(?:\\\\)*)\\(?:(0[0-7]|[1-7])|(x(?![\da-fA-F]***REMOVED***2***REMOVED***).***REMOVED***0,2***REMOVED***)|(u(?![\da-fA-F]***REMOVED***4***REMOVED***).***REMOVED***0,4***REMOVED***))/;

  LEADING_BLANK_LINE = /^[^\n\S]*\n/;

  TRAILING_BLANK_LINE = /\n[^\n\S]*$/;

  TRAILING_SPACES = /\s+$/;

  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];

  UNARY = ['NEW', 'TYPEOF', 'DELETE', 'DO'];

  UNARY_MATH = ['!', '~'];

  LOGIC = ['&&', '||', '&', '|', '^'];

  SHIFT = ['<<', '>>', '>>>'];

  COMPARE = ['==', '!=', '<', '>', '<=', '>='];

  MATH = ['*', '/', '%', '//', '%%'];

  RELATION = ['IN', 'OF', 'INSTANCEOF'];

  BOOL = ['TRUE', 'FALSE'];

  CALLABLE = ['IDENTIFIER', ')', ']', '?', '@', 'THIS', 'SUPER'];

  INDEXABLE = CALLABLE.concat(['NUMBER', 'STRING', 'STRING_END', 'REGEX', 'REGEX_END', 'BOOL', 'NULL', 'UNDEFINED', '***REMOVED***', '::']);

  NOT_REGEX = INDEXABLE.concat(['++', '--']);

  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];

  INDENTABLE_CLOSERS = [')', '***REMOVED***', ']'];

***REMOVED***).call(this);
