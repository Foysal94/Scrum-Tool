// Generated by CoffeeScript 1.10.0
(function() ***REMOVED***
  var Access, Arr, Assign, Base, Block, Call, Class, Code, CodeFragment, Comment, Existence, Expansion, Extends, For, HEXNUM, IDENTIFIER, IS_REGEX, IS_STRING, If, In, Index, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, Literal, NEGATE, NO, NUMBER, Obj, Op, Param, Parens, RESERVED, Range, Return, SIMPLENUM, STRICT_PROSCRIBED, Scope, Slice, Splat, Switch, TAB, THIS, Throw, Try, UTILITIES, Value, While, YES, addLocationDataFn, compact, del, ends, extend, flatten, fragmentsToText, isComplexOrAssignable, isLiteralArguments, isLiteralThis, locationDataToString, merge, multident, parseNum, ref1, ref2, some, starts, throwSyntaxError, unfoldSoak, utility,
    extend1 = function(child, parent) ***REMOVED*** for (var key in parent) ***REMOVED*** if (hasProp.call(parent, key)) child[key] = parent[key]; ***REMOVED*** function ctor() ***REMOVED*** this.constructor = child; ***REMOVED*** ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; ***REMOVED***,
    hasProp = ***REMOVED******REMOVED***.hasOwnProperty,
    indexOf = [].indexOf || function(item) ***REMOVED*** for (var i = 0, l = this.length; i < l; i++) ***REMOVED*** if (i in this && this[i] === item) return i; ***REMOVED*** return -1; ***REMOVED***,
    slice = [].slice;

  Error.stackTraceLimit = Infinity;

  Scope = require('./scope').Scope;

  ref1 = require('./lexer'), RESERVED = ref1.RESERVED, STRICT_PROSCRIBED = ref1.STRICT_PROSCRIBED;

  ref2 = require('./helpers'), compact = ref2.compact, flatten = ref2.flatten, extend = ref2.extend, merge = ref2.merge, del = ref2.del, starts = ref2.starts, ends = ref2.ends, some = ref2.some, addLocationDataFn = ref2.addLocationDataFn, locationDataToString = ref2.locationDataToString, throwSyntaxError = ref2.throwSyntaxError;

  exports.extend = extend;

  exports.addLocationDataFn = addLocationDataFn;

  YES = function() ***REMOVED***
    return true;
  ***REMOVED***;

  NO = function() ***REMOVED***
    return false;
  ***REMOVED***;

  THIS = function() ***REMOVED***
    return this;
  ***REMOVED***;

  NEGATE = function() ***REMOVED***
    this.negated = !this.negated;
    return this;
  ***REMOVED***;

  exports.CodeFragment = CodeFragment = (function() ***REMOVED***
    function CodeFragment(parent, code) ***REMOVED***
      var ref3;
      this.code = "" + code;
      this.locationData = parent != null ? parent.locationData : void 0;
      this.type = (parent != null ? (ref3 = parent.constructor) != null ? ref3.name : void 0 : void 0) || 'unknown';
***REMOVED***

    CodeFragment.prototype.toString = function() ***REMOVED***
      return "" + this.code + (this.locationData ? ": " + locationDataToString(this.locationData) : '');
***REMOVED***;

    return CodeFragment;

  ***REMOVED***)();

  fragmentsToText = function(fragments) ***REMOVED***
    var fragment;
    return ((function() ***REMOVED***
      var j, len1, results;
      results = [];
      for (j = 0, len1 = fragments.length; j < len1; j++) ***REMOVED***
        fragment = fragments[j];
        results.push(fragment.code);
  ***REMOVED***
      return results;
***REMOVED***)()).join('');
  ***REMOVED***;

  exports.Base = Base = (function() ***REMOVED***
    function Base() ***REMOVED******REMOVED***

    Base.prototype.compile = function(o, lvl) ***REMOVED***
      return fragmentsToText(this.compileToFragments(o, lvl));
***REMOVED***;

    Base.prototype.compileToFragments = function(o, lvl) ***REMOVED***
      var node;
      o = extend(***REMOVED******REMOVED***, o);
      if (lvl) ***REMOVED***
        o.level = lvl;
  ***REMOVED***
      node = this.unfoldSoak(o) || this;
      node.tab = o.indent;
      if (o.level === LEVEL_TOP || !node.isStatement(o)) ***REMOVED***
        return node.compileNode(o);
  ***REMOVED*** else ***REMOVED***
        return node.compileClosure(o);
  ***REMOVED***
***REMOVED***;

    Base.prototype.compileClosure = function(o) ***REMOVED***
      var args, argumentsNode, func, jumpNode, meth, parts, ref3;
      if (jumpNode = this.jumps()) ***REMOVED***
        jumpNode.error('cannot use a pure statement in an expression');
  ***REMOVED***
      o.sharedScope = true;
      func = new Code([], Block.wrap([this]));
      args = [];
      if ((argumentsNode = this.contains(isLiteralArguments)) || this.contains(isLiteralThis)) ***REMOVED***
        args = [new Literal('this')];
        if (argumentsNode) ***REMOVED***
          meth = 'apply';
          args.push(new Literal('arguments'));
***REMOVED*** else ***REMOVED***
          meth = 'call';
***REMOVED***
        func = new Value(func, [new Access(new Literal(meth))]);
  ***REMOVED***
      parts = (new Call(func, args)).compileNode(o);
      if (func.isGenerator || ((ref3 = func.base) != null ? ref3.isGenerator : void 0)) ***REMOVED***
        parts.unshift(this.makeCode("(yield* "));
        parts.push(this.makeCode(")"));
  ***REMOVED***
      return parts;
***REMOVED***;

    Base.prototype.cache = function(o, level, isComplex) ***REMOVED***
      var complex, ref, sub;
      complex = isComplex != null ? isComplex(this) : this.isComplex();
      if (complex) ***REMOVED***
        ref = new Literal(o.scope.freeVariable('ref'));
        sub = new Assign(ref, this);
        if (level) ***REMOVED***
          return [sub.compileToFragments(o, level), [this.makeCode(ref.value)]];
***REMOVED*** else ***REMOVED***
          return [sub, ref];
***REMOVED***
  ***REMOVED*** else ***REMOVED***
        ref = level ? this.compileToFragments(o, level) : this;
        return [ref, ref];
  ***REMOVED***
***REMOVED***;

    Base.prototype.cacheToCodeFragments = function(cacheValues) ***REMOVED***
      return [fragmentsToText(cacheValues[0]), fragmentsToText(cacheValues[1])];
***REMOVED***;

    Base.prototype.makeReturn = function(res) ***REMOVED***
      var me;
      me = this.unwrapAll();
      if (res) ***REMOVED***
        return new Call(new Literal(res + ".push"), [me]);
  ***REMOVED*** else ***REMOVED***
        return new Return(me);
  ***REMOVED***
***REMOVED***;

    Base.prototype.contains = function(pred) ***REMOVED***
      var node;
      node = void 0;
      this.traverseChildren(false, function(n) ***REMOVED***
        if (pred(n)) ***REMOVED***
          node = n;
          return false;
***REMOVED***
  ***REMOVED***);
      return node;
***REMOVED***;

    Base.prototype.lastNonComment = function(list) ***REMOVED***
      var i;
      i = list.length;
      while (i--) ***REMOVED***
        if (!(list[i] instanceof Comment)) ***REMOVED***
          return list[i];
***REMOVED***
  ***REMOVED***
      return null;
***REMOVED***;

    Base.prototype.toString = function(idt, name) ***REMOVED***
      var tree;
      if (idt == null) ***REMOVED***
        idt = '';
  ***REMOVED***
      if (name == null) ***REMOVED***
        name = this.constructor.name;
  ***REMOVED***
      tree = '\n' + idt + name;
      if (this.soak) ***REMOVED***
        tree += '?';
  ***REMOVED***
      this.eachChild(function(node) ***REMOVED***
        return tree += node.toString(idt + TAB);
  ***REMOVED***);
      return tree;
***REMOVED***;

    Base.prototype.eachChild = function(func) ***REMOVED***
      var attr, child, j, k, len1, len2, ref3, ref4;
      if (!this.children) ***REMOVED***
        return this;
  ***REMOVED***
      ref3 = this.children;
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        attr = ref3[j];
        if (this[attr]) ***REMOVED***
          ref4 = flatten([this[attr]]);
          for (k = 0, len2 = ref4.length; k < len2; k++) ***REMOVED***
            child = ref4[k];
            if (func(child) === false) ***REMOVED***
              return this;
***REMOVED***
  ***REMOVED***
***REMOVED***
  ***REMOVED***
      return this;
***REMOVED***;

    Base.prototype.traverseChildren = function(crossScope, func) ***REMOVED***
      return this.eachChild(function(child) ***REMOVED***
        var recur;
        recur = func(child);
        if (recur !== false) ***REMOVED***
          return child.traverseChildren(crossScope, func);
***REMOVED***
  ***REMOVED***);
***REMOVED***;

    Base.prototype.invert = function() ***REMOVED***
      return new Op('!', this);
***REMOVED***;

    Base.prototype.unwrapAll = function() ***REMOVED***
      var node;
      node = this;
      while (node !== (node = node.unwrap())) ***REMOVED***
        continue;
  ***REMOVED***
      return node;
***REMOVED***;

    Base.prototype.children = [];

    Base.prototype.isStatement = NO;

    Base.prototype.jumps = NO;

    Base.prototype.isComplex = YES;

    Base.prototype.isChainable = NO;

    Base.prototype.isAssignable = NO;

    Base.prototype.unwrap = THIS;

    Base.prototype.unfoldSoak = NO;

    Base.prototype.assigns = NO;

    Base.prototype.updateLocationDataIfMissing = function(locationData) ***REMOVED***
      if (this.locationData) ***REMOVED***
        return this;
  ***REMOVED***
      this.locationData = locationData;
      return this.eachChild(function(child) ***REMOVED***
        return child.updateLocationDataIfMissing(locationData);
  ***REMOVED***);
***REMOVED***;

    Base.prototype.error = function(message) ***REMOVED***
      return throwSyntaxError(message, this.locationData);
***REMOVED***;

    Base.prototype.makeCode = function(code) ***REMOVED***
      return new CodeFragment(this, code);
***REMOVED***;

    Base.prototype.wrapInBraces = function(fragments) ***REMOVED***
      return [].concat(this.makeCode('('), fragments, this.makeCode(')'));
***REMOVED***;

    Base.prototype.joinFragmentArrays = function(fragmentsList, joinStr) ***REMOVED***
      var answer, fragments, i, j, len1;
      answer = [];
      for (i = j = 0, len1 = fragmentsList.length; j < len1; i = ++j) ***REMOVED***
        fragments = fragmentsList[i];
        if (i) ***REMOVED***
          answer.push(this.makeCode(joinStr));
***REMOVED***
        answer = answer.concat(fragments);
  ***REMOVED***
      return answer;
***REMOVED***;

    return Base;

  ***REMOVED***)();

  exports.Block = Block = (function(superClass1) ***REMOVED***
    extend1(Block, superClass1);

    function Block(nodes) ***REMOVED***
      this.expressions = compact(flatten(nodes || []));
***REMOVED***

    Block.prototype.children = ['expressions'];

    Block.prototype.push = function(node) ***REMOVED***
      this.expressions.push(node);
      return this;
***REMOVED***;

    Block.prototype.pop = function() ***REMOVED***
      return this.expressions.pop();
***REMOVED***;

    Block.prototype.unshift = function(node) ***REMOVED***
      this.expressions.unshift(node);
      return this;
***REMOVED***;

    Block.prototype.unwrap = function() ***REMOVED***
      if (this.expressions.length === 1) ***REMOVED***
        return this.expressions[0];
  ***REMOVED*** else ***REMOVED***
        return this;
  ***REMOVED***
***REMOVED***;

    Block.prototype.isEmpty = function() ***REMOVED***
      return !this.expressions.length;
***REMOVED***;

    Block.prototype.isStatement = function(o) ***REMOVED***
      var exp, j, len1, ref3;
      ref3 = this.expressions;
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        exp = ref3[j];
        if (exp.isStatement(o)) ***REMOVED***
          return true;
***REMOVED***
  ***REMOVED***
      return false;
***REMOVED***;

    Block.prototype.jumps = function(o) ***REMOVED***
      var exp, j, jumpNode, len1, ref3;
      ref3 = this.expressions;
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        exp = ref3[j];
        if (jumpNode = exp.jumps(o)) ***REMOVED***
          return jumpNode;
***REMOVED***
  ***REMOVED***
***REMOVED***;

    Block.prototype.makeReturn = function(res) ***REMOVED***
      var expr, len;
      len = this.expressions.length;
      while (len--) ***REMOVED***
        expr = this.expressions[len];
        if (!(expr instanceof Comment)) ***REMOVED***
          this.expressions[len] = expr.makeReturn(res);
          if (expr instanceof Return && !expr.expression) ***REMOVED***
            this.expressions.splice(len, 1);
  ***REMOVED***
          break;
***REMOVED***
  ***REMOVED***
      return this;
***REMOVED***;

    Block.prototype.compileToFragments = function(o, level) ***REMOVED***
      if (o == null) ***REMOVED***
        o = ***REMOVED******REMOVED***;
  ***REMOVED***
      if (o.scope) ***REMOVED***
        return Block.__super__.compileToFragments.call(this, o, level);
  ***REMOVED*** else ***REMOVED***
        return this.compileRoot(o);
  ***REMOVED***
***REMOVED***;

    Block.prototype.compileNode = function(o) ***REMOVED***
      var answer, compiledNodes, fragments, index, j, len1, node, ref3, top;
      this.tab = o.indent;
      top = o.level === LEVEL_TOP;
      compiledNodes = [];
      ref3 = this.expressions;
      for (index = j = 0, len1 = ref3.length; j < len1; index = ++j) ***REMOVED***
        node = ref3[index];
        node = node.unwrapAll();
        node = node.unfoldSoak(o) || node;
        if (node instanceof Block) ***REMOVED***
          compiledNodes.push(node.compileNode(o));
***REMOVED*** else if (top) ***REMOVED***
          node.front = true;
          fragments = node.compileToFragments(o);
          if (!node.isStatement(o)) ***REMOVED***
            fragments.unshift(this.makeCode("" + this.tab));
            fragments.push(this.makeCode(";"));
  ***REMOVED***
          compiledNodes.push(fragments);
***REMOVED*** else ***REMOVED***
          compiledNodes.push(node.compileToFragments(o, LEVEL_LIST));
***REMOVED***
  ***REMOVED***
      if (top) ***REMOVED***
        if (this.spaced) ***REMOVED***
          return [].concat(this.joinFragmentArrays(compiledNodes, '\n\n'), this.makeCode("\n"));
***REMOVED*** else ***REMOVED***
          return this.joinFragmentArrays(compiledNodes, '\n');
***REMOVED***
  ***REMOVED***
      if (compiledNodes.length) ***REMOVED***
        answer = this.joinFragmentArrays(compiledNodes, ', ');
  ***REMOVED*** else ***REMOVED***
        answer = [this.makeCode("void 0")];
  ***REMOVED***
      if (compiledNodes.length > 1 && o.level >= LEVEL_LIST) ***REMOVED***
        return this.wrapInBraces(answer);
  ***REMOVED*** else ***REMOVED***
        return answer;
  ***REMOVED***
***REMOVED***;

    Block.prototype.compileRoot = function(o) ***REMOVED***
      var exp, fragments, i, j, len1, name, prelude, preludeExps, ref3, ref4, rest;
      o.indent = o.bare ? '' : TAB;
      o.level = LEVEL_TOP;
      this.spaced = true;
      o.scope = new Scope(null, this, null, (ref3 = o.referencedVars) != null ? ref3 : []);
      ref4 = o.locals || [];
      for (j = 0, len1 = ref4.length; j < len1; j++) ***REMOVED***
        name = ref4[j];
        o.scope.parameter(name);
  ***REMOVED***
      prelude = [];
      if (!o.bare) ***REMOVED***
        preludeExps = (function() ***REMOVED***
          var k, len2, ref5, results;
          ref5 = this.expressions;
          results = [];
          for (i = k = 0, len2 = ref5.length; k < len2; i = ++k) ***REMOVED***
            exp = ref5[i];
            if (!(exp.unwrap() instanceof Comment)) ***REMOVED***
              break;
***REMOVED***
            results.push(exp);
  ***REMOVED***
          return results;
***REMOVED***).call(this);
        rest = this.expressions.slice(preludeExps.length);
        this.expressions = preludeExps;
        if (preludeExps.length) ***REMOVED***
          prelude = this.compileNode(merge(o, ***REMOVED***
            indent: ''
  ***REMOVED***));
          prelude.push(this.makeCode("\n"));
***REMOVED***
        this.expressions = rest;
  ***REMOVED***
      fragments = this.compileWithDeclarations(o);
      if (o.bare) ***REMOVED***
        return fragments;
  ***REMOVED***
      return [].concat(prelude, this.makeCode("(function() ***REMOVED***\n"), fragments, this.makeCode("\n***REMOVED***).call(this);\n"));
***REMOVED***;

    Block.prototype.compileWithDeclarations = function(o) ***REMOVED***
      var assigns, declars, exp, fragments, i, j, len1, post, ref3, ref4, ref5, rest, scope, spaced;
      fragments = [];
      post = [];
      ref3 = this.expressions;
      for (i = j = 0, len1 = ref3.length; j < len1; i = ++j) ***REMOVED***
        exp = ref3[i];
        exp = exp.unwrap();
        if (!(exp instanceof Comment || exp instanceof Literal)) ***REMOVED***
          break;
***REMOVED***
  ***REMOVED***
      o = merge(o, ***REMOVED***
        level: LEVEL_TOP
  ***REMOVED***);
      if (i) ***REMOVED***
        rest = this.expressions.splice(i, 9e9);
        ref4 = [this.spaced, false], spaced = ref4[0], this.spaced = ref4[1];
        ref5 = [this.compileNode(o), spaced], fragments = ref5[0], this.spaced = ref5[1];
        this.expressions = rest;
  ***REMOVED***
      post = this.compileNode(o);
      scope = o.scope;
      if (scope.expressions === this) ***REMOVED***
        declars = o.scope.hasDeclarations();
        assigns = scope.hasAssignments;
        if (declars || assigns) ***REMOVED***
          if (i) ***REMOVED***
            fragments.push(this.makeCode('\n'));
  ***REMOVED***
          fragments.push(this.makeCode(this.tab + "var "));
          if (declars) ***REMOVED***
            fragments.push(this.makeCode(scope.declaredVariables().join(', ')));
  ***REMOVED***
          if (assigns) ***REMOVED***
            if (declars) ***REMOVED***
              fragments.push(this.makeCode(",\n" + (this.tab + TAB)));
***REMOVED***
            fragments.push(this.makeCode(scope.assignedVariables().join(",\n" + (this.tab + TAB))));
  ***REMOVED***
          fragments.push(this.makeCode(";\n" + (this.spaced ? '\n' : '')));
***REMOVED*** else if (fragments.length && post.length) ***REMOVED***
          fragments.push(this.makeCode("\n"));
***REMOVED***
  ***REMOVED***
      return fragments.concat(post);
***REMOVED***;

    Block.wrap = function(nodes) ***REMOVED***
      if (nodes.length === 1 && nodes[0] instanceof Block) ***REMOVED***
        return nodes[0];
  ***REMOVED***
      return new Block(nodes);
***REMOVED***;

    return Block;

  ***REMOVED***)(Base);

  exports.Literal = Literal = (function(superClass1) ***REMOVED***
    extend1(Literal, superClass1);

    function Literal(value1) ***REMOVED***
      this.value = value1;
***REMOVED***

    Literal.prototype.makeReturn = function() ***REMOVED***
      if (this.isStatement()) ***REMOVED***
        return this;
  ***REMOVED*** else ***REMOVED***
        return Literal.__super__.makeReturn.apply(this, arguments);
  ***REMOVED***
***REMOVED***;

    Literal.prototype.isAssignable = function() ***REMOVED***
      return IDENTIFIER.test(this.value);
***REMOVED***;

    Literal.prototype.isStatement = function() ***REMOVED***
      var ref3;
      return (ref3 = this.value) === 'break' || ref3 === 'continue' || ref3 === 'debugger';
***REMOVED***;

    Literal.prototype.isComplex = NO;

    Literal.prototype.assigns = function(name) ***REMOVED***
      return name === this.value;
***REMOVED***;

    Literal.prototype.jumps = function(o) ***REMOVED***
      if (this.value === 'break' && !((o != null ? o.loop : void 0) || (o != null ? o.block : void 0))) ***REMOVED***
        return this;
  ***REMOVED***
      if (this.value === 'continue' && !(o != null ? o.loop : void 0)) ***REMOVED***
        return this;
  ***REMOVED***
***REMOVED***;

    Literal.prototype.compileNode = function(o) ***REMOVED***
      var answer, code, ref3;
      code = this.value === 'this' ? ((ref3 = o.scope.method) != null ? ref3.bound : void 0) ? o.scope.method.context : this.value : this.value.reserved ? "\"" + this.value + "\"" : this.value;
      answer = this.isStatement() ? "" + this.tab + code + ";" : code;
      return [this.makeCode(answer)];
***REMOVED***;

    Literal.prototype.toString = function() ***REMOVED***
      return ' "' + this.value + '"';
***REMOVED***;

    return Literal;

  ***REMOVED***)(Base);

  exports.Undefined = (function(superClass1) ***REMOVED***
    extend1(Undefined, superClass1);

    function Undefined() ***REMOVED***
      return Undefined.__super__.constructor.apply(this, arguments);
***REMOVED***

    Undefined.prototype.isAssignable = NO;

    Undefined.prototype.isComplex = NO;

    Undefined.prototype.compileNode = function(o) ***REMOVED***
      return [this.makeCode(o.level >= LEVEL_ACCESS ? '(void 0)' : 'void 0')];
***REMOVED***;

    return Undefined;

  ***REMOVED***)(Base);

  exports.Null = (function(superClass1) ***REMOVED***
    extend1(Null, superClass1);

    function Null() ***REMOVED***
      return Null.__super__.constructor.apply(this, arguments);
***REMOVED***

    Null.prototype.isAssignable = NO;

    Null.prototype.isComplex = NO;

    Null.prototype.compileNode = function() ***REMOVED***
      return [this.makeCode("null")];
***REMOVED***;

    return Null;

  ***REMOVED***)(Base);

  exports.Bool = (function(superClass1) ***REMOVED***
    extend1(Bool, superClass1);

    Bool.prototype.isAssignable = NO;

    Bool.prototype.isComplex = NO;

    Bool.prototype.compileNode = function() ***REMOVED***
      return [this.makeCode(this.val)];
***REMOVED***;

    function Bool(val1) ***REMOVED***
      this.val = val1;
***REMOVED***

    return Bool;

  ***REMOVED***)(Base);

  exports.Return = Return = (function(superClass1) ***REMOVED***
    extend1(Return, superClass1);

    function Return(expression) ***REMOVED***
      this.expression = expression;
***REMOVED***

    Return.prototype.children = ['expression'];

    Return.prototype.isStatement = YES;

    Return.prototype.makeReturn = THIS;

    Return.prototype.jumps = THIS;

    Return.prototype.compileToFragments = function(o, level) ***REMOVED***
      var expr, ref3;
      expr = (ref3 = this.expression) != null ? ref3.makeReturn() : void 0;
      if (expr && !(expr instanceof Return)) ***REMOVED***
        return expr.compileToFragments(o, level);
  ***REMOVED*** else ***REMOVED***
        return Return.__super__.compileToFragments.call(this, o, level);
  ***REMOVED***
***REMOVED***;

    Return.prototype.compileNode = function(o) ***REMOVED***
      var answer, exprIsYieldReturn, ref3;
      answer = [];
      exprIsYieldReturn = (ref3 = this.expression) != null ? typeof ref3.isYieldReturn === "function" ? ref3.isYieldReturn() : void 0 : void 0;
      if (!exprIsYieldReturn) ***REMOVED***
        answer.push(this.makeCode(this.tab + ("return" + (this.expression ? " " : ""))));
  ***REMOVED***
      if (this.expression) ***REMOVED***
        answer = answer.concat(this.expression.compileToFragments(o, LEVEL_PAREN));
  ***REMOVED***
      if (!exprIsYieldReturn) ***REMOVED***
        answer.push(this.makeCode(";"));
  ***REMOVED***
      return answer;
***REMOVED***;

    return Return;

  ***REMOVED***)(Base);

  exports.Value = Value = (function(superClass1) ***REMOVED***
    extend1(Value, superClass1);

    function Value(base, props, tag) ***REMOVED***
      if (!props && base instanceof Value) ***REMOVED***
        return base;
  ***REMOVED***
      this.base = base;
      this.properties = props || [];
      if (tag) ***REMOVED***
        this[tag] = true;
  ***REMOVED***
      return this;
***REMOVED***

    Value.prototype.children = ['base', 'properties'];

    Value.prototype.add = function(props) ***REMOVED***
      this.properties = this.properties.concat(props);
      return this;
***REMOVED***;

    Value.prototype.hasProperties = function() ***REMOVED***
      return !!this.properties.length;
***REMOVED***;

    Value.prototype.bareLiteral = function(type) ***REMOVED***
      return !this.properties.length && this.base instanceof type;
***REMOVED***;

    Value.prototype.isArray = function() ***REMOVED***
      return this.bareLiteral(Arr);
***REMOVED***;

    Value.prototype.isRange = function() ***REMOVED***
      return this.bareLiteral(Range);
***REMOVED***;

    Value.prototype.isComplex = function() ***REMOVED***
      return this.hasProperties() || this.base.isComplex();
***REMOVED***;

    Value.prototype.isAssignable = function() ***REMOVED***
      return this.hasProperties() || this.base.isAssignable();
***REMOVED***;

    Value.prototype.isSimpleNumber = function() ***REMOVED***
      return this.bareLiteral(Literal) && SIMPLENUM.test(this.base.value);
***REMOVED***;

    Value.prototype.isString = function() ***REMOVED***
      return this.bareLiteral(Literal) && IS_STRING.test(this.base.value);
***REMOVED***;

    Value.prototype.isRegex = function() ***REMOVED***
      return this.bareLiteral(Literal) && IS_REGEX.test(this.base.value);
***REMOVED***;

    Value.prototype.isAtomic = function() ***REMOVED***
      var j, len1, node, ref3;
      ref3 = this.properties.concat(this.base);
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        node = ref3[j];
        if (node.soak || node instanceof Call) ***REMOVED***
          return false;
***REMOVED***
  ***REMOVED***
      return true;
***REMOVED***;

    Value.prototype.isNotCallable = function() ***REMOVED***
      return this.isSimpleNumber() || this.isString() || this.isRegex() || this.isArray() || this.isRange() || this.isSplice() || this.isObject();
***REMOVED***;

    Value.prototype.isStatement = function(o) ***REMOVED***
      return !this.properties.length && this.base.isStatement(o);
***REMOVED***;

    Value.prototype.assigns = function(name) ***REMOVED***
      return !this.properties.length && this.base.assigns(name);
***REMOVED***;

    Value.prototype.jumps = function(o) ***REMOVED***
      return !this.properties.length && this.base.jumps(o);
***REMOVED***;

    Value.prototype.isObject = function(onlyGenerated) ***REMOVED***
      if (this.properties.length) ***REMOVED***
        return false;
  ***REMOVED***
      return (this.base instanceof Obj) && (!onlyGenerated || this.base.generated);
***REMOVED***;

    Value.prototype.isSplice = function() ***REMOVED***
      var lastProp, ref3;
      ref3 = this.properties, lastProp = ref3[ref3.length - 1];
      return lastProp instanceof Slice;
***REMOVED***;

    Value.prototype.looksStatic = function(className) ***REMOVED***
      var ref3;
      return this.base.value === className && this.properties.length === 1 && ((ref3 = this.properties[0].name) != null ? ref3.value : void 0) !== 'prototype';
***REMOVED***;

    Value.prototype.unwrap = function() ***REMOVED***
      if (this.properties.length) ***REMOVED***
        return this;
  ***REMOVED*** else ***REMOVED***
        return this.base;
  ***REMOVED***
***REMOVED***;

    Value.prototype.cacheReference = function(o) ***REMOVED***
      var base, bref, name, nref, ref3;
      ref3 = this.properties, name = ref3[ref3.length - 1];
      if (this.properties.length < 2 && !this.base.isComplex() && !(name != null ? name.isComplex() : void 0)) ***REMOVED***
        return [this, this];
  ***REMOVED***
      base = new Value(this.base, this.properties.slice(0, -1));
      if (base.isComplex()) ***REMOVED***
        bref = new Literal(o.scope.freeVariable('base'));
        base = new Value(new Parens(new Assign(bref, base)));
  ***REMOVED***
      if (!name) ***REMOVED***
        return [base, bref];
  ***REMOVED***
      if (name.isComplex()) ***REMOVED***
        nref = new Literal(o.scope.freeVariable('name'));
        name = new Index(new Assign(nref, name.index));
        nref = new Index(nref);
  ***REMOVED***
      return [base.add(name), new Value(bref || base.base, [nref || name])];
***REMOVED***;

    Value.prototype.compileNode = function(o) ***REMOVED***
      var fragments, j, len1, prop, props;
      this.base.front = this.front;
      props = this.properties;
      fragments = this.base.compileToFragments(o, (props.length ? LEVEL_ACCESS : null));
      if ((this.base instanceof Parens || props.length) && SIMPLENUM.test(fragmentsToText(fragments))) ***REMOVED***
        fragments.push(this.makeCode('.'));
  ***REMOVED***
      for (j = 0, len1 = props.length; j < len1; j++) ***REMOVED***
        prop = props[j];
        fragments.push.apply(fragments, prop.compileToFragments(o));
  ***REMOVED***
      return fragments;
***REMOVED***;

    Value.prototype.unfoldSoak = function(o) ***REMOVED***
      return this.unfoldedSoak != null ? this.unfoldedSoak : this.unfoldedSoak = (function(_this) ***REMOVED***
        return function() ***REMOVED***
          var fst, i, ifn, j, len1, prop, ref, ref3, ref4, snd;
          if (ifn = _this.base.unfoldSoak(o)) ***REMOVED***
            (ref3 = ifn.body.properties).push.apply(ref3, _this.properties);
            return ifn;
  ***REMOVED***
          ref4 = _this.properties;
          for (i = j = 0, len1 = ref4.length; j < len1; i = ++j) ***REMOVED***
            prop = ref4[i];
            if (!prop.soak) ***REMOVED***
              continue;
***REMOVED***
            prop.soak = false;
            fst = new Value(_this.base, _this.properties.slice(0, i));
            snd = new Value(_this.base, _this.properties.slice(i));
            if (fst.isComplex()) ***REMOVED***
              ref = new Literal(o.scope.freeVariable('ref'));
              fst = new Parens(new Assign(ref, fst));
              snd.base = ref;
***REMOVED***
            return new If(new Existence(fst), snd, ***REMOVED***
              soak: true
***REMOVED***);
  ***REMOVED***
          return false;
***REMOVED***;
  ***REMOVED***)(this)();
***REMOVED***;

    return Value;

  ***REMOVED***)(Base);

  exports.Comment = Comment = (function(superClass1) ***REMOVED***
    extend1(Comment, superClass1);

    function Comment(comment1) ***REMOVED***
      this.comment = comment1;
***REMOVED***

    Comment.prototype.isStatement = YES;

    Comment.prototype.makeReturn = THIS;

    Comment.prototype.compileNode = function(o, level) ***REMOVED***
      var code, comment;
      comment = this.comment.replace(/^(\s*)#(?=\s)/gm, "$1 *");
      code = "/*" + (multident(comment, this.tab)) + (indexOf.call(comment, '\n') >= 0 ? "\n" + this.tab : '') + " */";
      if ((level || o.level) === LEVEL_TOP) ***REMOVED***
        code = o.indent + code;
  ***REMOVED***
      return [this.makeCode("\n"), this.makeCode(code)];
***REMOVED***;

    return Comment;

  ***REMOVED***)(Base);

  exports.Call = Call = (function(superClass1) ***REMOVED***
    extend1(Call, superClass1);

    function Call(variable, args1, soak) ***REMOVED***
      this.args = args1 != null ? args1 : [];
      this.soak = soak;
      this.isNew = false;
      this.isSuper = variable === 'super';
      this.variable = this.isSuper ? null : variable;
      if (variable instanceof Value && variable.isNotCallable()) ***REMOVED***
        variable.error("literal is not a function");
  ***REMOVED***
***REMOVED***

    Call.prototype.children = ['variable', 'args'];

    Call.prototype.newInstance = function() ***REMOVED***
      var base, ref3;
      base = ((ref3 = this.variable) != null ? ref3.base : void 0) || this.variable;
      if (base instanceof Call && !base.isNew) ***REMOVED***
        base.newInstance();
  ***REMOVED*** else ***REMOVED***
        this.isNew = true;
  ***REMOVED***
      return this;
***REMOVED***;

    Call.prototype.superReference = function(o) ***REMOVED***
      var accesses, base, bref, klass, method, name, nref, variable;
      method = o.scope.namedMethod();
      if (method != null ? method.klass : void 0) ***REMOVED***
        klass = method.klass, name = method.name, variable = method.variable;
        if (klass.isComplex()) ***REMOVED***
          bref = new Literal(o.scope.parent.freeVariable('base'));
          base = new Value(new Parens(new Assign(bref, klass)));
          variable.base = base;
          variable.properties.splice(0, klass.properties.length);
***REMOVED***
        if (name.isComplex() || (name instanceof Index && name.index.isAssignable())) ***REMOVED***
          nref = new Literal(o.scope.parent.freeVariable('name'));
          name = new Index(new Assign(nref, name.index));
          variable.properties.pop();
          variable.properties.push(name);
***REMOVED***
        accesses = [new Access(new Literal('__super__'))];
        if (method["static"]) ***REMOVED***
          accesses.push(new Access(new Literal('constructor')));
***REMOVED***
        accesses.push(nref != null ? new Index(nref) : name);
        return (new Value(bref != null ? bref : klass, accesses)).compile(o);
  ***REMOVED*** else if (method != null ? method.ctor : void 0) ***REMOVED***
        return method.name + ".__super__.constructor";
  ***REMOVED*** else ***REMOVED***
        return this.error('cannot call super outside of an instance method.');
  ***REMOVED***
***REMOVED***;

    Call.prototype.superThis = function(o) ***REMOVED***
      var method;
      method = o.scope.method;
      return (method && !method.klass && method.context) || "this";
***REMOVED***;

    Call.prototype.unfoldSoak = function(o) ***REMOVED***
      var call, ifn, j, left, len1, list, ref3, ref4, rite;
      if (this.soak) ***REMOVED***
        if (this.variable) ***REMOVED***
          if (ifn = unfoldSoak(o, this, 'variable')) ***REMOVED***
            return ifn;
  ***REMOVED***
          ref3 = new Value(this.variable).cacheReference(o), left = ref3[0], rite = ref3[1];
***REMOVED*** else ***REMOVED***
          left = new Literal(this.superReference(o));
          rite = new Value(left);
***REMOVED***
        rite = new Call(rite, this.args);
        rite.isNew = this.isNew;
        left = new Literal("typeof " + (left.compile(o)) + " === \"function\"");
        return new If(left, new Value(rite), ***REMOVED***
          soak: true
***REMOVED***);
  ***REMOVED***
      call = this;
      list = [];
      while (true) ***REMOVED***
        if (call.variable instanceof Call) ***REMOVED***
          list.push(call);
          call = call.variable;
          continue;
***REMOVED***
        if (!(call.variable instanceof Value)) ***REMOVED***
          break;
***REMOVED***
        list.push(call);
        if (!((call = call.variable.base) instanceof Call)) ***REMOVED***
          break;
***REMOVED***
  ***REMOVED***
      ref4 = list.reverse();
      for (j = 0, len1 = ref4.length; j < len1; j++) ***REMOVED***
        call = ref4[j];
        if (ifn) ***REMOVED***
          if (call.variable instanceof Call) ***REMOVED***
            call.variable = ifn;
  ***REMOVED*** else ***REMOVED***
            call.variable.base = ifn;
  ***REMOVED***
***REMOVED***
        ifn = unfoldSoak(o, call, 'variable');
  ***REMOVED***
      return ifn;
***REMOVED***;

    Call.prototype.compileNode = function(o) ***REMOVED***
      var arg, argIndex, compiledArgs, compiledArray, fragments, j, len1, preface, ref3, ref4;
      if ((ref3 = this.variable) != null) ***REMOVED***
        ref3.front = this.front;
  ***REMOVED***
      compiledArray = Splat.compileSplattedArray(o, this.args, true);
      if (compiledArray.length) ***REMOVED***
        return this.compileSplat(o, compiledArray);
  ***REMOVED***
      compiledArgs = [];
      ref4 = this.args;
      for (argIndex = j = 0, len1 = ref4.length; j < len1; argIndex = ++j) ***REMOVED***
        arg = ref4[argIndex];
        if (argIndex) ***REMOVED***
          compiledArgs.push(this.makeCode(", "));
***REMOVED***
        compiledArgs.push.apply(compiledArgs, arg.compileToFragments(o, LEVEL_LIST));
  ***REMOVED***
      fragments = [];
      if (this.isSuper) ***REMOVED***
        preface = this.superReference(o) + (".call(" + (this.superThis(o)));
        if (compiledArgs.length) ***REMOVED***
          preface += ", ";
***REMOVED***
        fragments.push(this.makeCode(preface));
  ***REMOVED*** else ***REMOVED***
        if (this.isNew) ***REMOVED***
          fragments.push(this.makeCode('new '));
***REMOVED***
        fragments.push.apply(fragments, this.variable.compileToFragments(o, LEVEL_ACCESS));
        fragments.push(this.makeCode("("));
  ***REMOVED***
      fragments.push.apply(fragments, compiledArgs);
      fragments.push(this.makeCode(")"));
      return fragments;
***REMOVED***;

    Call.prototype.compileSplat = function(o, splatArgs) ***REMOVED***
      var answer, base, fun, idt, name, ref;
      if (this.isSuper) ***REMOVED***
        return [].concat(this.makeCode((this.superReference(o)) + ".apply(" + (this.superThis(o)) + ", "), splatArgs, this.makeCode(")"));
  ***REMOVED***
      if (this.isNew) ***REMOVED***
        idt = this.tab + TAB;
        return [].concat(this.makeCode("(function(func, args, ctor) ***REMOVED***\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args);\n" + idt + "return Object(result) === result ? result : child;\n" + this.tab + "***REMOVED***)("), this.variable.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), splatArgs, this.makeCode(", function()***REMOVED******REMOVED***)"));
  ***REMOVED***
      answer = [];
      base = new Value(this.variable);
      if ((name = base.properties.pop()) && base.isComplex()) ***REMOVED***
        ref = o.scope.freeVariable('ref');
        answer = answer.concat(this.makeCode("(" + ref + " = "), base.compileToFragments(o, LEVEL_LIST), this.makeCode(")"), name.compileToFragments(o));
  ***REMOVED*** else ***REMOVED***
        fun = base.compileToFragments(o, LEVEL_ACCESS);
        if (SIMPLENUM.test(fragmentsToText(fun))) ***REMOVED***
          fun = this.wrapInBraces(fun);
***REMOVED***
        if (name) ***REMOVED***
          ref = fragmentsToText(fun);
          fun.push.apply(fun, name.compileToFragments(o));
***REMOVED*** else ***REMOVED***
          ref = 'null';
***REMOVED***
        answer = answer.concat(fun);
  ***REMOVED***
      return answer = answer.concat(this.makeCode(".apply(" + ref + ", "), splatArgs, this.makeCode(")"));
***REMOVED***;

    return Call;

  ***REMOVED***)(Base);

  exports.Extends = Extends = (function(superClass1) ***REMOVED***
    extend1(Extends, superClass1);

    function Extends(child1, parent1) ***REMOVED***
      this.child = child1;
      this.parent = parent1;
***REMOVED***

    Extends.prototype.children = ['child', 'parent'];

    Extends.prototype.compileToFragments = function(o) ***REMOVED***
      return new Call(new Value(new Literal(utility('extend', o))), [this.child, this.parent]).compileToFragments(o);
***REMOVED***;

    return Extends;

  ***REMOVED***)(Base);

  exports.Access = Access = (function(superClass1) ***REMOVED***
    extend1(Access, superClass1);

    function Access(name1, tag) ***REMOVED***
      this.name = name1;
      this.name.asKey = true;
      this.soak = tag === 'soak';
***REMOVED***

    Access.prototype.children = ['name'];

    Access.prototype.compileToFragments = function(o) ***REMOVED***
      var name;
      name = this.name.compileToFragments(o);
      if (IDENTIFIER.test(fragmentsToText(name))) ***REMOVED***
        name.unshift(this.makeCode("."));
  ***REMOVED*** else ***REMOVED***
        name.unshift(this.makeCode("["));
        name.push(this.makeCode("]"));
  ***REMOVED***
      return name;
***REMOVED***;

    Access.prototype.isComplex = NO;

    return Access;

  ***REMOVED***)(Base);

  exports.Index = Index = (function(superClass1) ***REMOVED***
    extend1(Index, superClass1);

    function Index(index1) ***REMOVED***
      this.index = index1;
***REMOVED***

    Index.prototype.children = ['index'];

    Index.prototype.compileToFragments = function(o) ***REMOVED***
      return [].concat(this.makeCode("["), this.index.compileToFragments(o, LEVEL_PAREN), this.makeCode("]"));
***REMOVED***;

    Index.prototype.isComplex = function() ***REMOVED***
      return this.index.isComplex();
***REMOVED***;

    return Index;

  ***REMOVED***)(Base);

  exports.Range = Range = (function(superClass1) ***REMOVED***
    extend1(Range, superClass1);

    Range.prototype.children = ['from', 'to'];

    function Range(from1, to1, tag) ***REMOVED***
      this.from = from1;
      this.to = to1;
      this.exclusive = tag === 'exclusive';
      this.equals = this.exclusive ? '' : '=';
***REMOVED***

    Range.prototype.compileVariables = function(o) ***REMOVED***
      var isComplex, ref3, ref4, ref5, ref6, step;
      o = merge(o, ***REMOVED***
        top: true
  ***REMOVED***);
      isComplex = del(o, 'isComplex');
      ref3 = this.cacheToCodeFragments(this.from.cache(o, LEVEL_LIST, isComplex)), this.fromC = ref3[0], this.fromVar = ref3[1];
      ref4 = this.cacheToCodeFragments(this.to.cache(o, LEVEL_LIST, isComplex)), this.toC = ref4[0], this.toVar = ref4[1];
      if (step = del(o, 'step')) ***REMOVED***
        ref5 = this.cacheToCodeFragments(step.cache(o, LEVEL_LIST, isComplex)), this.step = ref5[0], this.stepVar = ref5[1];
  ***REMOVED***
      ref6 = [this.fromVar.match(NUMBER), this.toVar.match(NUMBER)], this.fromNum = ref6[0], this.toNum = ref6[1];
      if (this.stepVar) ***REMOVED***
        return this.stepNum = this.stepVar.match(NUMBER);
  ***REMOVED***
***REMOVED***;

    Range.prototype.compileNode = function(o) ***REMOVED***
      var cond, condPart, from, gt, idx, idxName, known, lt, namedIndex, ref3, ref4, stepPart, to, varPart;
      if (!this.fromVar) ***REMOVED***
        this.compileVariables(o);
  ***REMOVED***
      if (!o.index) ***REMOVED***
        return this.compileArray(o);
  ***REMOVED***
      known = this.fromNum && this.toNum;
      idx = del(o, 'index');
      idxName = del(o, 'name');
      namedIndex = idxName && idxName !== idx;
      varPart = idx + " = " + this.fromC;
      if (this.toC !== this.toVar) ***REMOVED***
        varPart += ", " + this.toC;
  ***REMOVED***
      if (this.step !== this.stepVar) ***REMOVED***
        varPart += ", " + this.step;
  ***REMOVED***
      ref3 = [idx + " <" + this.equals, idx + " >" + this.equals], lt = ref3[0], gt = ref3[1];
      condPart = this.stepNum ? parseNum(this.stepNum[0]) > 0 ? lt + " " + this.toVar : gt + " " + this.toVar : known ? ((ref4 = [parseNum(this.fromNum[0]), parseNum(this.toNum[0])], from = ref4[0], to = ref4[1], ref4), from <= to ? lt + " " + to : gt + " " + to) : (cond = this.stepVar ? this.stepVar + " > 0" : this.fromVar + " <= " + this.toVar, cond + " ? " + lt + " " + this.toVar + " : " + gt + " " + this.toVar);
      stepPart = this.stepVar ? idx + " += " + this.stepVar : known ? namedIndex ? from <= to ? "++" + idx : "--" + idx : from <= to ? idx + "++" : idx + "--" : namedIndex ? cond + " ? ++" + idx + " : --" + idx : cond + " ? " + idx + "++ : " + idx + "--";
      if (namedIndex) ***REMOVED***
        varPart = idxName + " = " + varPart;
  ***REMOVED***
      if (namedIndex) ***REMOVED***
        stepPart = idxName + " = " + stepPart;
  ***REMOVED***
      return [this.makeCode(varPart + "; " + condPart + "; " + stepPart)];
***REMOVED***;

    Range.prototype.compileArray = function(o) ***REMOVED***
      var args, body, cond, hasArgs, i, idt, j, post, pre, range, ref3, ref4, result, results, vars;
      if (this.fromNum && this.toNum && Math.abs(this.fromNum - this.toNum) <= 20) ***REMOVED***
        range = (function() ***REMOVED***
          results = [];
          for (var j = ref3 = +this.fromNum, ref4 = +this.toNum; ref3 <= ref4 ? j <= ref4 : j >= ref4; ref3 <= ref4 ? j++ : j--)***REMOVED*** results.push(j); ***REMOVED***
          return results;
***REMOVED***).apply(this);
        if (this.exclusive) ***REMOVED***
          range.pop();
***REMOVED***
        return [this.makeCode("[" + (range.join(', ')) + "]")];
  ***REMOVED***
      idt = this.tab + TAB;
      i = o.scope.freeVariable('i', ***REMOVED***
        single: true
  ***REMOVED***);
      result = o.scope.freeVariable('results');
      pre = "\n" + idt + result + " = [];";
      if (this.fromNum && this.toNum) ***REMOVED***
        o.index = i;
        body = fragmentsToText(this.compileNode(o));
  ***REMOVED*** else ***REMOVED***
        vars = (i + " = " + this.fromC) + (this.toC !== this.toVar ? ", " + this.toC : '');
        cond = this.fromVar + " <= " + this.toVar;
        body = "var " + vars + "; " + cond + " ? " + i + " <" + this.equals + " " + this.toVar + " : " + i + " >" + this.equals + " " + this.toVar + "; " + cond + " ? " + i + "++ : " + i + "--";
  ***REMOVED***
      post = "***REMOVED*** " + result + ".push(" + i + "); ***REMOVED***\n" + idt + "return " + result + ";\n" + o.indent;
      hasArgs = function(node) ***REMOVED***
        return node != null ? node.contains(isLiteralArguments) : void 0;
  ***REMOVED***;
      if (hasArgs(this.from) || hasArgs(this.to)) ***REMOVED***
        args = ', arguments';
  ***REMOVED***
      return [this.makeCode("(function() ***REMOVED***" + pre + "\n" + idt + "for (" + body + ")" + post + "***REMOVED***).apply(this" + (args != null ? args : '') + ")")];
***REMOVED***;

    return Range;

  ***REMOVED***)(Base);

  exports.Slice = Slice = (function(superClass1) ***REMOVED***
    extend1(Slice, superClass1);

    Slice.prototype.children = ['range'];

    function Slice(range1) ***REMOVED***
      this.range = range1;
      Slice.__super__.constructor.call(this);
***REMOVED***

    Slice.prototype.compileNode = function(o) ***REMOVED***
      var compiled, compiledText, from, fromCompiled, ref3, to, toStr;
      ref3 = this.range, to = ref3.to, from = ref3.from;
      fromCompiled = from && from.compileToFragments(o, LEVEL_PAREN) || [this.makeCode('0')];
      if (to) ***REMOVED***
        compiled = to.compileToFragments(o, LEVEL_PAREN);
        compiledText = fragmentsToText(compiled);
        if (!(!this.range.exclusive && +compiledText === -1)) ***REMOVED***
          toStr = ', ' + (this.range.exclusive ? compiledText : SIMPLENUM.test(compiledText) ? "" + (+compiledText + 1) : (compiled = to.compileToFragments(o, LEVEL_ACCESS), "+" + (fragmentsToText(compiled)) + " + 1 || 9e9"));
***REMOVED***
  ***REMOVED***
      return [this.makeCode(".slice(" + (fragmentsToText(fromCompiled)) + (toStr || '') + ")")];
***REMOVED***;

    return Slice;

  ***REMOVED***)(Base);

  exports.Obj = Obj = (function(superClass1) ***REMOVED***
    extend1(Obj, superClass1);

    function Obj(props, generated) ***REMOVED***
      this.generated = generated != null ? generated : false;
      this.objects = this.properties = props || [];
***REMOVED***

    Obj.prototype.children = ['properties'];

    Obj.prototype.compileNode = function(o) ***REMOVED***
      var answer, dynamicIndex, hasDynamic, i, idt, indent, j, join, k, key, l, lastNoncom, len1, len2, len3, node, oref, prop, props, ref3, value;
      props = this.properties;
      if (this.generated) ***REMOVED***
        for (j = 0, len1 = props.length; j < len1; j++) ***REMOVED***
          node = props[j];
          if (node instanceof Value) ***REMOVED***
            node.error('cannot have an implicit value in an implicit object');
  ***REMOVED***
***REMOVED***
  ***REMOVED***
      for (dynamicIndex = k = 0, len2 = props.length; k < len2; dynamicIndex = ++k) ***REMOVED***
        prop = props[dynamicIndex];
        if ((prop.variable || prop).base instanceof Parens) ***REMOVED***
          break;
***REMOVED***
  ***REMOVED***
      hasDynamic = dynamicIndex < props.length;
      idt = o.indent += TAB;
      lastNoncom = this.lastNonComment(this.properties);
      answer = [];
      if (hasDynamic) ***REMOVED***
        oref = o.scope.freeVariable('obj');
        answer.push(this.makeCode("(\n" + idt + oref + " = "));
  ***REMOVED***
      answer.push(this.makeCode("***REMOVED***" + (props.length === 0 || dynamicIndex === 0 ? '***REMOVED***' : '\n')));
      for (i = l = 0, len3 = props.length; l < len3; i = ++l) ***REMOVED***
        prop = props[i];
        if (i === dynamicIndex) ***REMOVED***
          if (i !== 0) ***REMOVED***
            answer.push(this.makeCode("\n" + idt + "***REMOVED***"));
  ***REMOVED***
          answer.push(this.makeCode(',\n'));
***REMOVED***
        join = i === props.length - 1 || i === dynamicIndex - 1 ? '' : prop === lastNoncom || prop instanceof Comment ? '\n' : ',\n';
        indent = prop instanceof Comment ? '' : idt;
        if (hasDynamic && i < dynamicIndex) ***REMOVED***
          indent += TAB;
***REMOVED***
        if (prop instanceof Assign) ***REMOVED***
          if (prop.context !== 'object') ***REMOVED***
            prop.operatorToken.error("unexpected " + prop.operatorToken.value);
  ***REMOVED***
          if (prop.variable instanceof Value && prop.variable.hasProperties()) ***REMOVED***
            prop.variable.error('invalid object key');
  ***REMOVED***
***REMOVED***
        if (prop instanceof Value && prop["this"]) ***REMOVED***
          prop = new Assign(prop.properties[0].name, prop, 'object');
***REMOVED***
        if (!(prop instanceof Comment)) ***REMOVED***
          if (i < dynamicIndex) ***REMOVED***
            if (!(prop instanceof Assign)) ***REMOVED***
              prop = new Assign(prop, prop, 'object');
***REMOVED***
            (prop.variable.base || prop.variable).asKey = true;
  ***REMOVED*** else ***REMOVED***
            if (prop instanceof Assign) ***REMOVED***
              key = prop.variable;
              value = prop.value;
***REMOVED*** else ***REMOVED***
              ref3 = prop.base.cache(o), key = ref3[0], value = ref3[1];
***REMOVED***
            prop = new Assign(new Value(new Literal(oref), [new Access(key)]), value);
  ***REMOVED***
***REMOVED***
        if (indent) ***REMOVED***
          answer.push(this.makeCode(indent));
***REMOVED***
        answer.push.apply(answer, prop.compileToFragments(o, LEVEL_TOP));
        if (join) ***REMOVED***
          answer.push(this.makeCode(join));
***REMOVED***
  ***REMOVED***
      if (hasDynamic) ***REMOVED***
        answer.push(this.makeCode(",\n" + idt + oref + "\n" + this.tab + ")"));
  ***REMOVED*** else ***REMOVED***
        if (props.length !== 0) ***REMOVED***
          answer.push(this.makeCode("\n" + this.tab + "***REMOVED***"));
***REMOVED***
  ***REMOVED***
      if (this.front && !hasDynamic) ***REMOVED***
        return this.wrapInBraces(answer);
  ***REMOVED*** else ***REMOVED***
        return answer;
  ***REMOVED***
***REMOVED***;

    Obj.prototype.assigns = function(name) ***REMOVED***
      var j, len1, prop, ref3;
      ref3 = this.properties;
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        prop = ref3[j];
        if (prop.assigns(name)) ***REMOVED***
          return true;
***REMOVED***
  ***REMOVED***
      return false;
***REMOVED***;

    return Obj;

  ***REMOVED***)(Base);

  exports.Arr = Arr = (function(superClass1) ***REMOVED***
    extend1(Arr, superClass1);

    function Arr(objs) ***REMOVED***
      this.objects = objs || [];
***REMOVED***

    Arr.prototype.children = ['objects'];

    Arr.prototype.compileNode = function(o) ***REMOVED***
      var answer, compiledObjs, fragments, index, j, len1, obj;
      if (!this.objects.length) ***REMOVED***
        return [this.makeCode('[]')];
  ***REMOVED***
      o.indent += TAB;
      answer = Splat.compileSplattedArray(o, this.objects);
      if (answer.length) ***REMOVED***
        return answer;
  ***REMOVED***
      answer = [];
      compiledObjs = (function() ***REMOVED***
        var j, len1, ref3, results;
        ref3 = this.objects;
        results = [];
        for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
          obj = ref3[j];
          results.push(obj.compileToFragments(o, LEVEL_LIST));
***REMOVED***
        return results;
  ***REMOVED***).call(this);
      for (index = j = 0, len1 = compiledObjs.length; j < len1; index = ++j) ***REMOVED***
        fragments = compiledObjs[index];
        if (index) ***REMOVED***
          answer.push(this.makeCode(", "));
***REMOVED***
        answer.push.apply(answer, fragments);
  ***REMOVED***
      if (fragmentsToText(answer).indexOf('\n') >= 0) ***REMOVED***
        answer.unshift(this.makeCode("[\n" + o.indent));
        answer.push(this.makeCode("\n" + this.tab + "]"));
  ***REMOVED*** else ***REMOVED***
        answer.unshift(this.makeCode("["));
        answer.push(this.makeCode("]"));
  ***REMOVED***
      return answer;
***REMOVED***;

    Arr.prototype.assigns = function(name) ***REMOVED***
      var j, len1, obj, ref3;
      ref3 = this.objects;
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        obj = ref3[j];
        if (obj.assigns(name)) ***REMOVED***
          return true;
***REMOVED***
  ***REMOVED***
      return false;
***REMOVED***;

    return Arr;

  ***REMOVED***)(Base);

  exports.Class = Class = (function(superClass1) ***REMOVED***
    extend1(Class, superClass1);

    function Class(variable1, parent1, body1) ***REMOVED***
      this.variable = variable1;
      this.parent = parent1;
      this.body = body1 != null ? body1 : new Block;
      this.boundFuncs = [];
      this.body.classBody = true;
***REMOVED***

    Class.prototype.children = ['variable', 'parent', 'body'];

    Class.prototype.determineName = function() ***REMOVED***
      var decl, ref3, tail;
      if (!this.variable) ***REMOVED***
        return null;
  ***REMOVED***
      ref3 = this.variable.properties, tail = ref3[ref3.length - 1];
      decl = tail ? tail instanceof Access && tail.name.value : this.variable.base.value;
      if (indexOf.call(STRICT_PROSCRIBED, decl) >= 0) ***REMOVED***
        this.variable.error("class variable name may not be " + decl);
  ***REMOVED***
      return decl && (decl = IDENTIFIER.test(decl) && decl);
***REMOVED***;

    Class.prototype.setContext = function(name) ***REMOVED***
      return this.body.traverseChildren(false, function(node) ***REMOVED***
        if (node.classBody) ***REMOVED***
          return false;
***REMOVED***
        if (node instanceof Literal && node.value === 'this') ***REMOVED***
          return node.value = name;
***REMOVED*** else if (node instanceof Code) ***REMOVED***
          if (node.bound) ***REMOVED***
            return node.context = name;
  ***REMOVED***
***REMOVED***
  ***REMOVED***);
***REMOVED***;

    Class.prototype.addBoundFunctions = function(o) ***REMOVED***
      var bvar, j, len1, lhs, ref3;
      ref3 = this.boundFuncs;
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        bvar = ref3[j];
        lhs = (new Value(new Literal("this"), [new Access(bvar)])).compile(o);
        this.ctor.body.unshift(new Literal(lhs + " = " + (utility('bind', o)) + "(" + lhs + ", this)"));
  ***REMOVED***
***REMOVED***;

    Class.prototype.addProperties = function(node, name, o) ***REMOVED***
      var acc, assign, base, exprs, func, props;
      props = node.base.properties.slice(0);
      exprs = (function() ***REMOVED***
        var results;
        results = [];
        while (assign = props.shift()) ***REMOVED***
          if (assign instanceof Assign) ***REMOVED***
            base = assign.variable.base;
            delete assign.context;
            func = assign.value;
            if (base.value === 'constructor') ***REMOVED***
              if (this.ctor) ***REMOVED***
                assign.error('cannot define more than one constructor in a class');
  ***REMOVED***
              if (func.bound) ***REMOVED***
                assign.error('cannot define a constructor as a bound function');
  ***REMOVED***
              if (func instanceof Code) ***REMOVED***
                assign = this.ctor = func;
  ***REMOVED*** else ***REMOVED***
                this.externalCtor = o.classScope.freeVariable('class');
                assign = new Assign(new Literal(this.externalCtor), func);
  ***REMOVED***
***REMOVED*** else ***REMOVED***
              if (assign.variable["this"]) ***REMOVED***
                func["static"] = true;
  ***REMOVED*** else ***REMOVED***
                acc = base.isComplex() ? new Index(base) : new Access(base);
                assign.variable = new Value(new Literal(name), [new Access(new Literal('prototype')), acc]);
                if (func instanceof Code && func.bound) ***REMOVED***
                  this.boundFuncs.push(base);
                  func.bound = false;
***REMOVED***
  ***REMOVED***
***REMOVED***
  ***REMOVED***
          results.push(assign);
***REMOVED***
        return results;
  ***REMOVED***).call(this);
      return compact(exprs);
***REMOVED***;

    Class.prototype.walkBody = function(name, o) ***REMOVED***
      return this.traverseChildren(false, (function(_this) ***REMOVED***
        return function(child) ***REMOVED***
          var cont, exps, i, j, len1, node, ref3;
          cont = true;
          if (child instanceof Class) ***REMOVED***
            return false;
  ***REMOVED***
          if (child instanceof Block) ***REMOVED***
            ref3 = exps = child.expressions;
            for (i = j = 0, len1 = ref3.length; j < len1; i = ++j) ***REMOVED***
              node = ref3[i];
              if (node instanceof Assign && node.variable.looksStatic(name)) ***REMOVED***
                node.value["static"] = true;
  ***REMOVED*** else if (node instanceof Value && node.isObject(true)) ***REMOVED***
                cont = false;
                exps[i] = _this.addProperties(node, name, o);
  ***REMOVED***
***REMOVED***
            child.expressions = exps = flatten(exps);
  ***REMOVED***
          return cont && !(child instanceof Class);
***REMOVED***;
  ***REMOVED***)(this));
***REMOVED***;

    Class.prototype.hoistDirectivePrologue = function() ***REMOVED***
      var expressions, index, node;
      index = 0;
      expressions = this.body.expressions;
      while ((node = expressions[index]) && node instanceof Comment || node instanceof Value && node.isString()) ***REMOVED***
        ++index;
  ***REMOVED***
      return this.directives = expressions.splice(0, index);
***REMOVED***;

    Class.prototype.ensureConstructor = function(name) ***REMOVED***
      if (!this.ctor) ***REMOVED***
        this.ctor = new Code;
        if (this.externalCtor) ***REMOVED***
          this.ctor.body.push(new Literal(this.externalCtor + ".apply(this, arguments)"));
***REMOVED*** else if (this.parent) ***REMOVED***
          this.ctor.body.push(new Literal(name + ".__super__.constructor.apply(this, arguments)"));
***REMOVED***
        this.ctor.body.makeReturn();
        this.body.expressions.unshift(this.ctor);
  ***REMOVED***
      this.ctor.ctor = this.ctor.name = name;
      this.ctor.klass = null;
      return this.ctor.noReturn = true;
***REMOVED***;

    Class.prototype.compileNode = function(o) ***REMOVED***
      var args, argumentsNode, func, jumpNode, klass, lname, name, ref3, superClass;
      if (jumpNode = this.body.jumps()) ***REMOVED***
        jumpNode.error('Class bodies cannot contain pure statements');
  ***REMOVED***
      if (argumentsNode = this.body.contains(isLiteralArguments)) ***REMOVED***
        argumentsNode.error("Class bodies shouldn't reference arguments");
  ***REMOVED***
      name = this.determineName() || '_Class';
      if (name.reserved) ***REMOVED***
        name = "_" + name;
  ***REMOVED***
      lname = new Literal(name);
      func = new Code([], Block.wrap([this.body]));
      args = [];
      o.classScope = func.makeScope(o.scope);
      this.hoistDirectivePrologue();
      this.setContext(name);
      this.walkBody(name, o);
      this.ensureConstructor(name);
      this.addBoundFunctions(o);
      this.body.spaced = true;
      this.body.expressions.push(lname);
      if (this.parent) ***REMOVED***
        superClass = new Literal(o.classScope.freeVariable('superClass', ***REMOVED***
          reserve: false
***REMOVED***));
        this.body.expressions.unshift(new Extends(lname, superClass));
        func.params.push(new Param(superClass));
        args.push(this.parent);
  ***REMOVED***
      (ref3 = this.body.expressions).unshift.apply(ref3, this.directives);
      klass = new Parens(new Call(func, args));
      if (this.variable) ***REMOVED***
        klass = new Assign(this.variable, klass);
  ***REMOVED***
      return klass.compileToFragments(o);
***REMOVED***;

    return Class;

  ***REMOVED***)(Base);

  exports.Assign = Assign = (function(superClass1) ***REMOVED***
    extend1(Assign, superClass1);

    function Assign(variable1, value1, context, options) ***REMOVED***
      var forbidden, name, ref3;
      this.variable = variable1;
      this.value = value1;
      this.context = context;
      if (options == null) ***REMOVED***
        options = ***REMOVED******REMOVED***;
  ***REMOVED***
      this.param = options.param, this.subpattern = options.subpattern, this.operatorToken = options.operatorToken;
      forbidden = (ref3 = (name = this.variable.unwrapAll().value), indexOf.call(STRICT_PROSCRIBED, ref3) >= 0);
      if (forbidden && this.context !== 'object') ***REMOVED***
        this.variable.error("variable name may not be \"" + name + "\"");
  ***REMOVED***
***REMOVED***

    Assign.prototype.children = ['variable', 'value'];

    Assign.prototype.isStatement = function(o) ***REMOVED***
      return (o != null ? o.level : void 0) === LEVEL_TOP && (this.context != null) && indexOf.call(this.context, "?") >= 0;
***REMOVED***;

    Assign.prototype.assigns = function(name) ***REMOVED***
      return this[this.context === 'object' ? 'value' : 'variable'].assigns(name);
***REMOVED***;

    Assign.prototype.unfoldSoak = function(o) ***REMOVED***
      return unfoldSoak(o, this, 'variable');
***REMOVED***;

    Assign.prototype.compileNode = function(o) ***REMOVED***
      var answer, compiledName, isValue, j, name, properties, prototype, ref3, ref4, ref5, ref6, ref7, val, varBase;
      if (isValue = this.variable instanceof Value) ***REMOVED***
        if (this.variable.isArray() || this.variable.isObject()) ***REMOVED***
          return this.compilePatternMatch(o);
***REMOVED***
        if (this.variable.isSplice()) ***REMOVED***
          return this.compileSplice(o);
***REMOVED***
        if ((ref3 = this.context) === '||=' || ref3 === '&&=' || ref3 === '?=') ***REMOVED***
          return this.compileConditional(o);
***REMOVED***
        if ((ref4 = this.context) === '**=' || ref4 === '//=' || ref4 === '%%=') ***REMOVED***
          return this.compileSpecialMath(o);
***REMOVED***
  ***REMOVED***
      if (this.value instanceof Code) ***REMOVED***
        if (this.value["static"]) ***REMOVED***
          this.value.klass = this.variable.base;
          this.value.name = this.variable.properties[0];
          this.value.variable = this.variable;
***REMOVED*** else if (((ref5 = this.variable.properties) != null ? ref5.length : void 0) >= 2) ***REMOVED***
          ref6 = this.variable.properties, properties = 3 <= ref6.length ? slice.call(ref6, 0, j = ref6.length - 2) : (j = 0, []), prototype = ref6[j++], name = ref6[j++];
          if (((ref7 = prototype.name) != null ? ref7.value : void 0) === 'prototype') ***REMOVED***
            this.value.klass = new Value(this.variable.base, properties);
            this.value.name = name;
            this.value.variable = this.variable;
  ***REMOVED***
***REMOVED***
  ***REMOVED***
      if (!this.context) ***REMOVED***
        varBase = this.variable.unwrapAll();
        if (!varBase.isAssignable()) ***REMOVED***
          this.variable.error("\"" + (this.variable.compile(o)) + "\" cannot be assigned");
***REMOVED***
        if (!(typeof varBase.hasProperties === "function" ? varBase.hasProperties() : void 0)) ***REMOVED***
          if (this.param) ***REMOVED***
            o.scope.add(varBase.value, 'var');
  ***REMOVED*** else ***REMOVED***
            o.scope.find(varBase.value);
  ***REMOVED***
***REMOVED***
  ***REMOVED***
      val = this.value.compileToFragments(o, LEVEL_LIST);
      if (isValue && this.variable.base instanceof Obj) ***REMOVED***
        this.variable.front = true;
  ***REMOVED***
      compiledName = this.variable.compileToFragments(o, LEVEL_LIST);
      if (this.context === 'object') ***REMOVED***
        return compiledName.concat(this.makeCode(": "), val);
  ***REMOVED***
      answer = compiledName.concat(this.makeCode(" " + (this.context || '=') + " "), val);
      if (o.level <= LEVEL_LIST) ***REMOVED***
        return answer;
  ***REMOVED*** else ***REMOVED***
        return this.wrapInBraces(answer);
  ***REMOVED***
***REMOVED***;

    Assign.prototype.compilePatternMatch = function(o) ***REMOVED***
      var acc, assigns, code, defaultValue, expandedIdx, fragments, i, idx, isObject, ivar, j, len1, name, obj, objects, olen, ref, ref3, ref4, ref5, ref6, ref7, rest, top, val, value, vvar, vvarText;
      top = o.level === LEVEL_TOP;
      value = this.value;
      objects = this.variable.base.objects;
      if (!(olen = objects.length)) ***REMOVED***
        code = value.compileToFragments(o);
        if (o.level >= LEVEL_OP) ***REMOVED***
          return this.wrapInBraces(code);
***REMOVED*** else ***REMOVED***
          return code;
***REMOVED***
  ***REMOVED***
      obj = objects[0];
      if (olen === 1 && obj instanceof Expansion) ***REMOVED***
        obj.error('Destructuring assignment has no target');
  ***REMOVED***
      isObject = this.variable.isObject();
      if (top && olen === 1 && !(obj instanceof Splat)) ***REMOVED***
        defaultValue = null;
        if (obj instanceof Assign && obj.context === 'object') ***REMOVED***
          ref3 = obj, (ref4 = ref3.variable, idx = ref4.base), obj = ref3.value;
          if (obj instanceof Assign) ***REMOVED***
            defaultValue = obj.value;
            obj = obj.variable;
  ***REMOVED***
***REMOVED*** else ***REMOVED***
          if (obj instanceof Assign) ***REMOVED***
            defaultValue = obj.value;
            obj = obj.variable;
  ***REMOVED***
          idx = isObject ? obj["this"] ? obj.properties[0].name : obj : new Literal(0);
***REMOVED***
        acc = IDENTIFIER.test(idx.unwrap().value);
        value = new Value(value);
        value.properties.push(new (acc ? Access : Index)(idx));
        if (ref5 = obj.unwrap().value, indexOf.call(RESERVED, ref5) >= 0) ***REMOVED***
          obj.error("assignment to a reserved word: " + (obj.compile(o)));
***REMOVED***
        if (defaultValue) ***REMOVED***
          value = new Op('?', value, defaultValue);
***REMOVED***
        return new Assign(obj, value, null, ***REMOVED***
          param: this.param
***REMOVED***).compileToFragments(o, LEVEL_TOP);
  ***REMOVED***
      vvar = value.compileToFragments(o, LEVEL_LIST);
      vvarText = fragmentsToText(vvar);
      assigns = [];
      expandedIdx = false;
      if (!IDENTIFIER.test(vvarText) || this.variable.assigns(vvarText)) ***REMOVED***
        assigns.push([this.makeCode((ref = o.scope.freeVariable('ref')) + " = ")].concat(slice.call(vvar)));
        vvar = [this.makeCode(ref)];
        vvarText = ref;
  ***REMOVED***
      for (i = j = 0, len1 = objects.length; j < len1; i = ++j) ***REMOVED***
        obj = objects[i];
        idx = i;
        if (!expandedIdx && obj instanceof Splat) ***REMOVED***
          name = obj.name.unwrap().value;
          obj = obj.unwrap();
          val = olen + " <= " + vvarText + ".length ? " + (utility('slice', o)) + ".call(" + vvarText + ", " + i;
          if (rest = olen - i - 1) ***REMOVED***
            ivar = o.scope.freeVariable('i', ***REMOVED***
              single: true
***REMOVED***);
            val += ", " + ivar + " = " + vvarText + ".length - " + rest + ") : (" + ivar + " = " + i + ", [])";
  ***REMOVED*** else ***REMOVED***
            val += ") : []";
  ***REMOVED***
          val = new Literal(val);
          expandedIdx = ivar + "++";
***REMOVED*** else if (!expandedIdx && obj instanceof Expansion) ***REMOVED***
          if (rest = olen - i - 1) ***REMOVED***
            if (rest === 1) ***REMOVED***
              expandedIdx = vvarText + ".length - 1";
***REMOVED*** else ***REMOVED***
              ivar = o.scope.freeVariable('i', ***REMOVED***
                single: true
  ***REMOVED***);
              val = new Literal(ivar + " = " + vvarText + ".length - " + rest);
              expandedIdx = ivar + "++";
              assigns.push(val.compileToFragments(o, LEVEL_LIST));
***REMOVED***
  ***REMOVED***
          continue;
***REMOVED*** else ***REMOVED***
          if (obj instanceof Splat || obj instanceof Expansion) ***REMOVED***
            obj.error("multiple splats/expansions are disallowed in an assignment");
  ***REMOVED***
          defaultValue = null;
          if (obj instanceof Assign && obj.context === 'object') ***REMOVED***
            ref6 = obj, (ref7 = ref6.variable, idx = ref7.base), obj = ref6.value;
            if (obj instanceof Assign) ***REMOVED***
              defaultValue = obj.value;
              obj = obj.variable;
***REMOVED***
  ***REMOVED*** else ***REMOVED***
            if (obj instanceof Assign) ***REMOVED***
              defaultValue = obj.value;
              obj = obj.variable;
***REMOVED***
            idx = isObject ? obj["this"] ? obj.properties[0].name : obj : new Literal(expandedIdx || idx);
  ***REMOVED***
          name = obj.unwrap().value;
          acc = IDENTIFIER.test(idx.unwrap().value);
          val = new Value(new Literal(vvarText), [new (acc ? Access : Index)(idx)]);
          if (defaultValue) ***REMOVED***
            val = new Op('?', val, defaultValue);
  ***REMOVED***
***REMOVED***
        if ((name != null) && indexOf.call(RESERVED, name) >= 0) ***REMOVED***
          obj.error("assignment to a reserved word: " + (obj.compile(o)));
***REMOVED***
        assigns.push(new Assign(obj, val, null, ***REMOVED***
          param: this.param,
          subpattern: true
***REMOVED***).compileToFragments(o, LEVEL_LIST));
  ***REMOVED***
      if (!(top || this.subpattern)) ***REMOVED***
        assigns.push(vvar);
  ***REMOVED***
      fragments = this.joinFragmentArrays(assigns, ', ');
      if (o.level < LEVEL_LIST) ***REMOVED***
        return fragments;
  ***REMOVED*** else ***REMOVED***
        return this.wrapInBraces(fragments);
  ***REMOVED***
***REMOVED***;

    Assign.prototype.compileConditional = function(o) ***REMOVED***
      var fragments, left, ref3, right;
      ref3 = this.variable.cacheReference(o), left = ref3[0], right = ref3[1];
      if (!left.properties.length && left.base instanceof Literal && left.base.value !== "this" && !o.scope.check(left.base.value)) ***REMOVED***
        this.variable.error("the variable \"" + left.base.value + "\" can't be assigned with " + this.context + " because it has not been declared before");
  ***REMOVED***
      if (indexOf.call(this.context, "?") >= 0) ***REMOVED***
        o.isExistentialEquals = true;
        return new If(new Existence(left), right, ***REMOVED***
          type: 'if'
***REMOVED***).addElse(new Assign(right, this.value, '=')).compileToFragments(o);
  ***REMOVED*** else ***REMOVED***
        fragments = new Op(this.context.slice(0, -1), left, new Assign(right, this.value, '=')).compileToFragments(o);
        if (o.level <= LEVEL_LIST) ***REMOVED***
          return fragments;
***REMOVED*** else ***REMOVED***
          return this.wrapInBraces(fragments);
***REMOVED***
  ***REMOVED***
***REMOVED***;

    Assign.prototype.compileSpecialMath = function(o) ***REMOVED***
      var left, ref3, right;
      ref3 = this.variable.cacheReference(o), left = ref3[0], right = ref3[1];
      return new Assign(left, new Op(this.context.slice(0, -1), right, this.value)).compileToFragments(o);
***REMOVED***;

    Assign.prototype.compileSplice = function(o) ***REMOVED***
      var answer, exclusive, from, fromDecl, fromRef, name, ref3, ref4, ref5, to, valDef, valRef;
      ref3 = this.variable.properties.pop().range, from = ref3.from, to = ref3.to, exclusive = ref3.exclusive;
      name = this.variable.compile(o);
      if (from) ***REMOVED***
        ref4 = this.cacheToCodeFragments(from.cache(o, LEVEL_OP)), fromDecl = ref4[0], fromRef = ref4[1];
  ***REMOVED*** else ***REMOVED***
        fromDecl = fromRef = '0';
  ***REMOVED***
      if (to) ***REMOVED***
        if (from instanceof Value && from.isSimpleNumber() && to instanceof Value && to.isSimpleNumber()) ***REMOVED***
          to = to.compile(o) - fromRef;
          if (!exclusive) ***REMOVED***
            to += 1;
  ***REMOVED***
***REMOVED*** else ***REMOVED***
          to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef;
          if (!exclusive) ***REMOVED***
            to += ' + 1';
  ***REMOVED***
***REMOVED***
  ***REMOVED*** else ***REMOVED***
        to = "9e9";
  ***REMOVED***
      ref5 = this.value.cache(o, LEVEL_LIST), valDef = ref5[0], valRef = ref5[1];
      answer = [].concat(this.makeCode("[].splice.apply(" + name + ", [" + fromDecl + ", " + to + "].concat("), valDef, this.makeCode(")), "), valRef);
      if (o.level > LEVEL_TOP) ***REMOVED***
        return this.wrapInBraces(answer);
  ***REMOVED*** else ***REMOVED***
        return answer;
  ***REMOVED***
***REMOVED***;

    return Assign;

  ***REMOVED***)(Base);

  exports.Code = Code = (function(superClass1) ***REMOVED***
    extend1(Code, superClass1);

    function Code(params, body, tag) ***REMOVED***
      this.params = params || [];
      this.body = body || new Block;
      this.bound = tag === 'boundfunc';
      this.isGenerator = !!this.body.contains(function(node) ***REMOVED***
        var ref3;
        return node instanceof Op && ((ref3 = node.operator) === 'yield' || ref3 === 'yield*');
  ***REMOVED***);
***REMOVED***

    Code.prototype.children = ['params', 'body'];

    Code.prototype.isStatement = function() ***REMOVED***
      return !!this.ctor;
***REMOVED***;

    Code.prototype.jumps = NO;

    Code.prototype.makeScope = function(parentScope) ***REMOVED***
      return new Scope(parentScope, this.body, this);
***REMOVED***;

    Code.prototype.compileNode = function(o) ***REMOVED***
      var answer, boundfunc, code, exprs, i, j, k, l, len1, len2, len3, len4, len5, len6, lit, m, p, param, params, q, r, ref, ref3, ref4, ref5, ref6, ref7, ref8, splats, uniqs, val, wasEmpty, wrapper;
      if (this.bound && ((ref3 = o.scope.method) != null ? ref3.bound : void 0)) ***REMOVED***
        this.context = o.scope.method.context;
  ***REMOVED***
      if (this.bound && !this.context) ***REMOVED***
        this.context = '_this';
        wrapper = new Code([new Param(new Literal(this.context))], new Block([this]));
        boundfunc = new Call(wrapper, [new Literal('this')]);
        boundfunc.updateLocationDataIfMissing(this.locationData);
        return boundfunc.compileNode(o);
  ***REMOVED***
      o.scope = del(o, 'classScope') || this.makeScope(o.scope);
      o.scope.shared = del(o, 'sharedScope');
      o.indent += TAB;
      delete o.bare;
      delete o.isExistentialEquals;
      params = [];
      exprs = [];
      ref4 = this.params;
      for (j = 0, len1 = ref4.length; j < len1; j++) ***REMOVED***
        param = ref4[j];
        if (!(param instanceof Expansion)) ***REMOVED***
          o.scope.parameter(param.asReference(o));
***REMOVED***
  ***REMOVED***
      ref5 = this.params;
      for (k = 0, len2 = ref5.length; k < len2; k++) ***REMOVED***
        param = ref5[k];
        if (!(param.splat || param instanceof Expansion)) ***REMOVED***
          continue;
***REMOVED***
        ref6 = this.params;
        for (l = 0, len3 = ref6.length; l < len3; l++) ***REMOVED***
          p = ref6[l];
          if (!(p instanceof Expansion) && p.name.value) ***REMOVED***
            o.scope.add(p.name.value, 'var', true);
  ***REMOVED***
***REMOVED***
        splats = new Assign(new Value(new Arr((function() ***REMOVED***
          var len4, m, ref7, results;
          ref7 = this.params;
          results = [];
          for (m = 0, len4 = ref7.length; m < len4; m++) ***REMOVED***
            p = ref7[m];
            results.push(p.asReference(o));
  ***REMOVED***
          return results;
***REMOVED***).call(this))), new Value(new Literal('arguments')));
        break;
  ***REMOVED***
      ref7 = this.params;
      for (m = 0, len4 = ref7.length; m < len4; m++) ***REMOVED***
        param = ref7[m];
        if (param.isComplex()) ***REMOVED***
          val = ref = param.asReference(o);
          if (param.value) ***REMOVED***
            val = new Op('?', ref, param.value);
  ***REMOVED***
          exprs.push(new Assign(new Value(param.name), val, '=', ***REMOVED***
            param: true
  ***REMOVED***));
***REMOVED*** else ***REMOVED***
          ref = param;
          if (param.value) ***REMOVED***
            lit = new Literal(ref.name.value + ' == null');
            val = new Assign(new Value(param.name), param.value, '=');
            exprs.push(new If(lit, val));
  ***REMOVED***
***REMOVED***
        if (!splats) ***REMOVED***
          params.push(ref);
***REMOVED***
  ***REMOVED***
      wasEmpty = this.body.isEmpty();
      if (splats) ***REMOVED***
        exprs.unshift(splats);
  ***REMOVED***
      if (exprs.length) ***REMOVED***
        (ref8 = this.body.expressions).unshift.apply(ref8, exprs);
  ***REMOVED***
      for (i = q = 0, len5 = params.length; q < len5; i = ++q) ***REMOVED***
        p = params[i];
        params[i] = p.compileToFragments(o);
        o.scope.parameter(fragmentsToText(params[i]));
  ***REMOVED***
      uniqs = [];
      this.eachParamName(function(name, node) ***REMOVED***
        if (indexOf.call(uniqs, name) >= 0) ***REMOVED***
          node.error("multiple parameters named " + name);
***REMOVED***
        return uniqs.push(name);
  ***REMOVED***);
      if (!(wasEmpty || this.noReturn)) ***REMOVED***
        this.body.makeReturn();
  ***REMOVED***
      code = 'function';
      if (this.isGenerator) ***REMOVED***
        code += '*';
  ***REMOVED***
      if (this.ctor) ***REMOVED***
        code += ' ' + this.name;
  ***REMOVED***
      code += '(';
      answer = [this.makeCode(code)];
      for (i = r = 0, len6 = params.length; r < len6; i = ++r) ***REMOVED***
        p = params[i];
        if (i) ***REMOVED***
          answer.push(this.makeCode(", "));
***REMOVED***
        answer.push.apply(answer, p);
  ***REMOVED***
      answer.push(this.makeCode(') ***REMOVED***'));
      if (!this.body.isEmpty()) ***REMOVED***
        answer = answer.concat(this.makeCode("\n"), this.body.compileWithDeclarations(o), this.makeCode("\n" + this.tab));
  ***REMOVED***
      answer.push(this.makeCode('***REMOVED***'));
      if (this.ctor) ***REMOVED***
        return [this.makeCode(this.tab)].concat(slice.call(answer));
  ***REMOVED***
      if (this.front || (o.level >= LEVEL_ACCESS)) ***REMOVED***
        return this.wrapInBraces(answer);
  ***REMOVED*** else ***REMOVED***
        return answer;
  ***REMOVED***
***REMOVED***;

    Code.prototype.eachParamName = function(iterator) ***REMOVED***
      var j, len1, param, ref3, results;
      ref3 = this.params;
      results = [];
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        param = ref3[j];
        results.push(param.eachName(iterator));
  ***REMOVED***
      return results;
***REMOVED***;

    Code.prototype.traverseChildren = function(crossScope, func) ***REMOVED***
      if (crossScope) ***REMOVED***
        return Code.__super__.traverseChildren.call(this, crossScope, func);
  ***REMOVED***
***REMOVED***;

    return Code;

  ***REMOVED***)(Base);

  exports.Param = Param = (function(superClass1) ***REMOVED***
    extend1(Param, superClass1);

    function Param(name1, value1, splat) ***REMOVED***
      var name, ref3, token;
      this.name = name1;
      this.value = value1;
      this.splat = splat;
      if (ref3 = (name = this.name.unwrapAll().value), indexOf.call(STRICT_PROSCRIBED, ref3) >= 0) ***REMOVED***
        this.name.error("parameter name \"" + name + "\" is not allowed");
  ***REMOVED***
      if (this.name instanceof Obj && this.name.generated) ***REMOVED***
        token = this.name.objects[0].operatorToken;
        token.error("unexpected " + token.value);
  ***REMOVED***
***REMOVED***

    Param.prototype.children = ['name', 'value'];

    Param.prototype.compileToFragments = function(o) ***REMOVED***
      return this.name.compileToFragments(o, LEVEL_LIST);
***REMOVED***;

    Param.prototype.asReference = function(o) ***REMOVED***
      var name, node;
      if (this.reference) ***REMOVED***
        return this.reference;
  ***REMOVED***
      node = this.name;
      if (node["this"]) ***REMOVED***
        name = node.properties[0].name.value;
        if (name.reserved) ***REMOVED***
          name = "_" + name;
***REMOVED***
        node = new Literal(o.scope.freeVariable(name));
  ***REMOVED*** else if (node.isComplex()) ***REMOVED***
        node = new Literal(o.scope.freeVariable('arg'));
  ***REMOVED***
      node = new Value(node);
      if (this.splat) ***REMOVED***
        node = new Splat(node);
  ***REMOVED***
      node.updateLocationDataIfMissing(this.locationData);
      return this.reference = node;
***REMOVED***;

    Param.prototype.isComplex = function() ***REMOVED***
      return this.name.isComplex();
***REMOVED***;

    Param.prototype.eachName = function(iterator, name) ***REMOVED***
      var atParam, j, len1, node, obj, ref3;
      if (name == null) ***REMOVED***
        name = this.name;
  ***REMOVED***
      atParam = function(obj) ***REMOVED***
        return iterator("@" + obj.properties[0].name.value, obj);
  ***REMOVED***;
      if (name instanceof Literal) ***REMOVED***
        return iterator(name.value, name);
  ***REMOVED***
      if (name instanceof Value) ***REMOVED***
        return atParam(name);
  ***REMOVED***
      ref3 = name.objects;
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        obj = ref3[j];
        if (obj instanceof Assign && (obj.context == null)) ***REMOVED***
          obj = obj.variable;
***REMOVED***
        if (obj instanceof Assign) ***REMOVED***
          this.eachName(iterator, obj.value.unwrap());
***REMOVED*** else if (obj instanceof Splat) ***REMOVED***
          node = obj.name.unwrap();
          iterator(node.value, node);
***REMOVED*** else if (obj instanceof Value) ***REMOVED***
          if (obj.isArray() || obj.isObject()) ***REMOVED***
            this.eachName(iterator, obj.base);
  ***REMOVED*** else if (obj["this"]) ***REMOVED***
            atParam(obj);
  ***REMOVED*** else ***REMOVED***
            iterator(obj.base.value, obj.base);
  ***REMOVED***
***REMOVED*** else if (!(obj instanceof Expansion)) ***REMOVED***
          obj.error("illegal parameter " + (obj.compile()));
***REMOVED***
  ***REMOVED***
***REMOVED***;

    return Param;

  ***REMOVED***)(Base);

  exports.Splat = Splat = (function(superClass1) ***REMOVED***
    extend1(Splat, superClass1);

    Splat.prototype.children = ['name'];

    Splat.prototype.isAssignable = YES;

    function Splat(name) ***REMOVED***
      this.name = name.compile ? name : new Literal(name);
***REMOVED***

    Splat.prototype.assigns = function(name) ***REMOVED***
      return this.name.assigns(name);
***REMOVED***;

    Splat.prototype.compileToFragments = function(o) ***REMOVED***
      return this.name.compileToFragments(o);
***REMOVED***;

    Splat.prototype.unwrap = function() ***REMOVED***
      return this.name;
***REMOVED***;

    Splat.compileSplattedArray = function(o, list, apply) ***REMOVED***
      var args, base, compiledNode, concatPart, fragments, i, index, j, last, len1, node;
      index = -1;
      while ((node = list[++index]) && !(node instanceof Splat)) ***REMOVED***
        continue;
  ***REMOVED***
      if (index >= list.length) ***REMOVED***
        return [];
  ***REMOVED***
      if (list.length === 1) ***REMOVED***
        node = list[0];
        fragments = node.compileToFragments(o, LEVEL_LIST);
        if (apply) ***REMOVED***
          return fragments;
***REMOVED***
        return [].concat(node.makeCode((utility('slice', o)) + ".call("), fragments, node.makeCode(")"));
  ***REMOVED***
      args = list.slice(index);
      for (i = j = 0, len1 = args.length; j < len1; i = ++j) ***REMOVED***
        node = args[i];
        compiledNode = node.compileToFragments(o, LEVEL_LIST);
        args[i] = node instanceof Splat ? [].concat(node.makeCode((utility('slice', o)) + ".call("), compiledNode, node.makeCode(")")) : [].concat(node.makeCode("["), compiledNode, node.makeCode("]"));
  ***REMOVED***
      if (index === 0) ***REMOVED***
        node = list[0];
        concatPart = node.joinFragmentArrays(args.slice(1), ', ');
        return args[0].concat(node.makeCode(".concat("), concatPart, node.makeCode(")"));
  ***REMOVED***
      base = (function() ***REMOVED***
        var k, len2, ref3, results;
        ref3 = list.slice(0, index);
        results = [];
        for (k = 0, len2 = ref3.length; k < len2; k++) ***REMOVED***
          node = ref3[k];
          results.push(node.compileToFragments(o, LEVEL_LIST));
***REMOVED***
        return results;
  ***REMOVED***)();
      base = list[0].joinFragmentArrays(base, ', ');
      concatPart = list[index].joinFragmentArrays(args, ', ');
      last = list[list.length - 1];
      return [].concat(list[0].makeCode("["), base, list[index].makeCode("].concat("), concatPart, last.makeCode(")"));
***REMOVED***;

    return Splat;

  ***REMOVED***)(Base);

  exports.Expansion = Expansion = (function(superClass1) ***REMOVED***
    extend1(Expansion, superClass1);

    function Expansion() ***REMOVED***
      return Expansion.__super__.constructor.apply(this, arguments);
***REMOVED***

    Expansion.prototype.isComplex = NO;

    Expansion.prototype.compileNode = function(o) ***REMOVED***
      return this.error('Expansion must be used inside a destructuring assignment or parameter list');
***REMOVED***;

    Expansion.prototype.asReference = function(o) ***REMOVED***
      return this;
***REMOVED***;

    Expansion.prototype.eachName = function(iterator) ***REMOVED******REMOVED***;

    return Expansion;

  ***REMOVED***)(Base);

  exports.While = While = (function(superClass1) ***REMOVED***
    extend1(While, superClass1);

    function While(condition, options) ***REMOVED***
      this.condition = (options != null ? options.invert : void 0) ? condition.invert() : condition;
      this.guard = options != null ? options.guard : void 0;
***REMOVED***

    While.prototype.children = ['condition', 'guard', 'body'];

    While.prototype.isStatement = YES;

    While.prototype.makeReturn = function(res) ***REMOVED***
      if (res) ***REMOVED***
        return While.__super__.makeReturn.apply(this, arguments);
  ***REMOVED*** else ***REMOVED***
        this.returns = !this.jumps(***REMOVED***
          loop: true
***REMOVED***);
        return this;
  ***REMOVED***
***REMOVED***;

    While.prototype.addBody = function(body1) ***REMOVED***
      this.body = body1;
      return this;
***REMOVED***;

    While.prototype.jumps = function() ***REMOVED***
      var expressions, j, jumpNode, len1, node;
      expressions = this.body.expressions;
      if (!expressions.length) ***REMOVED***
        return false;
  ***REMOVED***
      for (j = 0, len1 = expressions.length; j < len1; j++) ***REMOVED***
        node = expressions[j];
        if (jumpNode = node.jumps(***REMOVED***
          loop: true
***REMOVED***)) ***REMOVED***
          return jumpNode;
***REMOVED***
  ***REMOVED***
      return false;
***REMOVED***;

    While.prototype.compileNode = function(o) ***REMOVED***
      var answer, body, rvar, set;
      o.indent += TAB;
      set = '';
      body = this.body;
      if (body.isEmpty()) ***REMOVED***
        body = this.makeCode('');
  ***REMOVED*** else ***REMOVED***
        if (this.returns) ***REMOVED***
          body.makeReturn(rvar = o.scope.freeVariable('results'));
          set = "" + this.tab + rvar + " = [];\n";
***REMOVED***
        if (this.guard) ***REMOVED***
          if (body.expressions.length > 1) ***REMOVED***
            body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Literal("continue")));
  ***REMOVED*** else ***REMOVED***
            if (this.guard) ***REMOVED***
              body = Block.wrap([new If(this.guard, body)]);
***REMOVED***
  ***REMOVED***
***REMOVED***
        body = [].concat(this.makeCode("\n"), body.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab));
  ***REMOVED***
      answer = [].concat(this.makeCode(set + this.tab + "while ("), this.condition.compileToFragments(o, LEVEL_PAREN), this.makeCode(") ***REMOVED***"), body, this.makeCode("***REMOVED***"));
      if (this.returns) ***REMOVED***
        answer.push(this.makeCode("\n" + this.tab + "return " + rvar + ";"));
  ***REMOVED***
      return answer;
***REMOVED***;

    return While;

  ***REMOVED***)(Base);

  exports.Op = Op = (function(superClass1) ***REMOVED***
    var CONVERSIONS, INVERSIONS;

    extend1(Op, superClass1);

    function Op(op, first, second, flip) ***REMOVED***
      if (op === 'in') ***REMOVED***
        return new In(first, second);
  ***REMOVED***
      if (op === 'do') ***REMOVED***
        return this.generateDo(first);
  ***REMOVED***
      if (op === 'new') ***REMOVED***
        if (first instanceof Call && !first["do"] && !first.isNew) ***REMOVED***
          return first.newInstance();
***REMOVED***
        if (first instanceof Code && first.bound || first["do"]) ***REMOVED***
          first = new Parens(first);
***REMOVED***
  ***REMOVED***
      this.operator = CONVERSIONS[op] || op;
      this.first = first;
      this.second = second;
      this.flip = !!flip;
      return this;
***REMOVED***

    CONVERSIONS = ***REMOVED***
      '==': '===',
      '!=': '!==',
      'of': 'in',
      'yieldfrom': 'yield*'
***REMOVED***;

    INVERSIONS = ***REMOVED***
      '!==': '===',
      '===': '!=='
***REMOVED***;

    Op.prototype.children = ['first', 'second'];

    Op.prototype.isSimpleNumber = NO;

    Op.prototype.isYield = function() ***REMOVED***
      var ref3;
      return (ref3 = this.operator) === 'yield' || ref3 === 'yield*';
***REMOVED***;

    Op.prototype.isYieldReturn = function() ***REMOVED***
      return this.isYield() && this.first instanceof Return;
***REMOVED***;

    Op.prototype.isUnary = function() ***REMOVED***
      return !this.second;
***REMOVED***;

    Op.prototype.isComplex = function() ***REMOVED***
      var ref3;
      return !(this.isUnary() && ((ref3 = this.operator) === '+' || ref3 === '-') && this.first instanceof Value && this.first.isSimpleNumber());
***REMOVED***;

    Op.prototype.isChainable = function() ***REMOVED***
      var ref3;
      return (ref3 = this.operator) === '<' || ref3 === '>' || ref3 === '>=' || ref3 === '<=' || ref3 === '===' || ref3 === '!==';
***REMOVED***;

    Op.prototype.invert = function() ***REMOVED***
      var allInvertable, curr, fst, op, ref3;
      if (this.isChainable() && this.first.isChainable()) ***REMOVED***
        allInvertable = true;
        curr = this;
        while (curr && curr.operator) ***REMOVED***
          allInvertable && (allInvertable = curr.operator in INVERSIONS);
          curr = curr.first;
***REMOVED***
        if (!allInvertable) ***REMOVED***
          return new Parens(this).invert();
***REMOVED***
        curr = this;
        while (curr && curr.operator) ***REMOVED***
          curr.invert = !curr.invert;
          curr.operator = INVERSIONS[curr.operator];
          curr = curr.first;
***REMOVED***
        return this;
  ***REMOVED*** else if (op = INVERSIONS[this.operator]) ***REMOVED***
        this.operator = op;
        if (this.first.unwrap() instanceof Op) ***REMOVED***
          this.first.invert();
***REMOVED***
        return this;
  ***REMOVED*** else if (this.second) ***REMOVED***
        return new Parens(this).invert();
  ***REMOVED*** else if (this.operator === '!' && (fst = this.first.unwrap()) instanceof Op && ((ref3 = fst.operator) === '!' || ref3 === 'in' || ref3 === 'instanceof')) ***REMOVED***
        return fst;
  ***REMOVED*** else ***REMOVED***
        return new Op('!', this);
  ***REMOVED***
***REMOVED***;

    Op.prototype.unfoldSoak = function(o) ***REMOVED***
      var ref3;
      return ((ref3 = this.operator) === '++' || ref3 === '--' || ref3 === 'delete') && unfoldSoak(o, this, 'first');
***REMOVED***;

    Op.prototype.generateDo = function(exp) ***REMOVED***
      var call, func, j, len1, param, passedParams, ref, ref3;
      passedParams = [];
      func = exp instanceof Assign && (ref = exp.value.unwrap()) instanceof Code ? ref : exp;
      ref3 = func.params || [];
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        param = ref3[j];
        if (param.value) ***REMOVED***
          passedParams.push(param.value);
          delete param.value;
***REMOVED*** else ***REMOVED***
          passedParams.push(param);
***REMOVED***
  ***REMOVED***
      call = new Call(exp, passedParams);
      call["do"] = true;
      return call;
***REMOVED***;

    Op.prototype.compileNode = function(o) ***REMOVED***
      var answer, isChain, lhs, ref3, ref4, rhs;
      isChain = this.isChainable() && this.first.isChainable();
      if (!isChain) ***REMOVED***
        this.first.front = this.front;
  ***REMOVED***
      if (this.operator === 'delete' && o.scope.check(this.first.unwrapAll().value)) ***REMOVED***
        this.error('delete operand may not be argument or var');
  ***REMOVED***
      if (((ref3 = this.operator) === '--' || ref3 === '++') && (ref4 = this.first.unwrapAll().value, indexOf.call(STRICT_PROSCRIBED, ref4) >= 0)) ***REMOVED***
        this.error("cannot increment/decrement \"" + (this.first.unwrapAll().value) + "\"");
  ***REMOVED***
      if (this.isYield()) ***REMOVED***
        return this.compileYield(o);
  ***REMOVED***
      if (this.isUnary()) ***REMOVED***
        return this.compileUnary(o);
  ***REMOVED***
      if (isChain) ***REMOVED***
        return this.compileChain(o);
  ***REMOVED***
      switch (this.operator) ***REMOVED***
        case '?':
          return this.compileExistence(o);
        case '**':
          return this.compilePower(o);
        case '//':
          return this.compileFloorDivision(o);
        case '%%':
          return this.compileModulo(o);
        default:
          lhs = this.first.compileToFragments(o, LEVEL_OP);
          rhs = this.second.compileToFragments(o, LEVEL_OP);
          answer = [].concat(lhs, this.makeCode(" " + this.operator + " "), rhs);
          if (o.level <= LEVEL_OP) ***REMOVED***
            return answer;
  ***REMOVED*** else ***REMOVED***
            return this.wrapInBraces(answer);
  ***REMOVED***
  ***REMOVED***
***REMOVED***;

    Op.prototype.compileChain = function(o) ***REMOVED***
      var fragments, fst, ref3, shared;
      ref3 = this.first.second.cache(o), this.first.second = ref3[0], shared = ref3[1];
      fst = this.first.compileToFragments(o, LEVEL_OP);
      fragments = fst.concat(this.makeCode(" " + (this.invert ? '&&' : '||') + " "), shared.compileToFragments(o), this.makeCode(" " + this.operator + " "), this.second.compileToFragments(o, LEVEL_OP));
      return this.wrapInBraces(fragments);
***REMOVED***;

    Op.prototype.compileExistence = function(o) ***REMOVED***
      var fst, ref;
      if (this.first.isComplex()) ***REMOVED***
        ref = new Literal(o.scope.freeVariable('ref'));
        fst = new Parens(new Assign(ref, this.first));
  ***REMOVED*** else ***REMOVED***
        fst = this.first;
        ref = fst;
  ***REMOVED***
      return new If(new Existence(fst), ref, ***REMOVED***
        type: 'if'
  ***REMOVED***).addElse(this.second).compileToFragments(o);
***REMOVED***;

    Op.prototype.compileUnary = function(o) ***REMOVED***
      var op, parts, plusMinus;
      parts = [];
      op = this.operator;
      parts.push([this.makeCode(op)]);
      if (op === '!' && this.first instanceof Existence) ***REMOVED***
        this.first.negated = !this.first.negated;
        return this.first.compileToFragments(o);
  ***REMOVED***
      if (o.level >= LEVEL_ACCESS) ***REMOVED***
        return (new Parens(this)).compileToFragments(o);
  ***REMOVED***
      plusMinus = op === '+' || op === '-';
      if ((op === 'new' || op === 'typeof' || op === 'delete') || plusMinus && this.first instanceof Op && this.first.operator === op) ***REMOVED***
        parts.push([this.makeCode(' ')]);
  ***REMOVED***
      if ((plusMinus && this.first instanceof Op) || (op === 'new' && this.first.isStatement(o))) ***REMOVED***
        this.first = new Parens(this.first);
  ***REMOVED***
      parts.push(this.first.compileToFragments(o, LEVEL_OP));
      if (this.flip) ***REMOVED***
        parts.reverse();
  ***REMOVED***
      return this.joinFragmentArrays(parts, '');
***REMOVED***;

    Op.prototype.compileYield = function(o) ***REMOVED***
      var op, parts;
      parts = [];
      op = this.operator;
      if (o.scope.parent == null) ***REMOVED***
        this.error('yield statements must occur within a function generator.');
  ***REMOVED***
      if (indexOf.call(Object.keys(this.first), 'expression') >= 0 && !(this.first instanceof Throw)) ***REMOVED***
        if (this.isYieldReturn()) ***REMOVED***
          parts.push(this.first.compileToFragments(o, LEVEL_TOP));
***REMOVED*** else if (this.first.expression != null) ***REMOVED***
          parts.push(this.first.expression.compileToFragments(o, LEVEL_OP));
***REMOVED***
  ***REMOVED*** else ***REMOVED***
        parts.push([this.makeCode("(" + op + " ")]);
        parts.push(this.first.compileToFragments(o, LEVEL_OP));
        parts.push([this.makeCode(")")]);
  ***REMOVED***
      return this.joinFragmentArrays(parts, '');
***REMOVED***;

    Op.prototype.compilePower = function(o) ***REMOVED***
      var pow;
      pow = new Value(new Literal('Math'), [new Access(new Literal('pow'))]);
      return new Call(pow, [this.first, this.second]).compileToFragments(o);
***REMOVED***;

    Op.prototype.compileFloorDivision = function(o) ***REMOVED***
      var div, floor;
      floor = new Value(new Literal('Math'), [new Access(new Literal('floor'))]);
      div = new Op('/', this.first, this.second);
      return new Call(floor, [div]).compileToFragments(o);
***REMOVED***;

    Op.prototype.compileModulo = function(o) ***REMOVED***
      var mod;
      mod = new Value(new Literal(utility('modulo', o)));
      return new Call(mod, [this.first, this.second]).compileToFragments(o);
***REMOVED***;

    Op.prototype.toString = function(idt) ***REMOVED***
      return Op.__super__.toString.call(this, idt, this.constructor.name + ' ' + this.operator);
***REMOVED***;

    return Op;

  ***REMOVED***)(Base);

  exports.In = In = (function(superClass1) ***REMOVED***
    extend1(In, superClass1);

    function In(object, array) ***REMOVED***
      this.object = object;
      this.array = array;
***REMOVED***

    In.prototype.children = ['object', 'array'];

    In.prototype.invert = NEGATE;

    In.prototype.compileNode = function(o) ***REMOVED***
      var hasSplat, j, len1, obj, ref3;
      if (this.array instanceof Value && this.array.isArray() && this.array.base.objects.length) ***REMOVED***
        ref3 = this.array.base.objects;
        for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
          obj = ref3[j];
          if (!(obj instanceof Splat)) ***REMOVED***
            continue;
  ***REMOVED***
          hasSplat = true;
          break;
***REMOVED***
        if (!hasSplat) ***REMOVED***
          return this.compileOrTest(o);
***REMOVED***
  ***REMOVED***
      return this.compileLoopTest(o);
***REMOVED***;

    In.prototype.compileOrTest = function(o) ***REMOVED***
      var cmp, cnj, i, item, j, len1, ref, ref3, ref4, ref5, sub, tests;
      ref3 = this.object.cache(o, LEVEL_OP), sub = ref3[0], ref = ref3[1];
      ref4 = this.negated ? [' !== ', ' && '] : [' === ', ' || '], cmp = ref4[0], cnj = ref4[1];
      tests = [];
      ref5 = this.array.base.objects;
      for (i = j = 0, len1 = ref5.length; j < len1; i = ++j) ***REMOVED***
        item = ref5[i];
        if (i) ***REMOVED***
          tests.push(this.makeCode(cnj));
***REMOVED***
        tests = tests.concat((i ? ref : sub), this.makeCode(cmp), item.compileToFragments(o, LEVEL_ACCESS));
  ***REMOVED***
      if (o.level < LEVEL_OP) ***REMOVED***
        return tests;
  ***REMOVED*** else ***REMOVED***
        return this.wrapInBraces(tests);
  ***REMOVED***
***REMOVED***;

    In.prototype.compileLoopTest = function(o) ***REMOVED***
      var fragments, ref, ref3, sub;
      ref3 = this.object.cache(o, LEVEL_LIST), sub = ref3[0], ref = ref3[1];
      fragments = [].concat(this.makeCode(utility('indexOf', o) + ".call("), this.array.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), ref, this.makeCode(") " + (this.negated ? '< 0' : '>= 0')));
      if (fragmentsToText(sub) === fragmentsToText(ref)) ***REMOVED***
        return fragments;
  ***REMOVED***
      fragments = sub.concat(this.makeCode(', '), fragments);
      if (o.level < LEVEL_LIST) ***REMOVED***
        return fragments;
  ***REMOVED*** else ***REMOVED***
        return this.wrapInBraces(fragments);
  ***REMOVED***
***REMOVED***;

    In.prototype.toString = function(idt) ***REMOVED***
      return In.__super__.toString.call(this, idt, this.constructor.name + (this.negated ? '!' : ''));
***REMOVED***;

    return In;

  ***REMOVED***)(Base);

  exports.Try = Try = (function(superClass1) ***REMOVED***
    extend1(Try, superClass1);

    function Try(attempt, errorVariable, recovery, ensure) ***REMOVED***
      this.attempt = attempt;
      this.errorVariable = errorVariable;
      this.recovery = recovery;
      this.ensure = ensure;
***REMOVED***

    Try.prototype.children = ['attempt', 'recovery', 'ensure'];

    Try.prototype.isStatement = YES;

    Try.prototype.jumps = function(o) ***REMOVED***
      var ref3;
      return this.attempt.jumps(o) || ((ref3 = this.recovery) != null ? ref3.jumps(o) : void 0);
***REMOVED***;

    Try.prototype.makeReturn = function(res) ***REMOVED***
      if (this.attempt) ***REMOVED***
        this.attempt = this.attempt.makeReturn(res);
  ***REMOVED***
      if (this.recovery) ***REMOVED***
        this.recovery = this.recovery.makeReturn(res);
  ***REMOVED***
      return this;
***REMOVED***;

    Try.prototype.compileNode = function(o) ***REMOVED***
      var catchPart, ensurePart, generatedErrorVariableName, placeholder, tryPart;
      o.indent += TAB;
      tryPart = this.attempt.compileToFragments(o, LEVEL_TOP);
      catchPart = this.recovery ? (generatedErrorVariableName = o.scope.freeVariable('error'), placeholder = new Literal(generatedErrorVariableName), this.errorVariable ? this.recovery.unshift(new Assign(this.errorVariable, placeholder)) : void 0, [].concat(this.makeCode(" catch ("), placeholder.compileToFragments(o), this.makeCode(") ***REMOVED***\n"), this.recovery.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "***REMOVED***"))) : !(this.ensure || this.recovery) ? [this.makeCode(" catch (" + generatedErrorVariableName + ") ***REMOVED******REMOVED***")] : [];
      ensurePart = this.ensure ? [].concat(this.makeCode(" finally ***REMOVED***\n"), this.ensure.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "***REMOVED***")) : [];
      return [].concat(this.makeCode(this.tab + "try ***REMOVED***\n"), tryPart, this.makeCode("\n" + this.tab + "***REMOVED***"), catchPart, ensurePart);
***REMOVED***;

    return Try;

  ***REMOVED***)(Base);

  exports.Throw = Throw = (function(superClass1) ***REMOVED***
    extend1(Throw, superClass1);

    function Throw(expression) ***REMOVED***
      this.expression = expression;
***REMOVED***

    Throw.prototype.children = ['expression'];

    Throw.prototype.isStatement = YES;

    Throw.prototype.jumps = NO;

    Throw.prototype.makeReturn = THIS;

    Throw.prototype.compileNode = function(o) ***REMOVED***
      return [].concat(this.makeCode(this.tab + "throw "), this.expression.compileToFragments(o), this.makeCode(";"));
***REMOVED***;

    return Throw;

  ***REMOVED***)(Base);

  exports.Existence = Existence = (function(superClass1) ***REMOVED***
    extend1(Existence, superClass1);

    function Existence(expression) ***REMOVED***
      this.expression = expression;
***REMOVED***

    Existence.prototype.children = ['expression'];

    Existence.prototype.invert = NEGATE;

    Existence.prototype.compileNode = function(o) ***REMOVED***
      var cmp, cnj, code, ref3;
      this.expression.front = this.front;
      code = this.expression.compile(o, LEVEL_OP);
      if (IDENTIFIER.test(code) && !o.scope.check(code)) ***REMOVED***
        ref3 = this.negated ? ['===', '||'] : ['!==', '&&'], cmp = ref3[0], cnj = ref3[1];
        code = "typeof " + code + " " + cmp + " \"undefined\" " + cnj + " " + code + " " + cmp + " null";
  ***REMOVED*** else ***REMOVED***
        code = code + " " + (this.negated ? '==' : '!=') + " null";
  ***REMOVED***
      return [this.makeCode(o.level <= LEVEL_COND ? code : "(" + code + ")")];
***REMOVED***;

    return Existence;

  ***REMOVED***)(Base);

  exports.Parens = Parens = (function(superClass1) ***REMOVED***
    extend1(Parens, superClass1);

    function Parens(body1) ***REMOVED***
      this.body = body1;
***REMOVED***

    Parens.prototype.children = ['body'];

    Parens.prototype.unwrap = function() ***REMOVED***
      return this.body;
***REMOVED***;

    Parens.prototype.isComplex = function() ***REMOVED***
      return this.body.isComplex();
***REMOVED***;

    Parens.prototype.compileNode = function(o) ***REMOVED***
      var bare, expr, fragments;
      expr = this.body.unwrap();
      if (expr instanceof Value && expr.isAtomic()) ***REMOVED***
        expr.front = this.front;
        return expr.compileToFragments(o);
  ***REMOVED***
      fragments = expr.compileToFragments(o, LEVEL_PAREN);
      bare = o.level < LEVEL_OP && (expr instanceof Op || expr instanceof Call || (expr instanceof For && expr.returns));
      if (bare) ***REMOVED***
        return fragments;
  ***REMOVED*** else ***REMOVED***
        return this.wrapInBraces(fragments);
  ***REMOVED***
***REMOVED***;

    return Parens;

  ***REMOVED***)(Base);

  exports.For = For = (function(superClass1) ***REMOVED***
    extend1(For, superClass1);

    function For(body, source) ***REMOVED***
      var ref3;
      this.source = source.source, this.guard = source.guard, this.step = source.step, this.name = source.name, this.index = source.index;
      this.body = Block.wrap([body]);
      this.own = !!source.own;
      this.object = !!source.object;
      if (this.object) ***REMOVED***
        ref3 = [this.index, this.name], this.name = ref3[0], this.index = ref3[1];
  ***REMOVED***
      if (this.index instanceof Value) ***REMOVED***
        this.index.error('index cannot be a pattern matching expression');
  ***REMOVED***
      this.range = this.source instanceof Value && this.source.base instanceof Range && !this.source.properties.length;
      this.pattern = this.name instanceof Value;
      if (this.range && this.index) ***REMOVED***
        this.index.error('indexes do not apply to range loops');
  ***REMOVED***
      if (this.range && this.pattern) ***REMOVED***
        this.name.error('cannot pattern match over range loops');
  ***REMOVED***
      if (this.own && !this.object) ***REMOVED***
        this.name.error('cannot use own with for-in');
  ***REMOVED***
      this.returns = false;
***REMOVED***

    For.prototype.children = ['body', 'source', 'guard', 'step'];

    For.prototype.compileNode = function(o) ***REMOVED***
      var body, bodyFragments, compare, compareDown, declare, declareDown, defPart, defPartFragments, down, forPartFragments, guardPart, idt1, increment, index, ivar, kvar, kvarAssign, last, lvar, name, namePart, ref, ref3, ref4, resultPart, returnResult, rvar, scope, source, step, stepNum, stepVar, svar, varPart;
      body = Block.wrap([this.body]);
      ref3 = body.expressions, last = ref3[ref3.length - 1];
      if ((last != null ? last.jumps() : void 0) instanceof Return) ***REMOVED***
        this.returns = false;
  ***REMOVED***
      source = this.range ? this.source.base : this.source;
      scope = o.scope;
      if (!this.pattern) ***REMOVED***
        name = this.name && (this.name.compile(o, LEVEL_LIST));
  ***REMOVED***
      index = this.index && (this.index.compile(o, LEVEL_LIST));
      if (name && !this.pattern) ***REMOVED***
        scope.find(name);
  ***REMOVED***
      if (index) ***REMOVED***
        scope.find(index);
  ***REMOVED***
      if (this.returns) ***REMOVED***
        rvar = scope.freeVariable('results');
  ***REMOVED***
      ivar = (this.object && index) || scope.freeVariable('i', ***REMOVED***
        single: true
  ***REMOVED***);
      kvar = (this.range && name) || index || ivar;
      kvarAssign = kvar !== ivar ? kvar + " = " : "";
      if (this.step && !this.range) ***REMOVED***
        ref4 = this.cacheToCodeFragments(this.step.cache(o, LEVEL_LIST, isComplexOrAssignable)), step = ref4[0], stepVar = ref4[1];
        stepNum = stepVar.match(NUMBER);
  ***REMOVED***
      if (this.pattern) ***REMOVED***
        name = ivar;
  ***REMOVED***
      varPart = '';
      guardPart = '';
      defPart = '';
      idt1 = this.tab + TAB;
      if (this.range) ***REMOVED***
        forPartFragments = source.compileToFragments(merge(o, ***REMOVED***
          index: ivar,
          name: name,
          step: this.step,
          isComplex: isComplexOrAssignable
***REMOVED***));
  ***REMOVED*** else ***REMOVED***
        svar = this.source.compile(o, LEVEL_LIST);
        if ((name || this.own) && !IDENTIFIER.test(svar)) ***REMOVED***
          defPart += "" + this.tab + (ref = scope.freeVariable('ref')) + " = " + svar + ";\n";
          svar = ref;
***REMOVED***
        if (name && !this.pattern) ***REMOVED***
          namePart = name + " = " + svar + "[" + kvar + "]";
***REMOVED***
        if (!this.object) ***REMOVED***
          if (step !== stepVar) ***REMOVED***
            defPart += "" + this.tab + step + ";\n";
  ***REMOVED***
          if (!(this.step && stepNum && (down = parseNum(stepNum[0]) < 0))) ***REMOVED***
            lvar = scope.freeVariable('len');
  ***REMOVED***
          declare = "" + kvarAssign + ivar + " = 0, " + lvar + " = " + svar + ".length";
          declareDown = "" + kvarAssign + ivar + " = " + svar + ".length - 1";
          compare = ivar + " < " + lvar;
          compareDown = ivar + " >= 0";
          if (this.step) ***REMOVED***
            if (stepNum) ***REMOVED***
              if (down) ***REMOVED***
                compare = compareDown;
                declare = declareDown;
  ***REMOVED***
***REMOVED*** else ***REMOVED***
              compare = stepVar + " > 0 ? " + compare + " : " + compareDown;
              declare = "(" + stepVar + " > 0 ? (" + declare + ") : " + declareDown + ")";
***REMOVED***
            increment = ivar + " += " + stepVar;
  ***REMOVED*** else ***REMOVED***
            increment = "" + (kvar !== ivar ? "++" + ivar : ivar + "++");
  ***REMOVED***
          forPartFragments = [this.makeCode(declare + "; " + compare + "; " + kvarAssign + increment)];
***REMOVED***
  ***REMOVED***
      if (this.returns) ***REMOVED***
        resultPart = "" + this.tab + rvar + " = [];\n";
        returnResult = "\n" + this.tab + "return " + rvar + ";";
        body.makeReturn(rvar);
  ***REMOVED***
      if (this.guard) ***REMOVED***
        if (body.expressions.length > 1) ***REMOVED***
          body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Literal("continue")));
***REMOVED*** else ***REMOVED***
          if (this.guard) ***REMOVED***
            body = Block.wrap([new If(this.guard, body)]);
  ***REMOVED***
***REMOVED***
  ***REMOVED***
      if (this.pattern) ***REMOVED***
        body.expressions.unshift(new Assign(this.name, new Literal(svar + "[" + kvar + "]")));
  ***REMOVED***
      defPartFragments = [].concat(this.makeCode(defPart), this.pluckDirectCall(o, body));
      if (namePart) ***REMOVED***
        varPart = "\n" + idt1 + namePart + ";";
  ***REMOVED***
      if (this.object) ***REMOVED***
        forPartFragments = [this.makeCode(kvar + " in " + svar)];
        if (this.own) ***REMOVED***
          guardPart = "\n" + idt1 + "if (!" + (utility('hasProp', o)) + ".call(" + svar + ", " + kvar + ")) continue;";
***REMOVED***
  ***REMOVED***
      bodyFragments = body.compileToFragments(merge(o, ***REMOVED***
        indent: idt1
  ***REMOVED***), LEVEL_TOP);
      if (bodyFragments && (bodyFragments.length > 0)) ***REMOVED***
        bodyFragments = [].concat(this.makeCode("\n"), bodyFragments, this.makeCode("\n"));
  ***REMOVED***
      return [].concat(defPartFragments, this.makeCode("" + (resultPart || '') + this.tab + "for ("), forPartFragments, this.makeCode(") ***REMOVED***" + guardPart + varPart), bodyFragments, this.makeCode(this.tab + "***REMOVED***" + (returnResult || '')));
***REMOVED***;

    For.prototype.pluckDirectCall = function(o, body) ***REMOVED***
      var base, defs, expr, fn, idx, j, len1, ref, ref3, ref4, ref5, ref6, ref7, ref8, ref9, val;
      defs = [];
      ref3 = body.expressions;
      for (idx = j = 0, len1 = ref3.length; j < len1; idx = ++j) ***REMOVED***
        expr = ref3[idx];
        expr = expr.unwrapAll();
        if (!(expr instanceof Call)) ***REMOVED***
          continue;
***REMOVED***
        val = (ref4 = expr.variable) != null ? ref4.unwrapAll() : void 0;
        if (!((val instanceof Code) || (val instanceof Value && ((ref5 = val.base) != null ? ref5.unwrapAll() : void 0) instanceof Code && val.properties.length === 1 && ((ref6 = (ref7 = val.properties[0].name) != null ? ref7.value : void 0) === 'call' || ref6 === 'apply')))) ***REMOVED***
          continue;
***REMOVED***
        fn = ((ref8 = val.base) != null ? ref8.unwrapAll() : void 0) || val;
        ref = new Literal(o.scope.freeVariable('fn'));
        base = new Value(ref);
        if (val.base) ***REMOVED***
          ref9 = [base, val], val.base = ref9[0], base = ref9[1];
***REMOVED***
        body.expressions[idx] = new Call(base, expr.args);
        defs = defs.concat(this.makeCode(this.tab), new Assign(ref, fn).compileToFragments(o, LEVEL_TOP), this.makeCode(';\n'));
  ***REMOVED***
      return defs;
***REMOVED***;

    return For;

  ***REMOVED***)(While);

  exports.Switch = Switch = (function(superClass1) ***REMOVED***
    extend1(Switch, superClass1);

    function Switch(subject, cases, otherwise) ***REMOVED***
      this.subject = subject;
      this.cases = cases;
      this.otherwise = otherwise;
***REMOVED***

    Switch.prototype.children = ['subject', 'cases', 'otherwise'];

    Switch.prototype.isStatement = YES;

    Switch.prototype.jumps = function(o) ***REMOVED***
      var block, conds, j, jumpNode, len1, ref3, ref4, ref5;
      if (o == null) ***REMOVED***
        o = ***REMOVED***
          block: true
***REMOVED***;
  ***REMOVED***
      ref3 = this.cases;
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        ref4 = ref3[j], conds = ref4[0], block = ref4[1];
        if (jumpNode = block.jumps(o)) ***REMOVED***
          return jumpNode;
***REMOVED***
  ***REMOVED***
      return (ref5 = this.otherwise) != null ? ref5.jumps(o) : void 0;
***REMOVED***;

    Switch.prototype.makeReturn = function(res) ***REMOVED***
      var j, len1, pair, ref3, ref4;
      ref3 = this.cases;
      for (j = 0, len1 = ref3.length; j < len1; j++) ***REMOVED***
        pair = ref3[j];
        pair[1].makeReturn(res);
  ***REMOVED***
      if (res) ***REMOVED***
        this.otherwise || (this.otherwise = new Block([new Literal('void 0')]));
  ***REMOVED***
      if ((ref4 = this.otherwise) != null) ***REMOVED***
        ref4.makeReturn(res);
  ***REMOVED***
      return this;
***REMOVED***;

    Switch.prototype.compileNode = function(o) ***REMOVED***
      var block, body, cond, conditions, expr, fragments, i, idt1, idt2, j, k, len1, len2, ref3, ref4, ref5;
      idt1 = o.indent + TAB;
      idt2 = o.indent = idt1 + TAB;
      fragments = [].concat(this.makeCode(this.tab + "switch ("), (this.subject ? this.subject.compileToFragments(o, LEVEL_PAREN) : this.makeCode("false")), this.makeCode(") ***REMOVED***\n"));
      ref3 = this.cases;
      for (i = j = 0, len1 = ref3.length; j < len1; i = ++j) ***REMOVED***
        ref4 = ref3[i], conditions = ref4[0], block = ref4[1];
        ref5 = flatten([conditions]);
        for (k = 0, len2 = ref5.length; k < len2; k++) ***REMOVED***
          cond = ref5[k];
          if (!this.subject) ***REMOVED***
            cond = cond.invert();
  ***REMOVED***
          fragments = fragments.concat(this.makeCode(idt1 + "case "), cond.compileToFragments(o, LEVEL_PAREN), this.makeCode(":\n"));
***REMOVED***
        if ((body = block.compileToFragments(o, LEVEL_TOP)).length > 0) ***REMOVED***
          fragments = fragments.concat(body, this.makeCode('\n'));
***REMOVED***
        if (i === this.cases.length - 1 && !this.otherwise) ***REMOVED***
          break;
***REMOVED***
        expr = this.lastNonComment(block.expressions);
        if (expr instanceof Return || (expr instanceof Literal && expr.jumps() && expr.value !== 'debugger')) ***REMOVED***
          continue;
***REMOVED***
        fragments.push(cond.makeCode(idt2 + 'break;\n'));
  ***REMOVED***
      if (this.otherwise && this.otherwise.expressions.length) ***REMOVED***
        fragments.push.apply(fragments, [this.makeCode(idt1 + "default:\n")].concat(slice.call(this.otherwise.compileToFragments(o, LEVEL_TOP)), [this.makeCode("\n")]));
  ***REMOVED***
      fragments.push(this.makeCode(this.tab + '***REMOVED***'));
      return fragments;
***REMOVED***;

    return Switch;

  ***REMOVED***)(Base);

  exports.If = If = (function(superClass1) ***REMOVED***
    extend1(If, superClass1);

    function If(condition, body1, options) ***REMOVED***
      this.body = body1;
      if (options == null) ***REMOVED***
        options = ***REMOVED******REMOVED***;
  ***REMOVED***
      this.condition = options.type === 'unless' ? condition.invert() : condition;
      this.elseBody = null;
      this.isChain = false;
      this.soak = options.soak;
***REMOVED***

    If.prototype.children = ['condition', 'body', 'elseBody'];

    If.prototype.bodyNode = function() ***REMOVED***
      var ref3;
      return (ref3 = this.body) != null ? ref3.unwrap() : void 0;
***REMOVED***;

    If.prototype.elseBodyNode = function() ***REMOVED***
      var ref3;
      return (ref3 = this.elseBody) != null ? ref3.unwrap() : void 0;
***REMOVED***;

    If.prototype.addElse = function(elseBody) ***REMOVED***
      if (this.isChain) ***REMOVED***
        this.elseBodyNode().addElse(elseBody);
  ***REMOVED*** else ***REMOVED***
        this.isChain = elseBody instanceof If;
        this.elseBody = this.ensureBlock(elseBody);
        this.elseBody.updateLocationDataIfMissing(elseBody.locationData);
  ***REMOVED***
      return this;
***REMOVED***;

    If.prototype.isStatement = function(o) ***REMOVED***
      var ref3;
      return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatement(o) || ((ref3 = this.elseBodyNode()) != null ? ref3.isStatement(o) : void 0);
***REMOVED***;

    If.prototype.jumps = function(o) ***REMOVED***
      var ref3;
      return this.body.jumps(o) || ((ref3 = this.elseBody) != null ? ref3.jumps(o) : void 0);
***REMOVED***;

    If.prototype.compileNode = function(o) ***REMOVED***
      if (this.isStatement(o)) ***REMOVED***
        return this.compileStatement(o);
  ***REMOVED*** else ***REMOVED***
        return this.compileExpression(o);
  ***REMOVED***
***REMOVED***;

    If.prototype.makeReturn = function(res) ***REMOVED***
      if (res) ***REMOVED***
        this.elseBody || (this.elseBody = new Block([new Literal('void 0')]));
  ***REMOVED***
      this.body && (this.body = new Block([this.body.makeReturn(res)]));
      this.elseBody && (this.elseBody = new Block([this.elseBody.makeReturn(res)]));
      return this;
***REMOVED***;

    If.prototype.ensureBlock = function(node) ***REMOVED***
      if (node instanceof Block) ***REMOVED***
        return node;
  ***REMOVED*** else ***REMOVED***
        return new Block([node]);
  ***REMOVED***
***REMOVED***;

    If.prototype.compileStatement = function(o) ***REMOVED***
      var answer, body, child, cond, exeq, ifPart, indent;
      child = del(o, 'chainChild');
      exeq = del(o, 'isExistentialEquals');
      if (exeq) ***REMOVED***
        return new If(this.condition.invert(), this.elseBodyNode(), ***REMOVED***
          type: 'if'
***REMOVED***).compileToFragments(o);
  ***REMOVED***
      indent = o.indent + TAB;
      cond = this.condition.compileToFragments(o, LEVEL_PAREN);
      body = this.ensureBlock(this.body).compileToFragments(merge(o, ***REMOVED***
        indent: indent
  ***REMOVED***));
      ifPart = [].concat(this.makeCode("if ("), cond, this.makeCode(") ***REMOVED***\n"), body, this.makeCode("\n" + this.tab + "***REMOVED***"));
      if (!child) ***REMOVED***
        ifPart.unshift(this.makeCode(this.tab));
  ***REMOVED***
      if (!this.elseBody) ***REMOVED***
        return ifPart;
  ***REMOVED***
      answer = ifPart.concat(this.makeCode(' else '));
      if (this.isChain) ***REMOVED***
        o.chainChild = true;
        answer = answer.concat(this.elseBody.unwrap().compileToFragments(o, LEVEL_TOP));
  ***REMOVED*** else ***REMOVED***
        answer = answer.concat(this.makeCode("***REMOVED***\n"), this.elseBody.compileToFragments(merge(o, ***REMOVED***
          indent: indent
***REMOVED***), LEVEL_TOP), this.makeCode("\n" + this.tab + "***REMOVED***"));
  ***REMOVED***
      return answer;
***REMOVED***;

    If.prototype.compileExpression = function(o) ***REMOVED***
      var alt, body, cond, fragments;
      cond = this.condition.compileToFragments(o, LEVEL_COND);
      body = this.bodyNode().compileToFragments(o, LEVEL_LIST);
      alt = this.elseBodyNode() ? this.elseBodyNode().compileToFragments(o, LEVEL_LIST) : [this.makeCode('void 0')];
      fragments = cond.concat(this.makeCode(" ? "), body, this.makeCode(" : "), alt);
      if (o.level >= LEVEL_COND) ***REMOVED***
        return this.wrapInBraces(fragments);
  ***REMOVED*** else ***REMOVED***
        return fragments;
  ***REMOVED***
***REMOVED***;

    If.prototype.unfoldSoak = function() ***REMOVED***
      return this.soak && this;
***REMOVED***;

    return If;

  ***REMOVED***)(Base);

  UTILITIES = ***REMOVED***
    extend: function(o) ***REMOVED***
      return "function(child, parent) ***REMOVED*** for (var key in parent) ***REMOVED*** if (" + (utility('hasProp', o)) + ".call(parent, key)) child[key] = parent[key]; ***REMOVED*** function ctor() ***REMOVED*** this.constructor = child; ***REMOVED*** ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; ***REMOVED***";
***REMOVED***,
    bind: function() ***REMOVED***
      return 'function(fn, me)***REMOVED*** return function()***REMOVED*** return fn.apply(me, arguments); ***REMOVED***; ***REMOVED***';
***REMOVED***,
    indexOf: function() ***REMOVED***
      return "[].indexOf || function(item) ***REMOVED*** for (var i = 0, l = this.length; i < l; i++) ***REMOVED*** if (i in this && this[i] === item) return i; ***REMOVED*** return -1; ***REMOVED***";
***REMOVED***,
    modulo: function() ***REMOVED***
      return "function(a, b) ***REMOVED*** return (+a % (b = +b) + b) % b; ***REMOVED***";
***REMOVED***,
    hasProp: function() ***REMOVED***
      return '***REMOVED******REMOVED***.hasOwnProperty';
***REMOVED***,
    slice: function() ***REMOVED***
      return '[].slice';
***REMOVED***
  ***REMOVED***;

  LEVEL_TOP = 1;

  LEVEL_PAREN = 2;

  LEVEL_LIST = 3;

  LEVEL_COND = 4;

  LEVEL_OP = 5;

  LEVEL_ACCESS = 6;

  TAB = '  ';

  IDENTIFIER = /^(?!\d)[$\w\x7f-\uffff]+$/;

  SIMPLENUM = /^[+-]?\d+$/;

  HEXNUM = /^[+-]?0x[\da-f]+/i;

  NUMBER = /^[+-]?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)$/i;

  IS_STRING = /^['"]/;

  IS_REGEX = /^\//;

  utility = function(name, o) ***REMOVED***
    var ref, root;
    root = o.scope.root;
    if (name in root.utilities) ***REMOVED***
      return root.utilities[name];
***REMOVED*** else ***REMOVED***
      ref = root.freeVariable(name);
      root.assign(ref, UTILITIES[name](o));
      return root.utilities[name] = ref;
***REMOVED***
  ***REMOVED***;

  multident = function(code, tab) ***REMOVED***
    code = code.replace(/\n/g, '$&' + tab);
    return code.replace(/\s+$/, '');
  ***REMOVED***;

  parseNum = function(x) ***REMOVED***
    if (x == null) ***REMOVED***
      return 0;
***REMOVED*** else if (x.match(HEXNUM)) ***REMOVED***
      return parseInt(x, 16);
***REMOVED*** else ***REMOVED***
      return parseFloat(x);
***REMOVED***
  ***REMOVED***;

  isLiteralArguments = function(node) ***REMOVED***
    return node instanceof Literal && node.value === 'arguments' && !node.asKey;
  ***REMOVED***;

  isLiteralThis = function(node) ***REMOVED***
    return (node instanceof Literal && node.value === 'this' && !node.asKey) || (node instanceof Code && node.bound) || (node instanceof Call && node.isSuper);
  ***REMOVED***;

  isComplexOrAssignable = function(node) ***REMOVED***
    return node.isComplex() || (typeof node.isAssignable === "function" ? node.isAssignable() : void 0);
  ***REMOVED***;

  unfoldSoak = function(o, parent, name) ***REMOVED***
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) ***REMOVED***
      return;
***REMOVED***
    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  ***REMOVED***;

***REMOVED***).call(this);
