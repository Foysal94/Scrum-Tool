// Generated by CoffeeScript 1.10.0
(function() ***REMOVED***
  var BALANCED_PAIRS, CALL_CLOSERS, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, SINGLE_CLOSERS, SINGLE_LINERS, generate, k, left, len, ref, rite,
    indexOf = [].indexOf || function(item) ***REMOVED*** for (var i = 0, l = this.length; i < l; i++) ***REMOVED*** if (i in this && this[i] === item) return i; ***REMOVED*** return -1; ***REMOVED***,
    slice = [].slice;

  generate = function(tag, value, origin) ***REMOVED***
    var tok;
    tok = [tag, value];
    tok.generated = true;
    if (origin) ***REMOVED***
      tok.origin = origin;
***REMOVED***
    return tok;
  ***REMOVED***;

  exports.Rewriter = (function() ***REMOVED***
    function Rewriter() ***REMOVED******REMOVED***

    Rewriter.prototype.rewrite = function(tokens1) ***REMOVED***
      this.tokens = tokens1;
      this.removeLeadingNewlines();
      this.closeOpenCalls();
      this.closeOpenIndexes();
      this.normalizeLines();
      this.tagPostfixConditionals();
      this.addImplicitBracesAndParens();
      this.addLocationDataToGeneratedTokens();
      return this.tokens;
***REMOVED***;

    Rewriter.prototype.scanTokens = function(block) ***REMOVED***
      var i, token, tokens;
      tokens = this.tokens;
      i = 0;
      while (token = tokens[i]) ***REMOVED***
        i += block.call(this, token, i, tokens);
  ***REMOVED***
      return true;
***REMOVED***;

    Rewriter.prototype.detectEnd = function(i, condition, action) ***REMOVED***
      var levels, ref, ref1, token, tokens;
      tokens = this.tokens;
      levels = 0;
      while (token = tokens[i]) ***REMOVED***
        if (levels === 0 && condition.call(this, token, i)) ***REMOVED***
          return action.call(this, token, i);
***REMOVED***
        if (!token || levels < 0) ***REMOVED***
          return action.call(this, token, i - 1);
***REMOVED***
        if (ref = token[0], indexOf.call(EXPRESSION_START, ref) >= 0) ***REMOVED***
          levels += 1;
***REMOVED*** else if (ref1 = token[0], indexOf.call(EXPRESSION_END, ref1) >= 0) ***REMOVED***
          levels -= 1;
***REMOVED***
        i += 1;
  ***REMOVED***
      return i - 1;
***REMOVED***;

    Rewriter.prototype.removeLeadingNewlines = function() ***REMOVED***
      var i, k, len, ref, tag;
      ref = this.tokens;
      for (i = k = 0, len = ref.length; k < len; i = ++k) ***REMOVED***
        tag = ref[i][0];
        if (tag !== 'TERMINATOR') ***REMOVED***
          break;
***REMOVED***
  ***REMOVED***
      if (i) ***REMOVED***
        return this.tokens.splice(0, i);
  ***REMOVED***
***REMOVED***;

    Rewriter.prototype.closeOpenCalls = function() ***REMOVED***
      var action, condition;
      condition = function(token, i) ***REMOVED***
        var ref;
        return ((ref = token[0]) === ')' || ref === 'CALL_END') || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';
  ***REMOVED***;
      action = function(token, i) ***REMOVED***
        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';
  ***REMOVED***;
      return this.scanTokens(function(token, i) ***REMOVED***
        if (token[0] === 'CALL_START') ***REMOVED***
          this.detectEnd(i + 1, condition, action);
***REMOVED***
        return 1;
  ***REMOVED***);
***REMOVED***;

    Rewriter.prototype.closeOpenIndexes = function() ***REMOVED***
      var action, condition;
      condition = function(token, i) ***REMOVED***
        var ref;
        return (ref = token[0]) === ']' || ref === 'INDEX_END';
  ***REMOVED***;
      action = function(token, i) ***REMOVED***
        return token[0] = 'INDEX_END';
  ***REMOVED***;
      return this.scanTokens(function(token, i) ***REMOVED***
        if (token[0] === 'INDEX_START') ***REMOVED***
          this.detectEnd(i + 1, condition, action);
***REMOVED***
        return 1;
  ***REMOVED***);
***REMOVED***;

    Rewriter.prototype.indexOfTag = function() ***REMOVED***
      var fuzz, i, j, k, pattern, ref, ref1;
      i = arguments[0], pattern = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      fuzz = 0;
      for (j = k = 0, ref = pattern.length; 0 <= ref ? k < ref : k > ref; j = 0 <= ref ? ++k : --k) ***REMOVED***
        while (this.tag(i + j + fuzz) === 'HERECOMMENT') ***REMOVED***
          fuzz += 2;
***REMOVED***
        if (pattern[j] == null) ***REMOVED***
          continue;
***REMOVED***
        if (typeof pattern[j] === 'string') ***REMOVED***
          pattern[j] = [pattern[j]];
***REMOVED***
        if (ref1 = this.tag(i + j + fuzz), indexOf.call(pattern[j], ref1) < 0) ***REMOVED***
          return -1;
***REMOVED***
  ***REMOVED***
      return i + j + fuzz - 1;
***REMOVED***;

    Rewriter.prototype.looksObjectish = function(j) ***REMOVED***
      var end, index;
      if (this.indexOfTag(j, '@', null, ':') > -1 || this.indexOfTag(j, null, ':') > -1) ***REMOVED***
        return true;
  ***REMOVED***
      index = this.indexOfTag(j, EXPRESSION_START);
      if (index > -1) ***REMOVED***
        end = null;
        this.detectEnd(index + 1, (function(token) ***REMOVED***
          var ref;
          return ref = token[0], indexOf.call(EXPRESSION_END, ref) >= 0;
***REMOVED***), (function(token, i) ***REMOVED***
          return end = i;
***REMOVED***));
        if (this.tag(end + 1) === ':') ***REMOVED***
          return true;
***REMOVED***
  ***REMOVED***
      return false;
***REMOVED***;

    Rewriter.prototype.findTagsBackwards = function(i, tags) ***REMOVED***
      var backStack, ref, ref1, ref2, ref3, ref4, ref5;
      backStack = [];
      while (i >= 0 && (backStack.length || (ref2 = this.tag(i), indexOf.call(tags, ref2) < 0) && ((ref3 = this.tag(i), indexOf.call(EXPRESSION_START, ref3) < 0) || this.tokens[i].generated) && (ref4 = this.tag(i), indexOf.call(LINEBREAKS, ref4) < 0))) ***REMOVED***
        if (ref = this.tag(i), indexOf.call(EXPRESSION_END, ref) >= 0) ***REMOVED***
          backStack.push(this.tag(i));
***REMOVED***
        if ((ref1 = this.tag(i), indexOf.call(EXPRESSION_START, ref1) >= 0) && backStack.length) ***REMOVED***
          backStack.pop();
***REMOVED***
        i -= 1;
  ***REMOVED***
      return ref5 = this.tag(i), indexOf.call(tags, ref5) >= 0;
***REMOVED***;

    Rewriter.prototype.addImplicitBracesAndParens = function() ***REMOVED***
      var stack, start;
      stack = [];
      start = null;
      return this.scanTokens(function(token, i, tokens) ***REMOVED***
        var endImplicitCall, endImplicitObject, forward, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, newLine, nextTag, offset, prevTag, prevToken, ref, ref1, ref2, ref3, ref4, ref5, s, sameLine, stackIdx, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startsLine, tag;
        tag = token[0];
        prevTag = (prevToken = i > 0 ? tokens[i - 1] : [])[0];
        nextTag = (i < tokens.length - 1 ? tokens[i + 1] : [])[0];
        stackTop = function() ***REMOVED***
          return stack[stack.length - 1];
***REMOVED***;
        startIdx = i;
        forward = function(n) ***REMOVED***
          return i - startIdx + n;
***REMOVED***;
        inImplicit = function() ***REMOVED***
          var ref, ref1;
          return (ref = stackTop()) != null ? (ref1 = ref[2]) != null ? ref1.ours : void 0 : void 0;
***REMOVED***;
        inImplicitCall = function() ***REMOVED***
          var ref;
          return inImplicit() && ((ref = stackTop()) != null ? ref[0] : void 0) === '(';
***REMOVED***;
        inImplicitObject = function() ***REMOVED***
          var ref;
          return inImplicit() && ((ref = stackTop()) != null ? ref[0] : void 0) === '***REMOVED***';
***REMOVED***;
        inImplicitControl = function() ***REMOVED***
          var ref;
          return inImplicit && ((ref = stackTop()) != null ? ref[0] : void 0) === 'CONTROL';
***REMOVED***;
        startImplicitCall = function(j) ***REMOVED***
          var idx;
          idx = j != null ? j : i;
          stack.push([
            '(', idx, ***REMOVED***
              ours: true
***REMOVED***
          ]);
          tokens.splice(idx, 0, generate('CALL_START', '('));
          if (j == null) ***REMOVED***
            return i += 1;
  ***REMOVED***
***REMOVED***;
        endImplicitCall = function() ***REMOVED***
          stack.pop();
          tokens.splice(i, 0, generate('CALL_END', ')', ['', 'end of input', token[2]]));
          return i += 1;
***REMOVED***;
        startImplicitObject = function(j, startsLine) ***REMOVED***
          var idx, val;
          if (startsLine == null) ***REMOVED***
            startsLine = true;
  ***REMOVED***
          idx = j != null ? j : i;
          stack.push([
            '***REMOVED***', idx, ***REMOVED***
              sameLine: true,
              startsLine: startsLine,
              ours: true
***REMOVED***
          ]);
          val = new String('***REMOVED***');
          val.generated = true;
          tokens.splice(idx, 0, generate('***REMOVED***', val, token));
          if (j == null) ***REMOVED***
            return i += 1;
  ***REMOVED***
***REMOVED***;
        endImplicitObject = function(j) ***REMOVED***
          j = j != null ? j : i;
          stack.pop();
          tokens.splice(j, 0, generate('***REMOVED***', '***REMOVED***', token));
          return i += 1;
***REMOVED***;
        if (inImplicitCall() && (tag === 'IF' || tag === 'TRY' || tag === 'FINALLY' || tag === 'CATCH' || tag === 'CLASS' || tag === 'SWITCH')) ***REMOVED***
          stack.push([
            'CONTROL', i, ***REMOVED***
              ours: true
***REMOVED***
          ]);
          return forward(1);
***REMOVED***
        if (tag === 'INDENT' && inImplicit()) ***REMOVED***
          if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '***REMOVED***' && prevTag !== 'TRY' && prevTag !== 'ELSE' && prevTag !== '=') ***REMOVED***
            while (inImplicitCall()) ***REMOVED***
              endImplicitCall();
***REMOVED***
  ***REMOVED***
          if (inImplicitControl()) ***REMOVED***
            stack.pop();
  ***REMOVED***
          stack.push([tag, i]);
          return forward(1);
***REMOVED***
        if (indexOf.call(EXPRESSION_START, tag) >= 0) ***REMOVED***
          stack.push([tag, i]);
          return forward(1);
***REMOVED***
        if (indexOf.call(EXPRESSION_END, tag) >= 0) ***REMOVED***
          while (inImplicit()) ***REMOVED***
            if (inImplicitCall()) ***REMOVED***
              endImplicitCall();
***REMOVED*** else if (inImplicitObject()) ***REMOVED***
              endImplicitObject();
***REMOVED*** else ***REMOVED***
              stack.pop();
***REMOVED***
  ***REMOVED***
          start = stack.pop();
***REMOVED***
        if ((indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !((ref = tokens[i + 1]) != null ? ref.spaced : void 0) && !((ref1 = tokens[i + 1]) != null ? ref1.newLine : void 0))) ***REMOVED***
          if (tag === '?') ***REMOVED***
            tag = token[0] = 'FUNC_EXIST';
  ***REMOVED***
          startImplicitCall(i + 1);
          return forward(2);
***REMOVED***
        if (indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.indexOfTag(i + 1, 'INDENT') > -1 && this.looksObjectish(i + 2) && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL'])) ***REMOVED***
          startImplicitCall(i + 1);
          stack.push(['INDENT', i + 2]);
          return forward(3);
***REMOVED***
        if (tag === ':') ***REMOVED***
          s = (function() ***REMOVED***
            var ref2;
            switch (false) ***REMOVED***
              case ref2 = this.tag(i - 1), indexOf.call(EXPRESSION_END, ref2) < 0:
                return start[1];
              case this.tag(i - 2) !== '@':
                return i - 2;
              default:
                return i - 1;
***REMOVED***
  ***REMOVED***).call(this);
          while (this.tag(s - 2) === 'HERECOMMENT') ***REMOVED***
            s -= 2;
  ***REMOVED***
          this.insideForDeclaration = nextTag === 'FOR';
          startsLine = s === 0 || (ref2 = this.tag(s - 1), indexOf.call(LINEBREAKS, ref2) >= 0) || tokens[s - 1].newLine;
          if (stackTop()) ***REMOVED***
            ref3 = stackTop(), stackTag = ref3[0], stackIdx = ref3[1];
            if ((stackTag === '***REMOVED***' || stackTag === 'INDENT' && this.tag(stackIdx - 1) === '***REMOVED***') && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '***REMOVED***')) ***REMOVED***
              return forward(1);
***REMOVED***
  ***REMOVED***
          startImplicitObject(s, !!startsLine);
          return forward(2);
***REMOVED***
        if (inImplicitObject() && indexOf.call(LINEBREAKS, tag) >= 0) ***REMOVED***
          stackTop()[2].sameLine = false;
***REMOVED***
        newLine = prevTag === 'OUTDENT' || prevToken.newLine;
        if (indexOf.call(IMPLICIT_END, tag) >= 0 || indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) ***REMOVED***
          while (inImplicit()) ***REMOVED***
            ref4 = stackTop(), stackTag = ref4[0], stackIdx = ref4[1], (ref5 = ref4[2], sameLine = ref5.sameLine, startsLine = ref5.startsLine);
            if (inImplicitCall() && prevTag !== ',') ***REMOVED***
              endImplicitCall();
***REMOVED*** else if (inImplicitObject() && !this.insideForDeclaration && sameLine && tag !== 'TERMINATOR' && prevTag !== ':') ***REMOVED***
              endImplicitObject();
***REMOVED*** else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) ***REMOVED***
              if (nextTag === 'HERECOMMENT') ***REMOVED***
                return forward(1);
  ***REMOVED***
              endImplicitObject();
***REMOVED*** else ***REMOVED***
              break;
***REMOVED***
  ***REMOVED***
***REMOVED***
        if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !this.insideForDeclaration && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) ***REMOVED***
          offset = nextTag === 'OUTDENT' ? 1 : 0;
          while (inImplicitObject()) ***REMOVED***
            endImplicitObject(i + offset);
  ***REMOVED***
***REMOVED***
        return forward(1);
  ***REMOVED***);
***REMOVED***;

    Rewriter.prototype.addLocationDataToGeneratedTokens = function() ***REMOVED***
      return this.scanTokens(function(token, i, tokens) ***REMOVED***
        var column, line, nextLocation, prevLocation, ref, ref1;
        if (token[2]) ***REMOVED***
          return 1;
***REMOVED***
        if (!(token.generated || token.explicit)) ***REMOVED***
          return 1;
***REMOVED***
        if (token[0] === '***REMOVED***' && (nextLocation = (ref = tokens[i + 1]) != null ? ref[2] : void 0)) ***REMOVED***
          line = nextLocation.first_line, column = nextLocation.first_column;
***REMOVED*** else if (prevLocation = (ref1 = tokens[i - 1]) != null ? ref1[2] : void 0) ***REMOVED***
          line = prevLocation.last_line, column = prevLocation.last_column;
***REMOVED*** else ***REMOVED***
          line = column = 0;
***REMOVED***
        token[2] = ***REMOVED***
          first_line: line,
          first_column: column,
          last_line: line,
          last_column: column
***REMOVED***;
        return 1;
  ***REMOVED***);
***REMOVED***;

    Rewriter.prototype.normalizeLines = function() ***REMOVED***
      var action, condition, indent, outdent, starter;
      starter = indent = outdent = null;
      condition = function(token, i) ***REMOVED***
        var ref, ref1, ref2, ref3;
        return token[1] !== ';' && (ref = token[0], indexOf.call(SINGLE_CLOSERS, ref) >= 0) && !(token[0] === 'TERMINATOR' && (ref1 = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref1) >= 0)) && !(token[0] === 'ELSE' && starter !== 'THEN') && !(((ref2 = token[0]) === 'CATCH' || ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (ref3 = token[0], indexOf.call(CALL_CLOSERS, ref3) >= 0) && this.tokens[i - 1].newLine;
  ***REMOVED***;
      action = function(token, i) ***REMOVED***
        return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);
  ***REMOVED***;
      return this.scanTokens(function(token, i, tokens) ***REMOVED***
        var j, k, ref, ref1, ref2, tag;
        tag = token[0];
        if (tag === 'TERMINATOR') ***REMOVED***
          if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') ***REMOVED***
            tokens.splice.apply(tokens, [i, 1].concat(slice.call(this.indentation())));
            return 1;
  ***REMOVED***
          if (ref = this.tag(i + 1), indexOf.call(EXPRESSION_CLOSE, ref) >= 0) ***REMOVED***
            tokens.splice(i, 1);
            return 0;
  ***REMOVED***
***REMOVED***
        if (tag === 'CATCH') ***REMOVED***
          for (j = k = 1; k <= 2; j = ++k) ***REMOVED***
            if (!((ref1 = this.tag(i + j)) === 'OUTDENT' || ref1 === 'TERMINATOR' || ref1 === 'FINALLY')) ***REMOVED***
              continue;
***REMOVED***
            tokens.splice.apply(tokens, [i + j, 0].concat(slice.call(this.indentation())));
            return 2 + j;
  ***REMOVED***
***REMOVED***
        if (indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF')) ***REMOVED***
          starter = tag;
          ref2 = this.indentation(tokens[i]), indent = ref2[0], outdent = ref2[1];
          if (starter === 'THEN') ***REMOVED***
            indent.fromThen = true;
  ***REMOVED***
          tokens.splice(i + 1, 0, indent);
          this.detectEnd(i + 2, condition, action);
          if (tag === 'THEN') ***REMOVED***
            tokens.splice(i, 1);
  ***REMOVED***
          return 1;
***REMOVED***
        return 1;
  ***REMOVED***);
***REMOVED***;

    Rewriter.prototype.tagPostfixConditionals = function() ***REMOVED***
      var action, condition, original;
      original = null;
      condition = function(token, i) ***REMOVED***
        var prevTag, tag;
        tag = token[0];
        prevTag = this.tokens[i - 1][0];
        return tag === 'TERMINATOR' || (tag === 'INDENT' && indexOf.call(SINGLE_LINERS, prevTag) < 0);
  ***REMOVED***;
      action = function(token, i) ***REMOVED***
        if (token[0] !== 'INDENT' || (token.generated && !token.fromThen)) ***REMOVED***
          return original[0] = 'POST_' + original[0];
***REMOVED***
  ***REMOVED***;
      return this.scanTokens(function(token, i) ***REMOVED***
        if (token[0] !== 'IF') ***REMOVED***
          return 1;
***REMOVED***
        original = token;
        this.detectEnd(i + 1, condition, action);
        return 1;
  ***REMOVED***);
***REMOVED***;

    Rewriter.prototype.indentation = function(origin) ***REMOVED***
      var indent, outdent;
      indent = ['INDENT', 2];
      outdent = ['OUTDENT', 2];
      if (origin) ***REMOVED***
        indent.generated = outdent.generated = true;
        indent.origin = outdent.origin = origin;
  ***REMOVED*** else ***REMOVED***
        indent.explicit = outdent.explicit = true;
  ***REMOVED***
      return [indent, outdent];
***REMOVED***;

    Rewriter.prototype.generate = generate;

    Rewriter.prototype.tag = function(i) ***REMOVED***
      var ref;
      return (ref = this.tokens[i]) != null ? ref[0] : void 0;
***REMOVED***;

    return Rewriter;

  ***REMOVED***)();

  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['***REMOVED***', '***REMOVED***'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END'], ['STRING_START', 'STRING_END'], ['REGEX_START', 'REGEX_END']];

  exports.INVERSES = INVERSES = ***REMOVED******REMOVED***;

  EXPRESSION_START = [];

  EXPRESSION_END = [];

  for (k = 0, len = BALANCED_PAIRS.length; k < len; k++) ***REMOVED***
    ref = BALANCED_PAIRS[k], left = ref[0], rite = ref[1];
    EXPRESSION_START.push(INVERSES[rite] = left);
    EXPRESSION_END.push(INVERSES[left] = rite);
  ***REMOVED***

  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);

  IMPLICIT_FUNC = ['IDENTIFIER', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];

  IMPLICIT_CALL = ['IDENTIFIER', 'NUMBER', 'STRING', 'STRING_START', 'JS', 'REGEX', 'REGEX_START', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'BOOL', 'NULL', 'UNDEFINED', 'UNARY', 'YIELD', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '***REMOVED***', '--', '++'];

  IMPLICIT_UNSPACED_CALL = ['+', '-'];

  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];

  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];

  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];

  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];

  CALL_CLOSERS = ['.', '?.', '::', '?::'];

***REMOVED***).call(this);
