
module.exports = exports = build

/**
 * Module dependencies.
 */

var fs = require('graceful-fs')
  , rm = require('rimraf')
  , path = require('path')
  , glob = require('glob')
  , log = require('npmlog')
  , which = require('which')
  , mkdirp = require('mkdirp')
  , exec = require('child_process').exec
  , processRelease = require('./process-release')
  , win = process.platform == 'win32'

exports.usage = 'Invokes `' + (win ? 'msbuild' : 'make') + '` and builds the module'

function build (gyp, argv, callback) ***REMOVED***
  var platformMake = 'make'
  if (process.platform === 'aix') ***REMOVED***
    platformMake = 'gmake'
  ***REMOVED*** else if (process.platform.indexOf('bsd') !== -1) ***REMOVED***
    platformMake = 'gmake'
  ***REMOVED***

  var release = processRelease(argv, gyp, process.version, process.release)
    , makeCommand = gyp.opts.make || process.env.MAKE || platformMake
    , command = win ? 'msbuild' : makeCommand
    , buildDir = path.resolve('build')
    , configPath = path.resolve(buildDir, 'config.gypi')
    , jobs = gyp.opts.jobs || process.env.JOBS
    , buildType
    , config
    , arch
    , nodeDir
    , copyDevLib

  loadConfigGypi()

  /**
   * Load the "config.gypi" file that was generated during "configure".
   */

  function loadConfigGypi () ***REMOVED***
    fs.readFile(configPath, 'utf8', function (err, data) ***REMOVED***
      if (err) ***REMOVED***
        if (err.code == 'ENOENT') ***REMOVED***
          callback(new Error('You must run `node-gyp configure` first!'))
***REMOVED*** else ***REMOVED***
          callback(err)
***REMOVED***
        return
  ***REMOVED***
      config = JSON.parse(data.replace(/\#.+\n/, ''))

      // get the 'arch', 'buildType', and 'nodeDir' vars from the config
      buildType = config.target_defaults.default_configuration
      arch = config.variables.target_arch
      nodeDir = config.variables.nodedir
      copyDevLib = config.variables.copy_dev_lib == 'true'

      if ('debug' in gyp.opts) ***REMOVED***
        buildType = gyp.opts.debug ? 'Debug' : 'Release'
  ***REMOVED***
      if (!buildType) ***REMOVED***
        buildType = 'Release'
  ***REMOVED***

      log.verbose('build type', buildType)
      log.verbose('architecture', arch)
      log.verbose('node dev dir', nodeDir)

      if (win) ***REMOVED***
        findSolutionFile()
  ***REMOVED*** else ***REMOVED***
        doWhich()
  ***REMOVED***
***REMOVED***)
  ***REMOVED***

  /**
   * On Windows, find the first build/*.sln file.
   */

  function findSolutionFile () ***REMOVED***
    glob('build/*.sln', function (err, files) ***REMOVED***
      if (err) return callback(err)
      if (files.length === 0) ***REMOVED***
        return callback(new Error('Could not find *.sln file. Did you run "configure"?'))
  ***REMOVED***
      guessedSolution = files[0]
      log.verbose('found first Solution file', guessedSolution)
      doWhich()
***REMOVED***)
  ***REMOVED***

  /**
   * Uses node-which to locate the msbuild / make executable.
   */

  function doWhich () ***REMOVED***
    // First make sure we have the build command in the PATH
    which(command, function (err, execPath) ***REMOVED***
      if (err) ***REMOVED***
        if (win && /not found/.test(err.message)) ***REMOVED***
          // On windows and no 'msbuild' found. Let's guess where it is
          findMsbuild()
***REMOVED*** else ***REMOVED***
          // Some other error or 'make' not found on Unix, report that to the user
          callback(err)
***REMOVED***
        return
  ***REMOVED***
      log.verbose('`which` succeeded for `' + command + '`', execPath)
      copyNodeLib()
***REMOVED***)
  ***REMOVED***

  /**
   * Search for the location of "msbuild.exe" file on Windows.
   */

  function findMsbuild () ***REMOVED***
    log.verbose('could not find "msbuild.exe" in PATH - finding location in registry')
    var notfoundErr = new Error('Can\'t find "msbuild.exe". Do you have Microsoft Visual Studio C++ 2008+ installed?')
    var cmd = 'reg query "HKLM\\Software\\Microsoft\\MSBuild\\ToolsVersions" /s'
    if (process.arch !== 'ia32')
      cmd += ' /reg:32'
    exec(cmd, function (err, stdout, stderr) ***REMOVED***
      var reVers = /ToolsVersions\\([^\\]+)$/i
        , rePath = /\r\n[ \t]+MSBuildToolsPath[ \t]+REG_SZ[ \t]+([^\r]+)/i
        , msbuilds = []
        , r
        , msbuildPath
      if (err) ***REMOVED***
        return callback(notfoundErr)
  ***REMOVED***
      stdout.split('\r\n\r\n').forEach(function(l) ***REMOVED***
        if (!l) return
        l = l.trim()
        if (r = reVers.exec(l.substring(0, l.indexOf('\r\n')))) ***REMOVED***
          var ver = parseFloat(r[1], 10)
          if (ver >= 3.5) ***REMOVED***
            if (r = rePath.exec(l)) ***REMOVED***
              msbuilds.push(***REMOVED***
                version: ver,
                path: r[1]
  ***REMOVED***)
***REMOVED***
  ***REMOVED***
***REMOVED***
  ***REMOVED***)
      msbuilds.sort(function (x, y) ***REMOVED***
        return (x.version < y.version ? -1 : 1)
  ***REMOVED***)
      ;(function verifyMsbuild () ***REMOVED***
        if (!msbuilds.length) return callback(notfoundErr)
        msbuildPath = path.resolve(msbuilds.pop().path, 'msbuild.exe')
        fs.stat(msbuildPath, function (err, stat) ***REMOVED***
          if (err) ***REMOVED***
            if (err.code == 'ENOENT') ***REMOVED***
              if (msbuilds.length) ***REMOVED***
                return verifyMsbuild()
  ***REMOVED*** else ***REMOVED***
                callback(notfoundErr)
  ***REMOVED***
***REMOVED*** else ***REMOVED***
              callback(err)
***REMOVED***
            return
  ***REMOVED***
          command = msbuildPath
          copyNodeLib()
***REMOVED***)
  ***REMOVED***)()
***REMOVED***)
  ***REMOVED***

  /**
   * Copies the node.lib file for the current target architecture into the
   * current proper dev dir location.
   */

  function copyNodeLib () ***REMOVED***
    if (!win || !copyDevLib) return doBuild()

    var buildDir = path.resolve(nodeDir, buildType)
      , archNodeLibPath = path.resolve(nodeDir, arch, release.name + '.lib')
      , buildNodeLibPath = path.resolve(buildDir, release.name + '.lib')

    mkdirp(buildDir, function (err, isNew) ***REMOVED***
      if (err) return callback(err)
      log.verbose('"' + buildType + '" dir needed to be created?', isNew)
      var rs = fs.createReadStream(archNodeLibPath)
        , ws = fs.createWriteStream(buildNodeLibPath)
      log.verbose('copying "' + release.name + '.lib" for ' + arch, buildNodeLibPath)
      rs.pipe(ws)
      rs.on('error', callback)
      ws.on('error', callback)
      rs.on('end', doBuild)
***REMOVED***)
  ***REMOVED***

  /**
   * Actually spawn the process and compile the module.
   */

  function doBuild () ***REMOVED***

    // Enable Verbose build
    var verbose = log.levels[log.level] <= log.levels.verbose
    if (!win && verbose) ***REMOVED***
      argv.push('V=1')
***REMOVED***
    if (win && !verbose) ***REMOVED***
      argv.push('/clp:Verbosity=minimal')
***REMOVED***

    if (win) ***REMOVED***
      // Turn off the Microsoft logo on Windows
      argv.push('/nologo')
***REMOVED***

    // Specify the build type, Release by default
    if (win) ***REMOVED***
      var p = arch === 'x64' ? 'x64' : 'Win32'
      argv.push('/p:Configuration=' + buildType + ';Platform=' + p)
      if (jobs) ***REMOVED***
        var j = parseInt(jobs, 10)
        if (!isNaN(j) && j > 0) ***REMOVED***
          argv.push('/m:' + j)
***REMOVED*** else if (jobs.toUpperCase() === 'MAX') ***REMOVED***
          argv.push('/m:' + require('os').cpus().length)
***REMOVED***
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      argv.push('BUILDTYPE=' + buildType)
      // Invoke the Makefile in the 'build' dir.
      argv.push('-C')
      argv.push('build')
      if (jobs) ***REMOVED***
        var j = parseInt(jobs, 10)
        if (!isNaN(j) && j > 0) ***REMOVED***
          argv.push('--jobs')
          argv.push(j)
***REMOVED*** else if (jobs.toUpperCase() === 'MAX') ***REMOVED***
          argv.push('--jobs')
          argv.push(require('os').cpus().length)
***REMOVED***
  ***REMOVED***
***REMOVED***

    if (win) ***REMOVED***
      // did the user specify their own .sln file?
      var hasSln = argv.some(function (arg) ***REMOVED***
        return path.extname(arg) == '.sln'
  ***REMOVED***)
      if (!hasSln) ***REMOVED***
        argv.unshift(gyp.opts.solution || guessedSolution)
  ***REMOVED***
***REMOVED***

    var proc = gyp.spawn(command, argv)
    proc.on('exit', onExit)
  ***REMOVED***

  /**
   * Invoked after the make/msbuild command exits.
   */

  function onExit (code, signal) ***REMOVED***
    if (code !== 0) ***REMOVED***
      return callback(new Error('`' + command + '` failed with exit code: ' + code))
***REMOVED***
    if (signal) ***REMOVED***
      return callback(new Error('`' + command + '` got signal: ' + signal))
***REMOVED***
    callback()
  ***REMOVED***

***REMOVED***
