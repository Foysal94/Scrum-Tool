/*!
 * node-sass: lib/index.js
 */

var eol = require('os').EOL,
    path = require('path'),
    util = require('util'),
    pkg = require('../package.json');

require('./extensions');

/**
 * Require binding
 */

var binding = require(process.sass.getBinaryPath(true));

/**
 * Get Sass version information
 *
 * @api private
 */

function getVersionInfo(binding) ***REMOVED***
  return [
           ['node-sass', pkg.version, '(Wrapper)', '[JavaScript]'].join('\t'),
           ['libsass  ', binding.libsassVersion(), '(Sass Compiler)', '[C/C++]'].join('\t'),
  ].join(eol);
***REMOVED***

/**
 * Get input file
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api private
 */

function getInputFile(options) ***REMOVED***
  return options.file ? path.resolve(options.file) : null;
***REMOVED***

/**
 * Get output file
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api private
 */

function getOutputFile(options) ***REMOVED***
  var outFile = options.outFile;

  if (!outFile || typeof outFile !== 'string' || (!options.data && !options.file)) ***REMOVED***
    return null;
  ***REMOVED***

  return path.resolve(outFile);
***REMOVED***

/**
 * Get source map
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api private
 */

function getSourceMap(options) ***REMOVED***
  var sourceMap = options.sourceMap;

  if (sourceMap && typeof sourceMap !== 'string' && options.outFile) ***REMOVED***
    sourceMap = options.outFile + '.map';
  ***REMOVED***

  return sourceMap && typeof sourceMap === 'string' ? path.resolve(sourceMap) : null;
***REMOVED***

/**
 * Get stats
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api private
 */

function getStats(options) ***REMOVED***
  var stats = ***REMOVED******REMOVED***;

  stats.entry = options.file || 'data';
  stats.start = Date.now();

  return stats;
***REMOVED***

/**
 * End stats
 *
 * @param ***REMOVED***Object***REMOVED*** stats
 * @param ***REMOVED***Object***REMOVED*** sourceMap
 * @api private
 */

function endStats(stats) ***REMOVED***
  stats.end = Date.now();
  stats.duration = stats.end - stats.start;

  return stats;
***REMOVED***

/**
 * Get style
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api private
 */

function getStyle(options) ***REMOVED***
  var styles = ***REMOVED***
    nested: 0,
    expanded: 1,
    compact: 2,
    compressed: 3
  ***REMOVED***;

  return styles[options.outputStyle] || 0;
***REMOVED***

/**
 * Get indent width
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api private
 */

function getIndentWidth(options) ***REMOVED***
  var width = parseInt(options.indentWidth) || 2;

  return width > 10 ? 2 : width;
***REMOVED***

/**
 * Get indent type
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api private
 */

function getIndentType(options) ***REMOVED***
  var types = ***REMOVED***
    space: 0,
    tab: 1
  ***REMOVED***;

  return types[options.indentType] || 0;
***REMOVED***

/**
 * Get linefeed
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api private
 */

function getLinefeed(options) ***REMOVED***
  var feeds = ***REMOVED***
    cr: '\r',
    crlf: '\r\n',
    lf: '\n',
    lfcr: '\n\r'
  ***REMOVED***;

  return feeds[options.linefeed] || '\n';
***REMOVED***

/**
 * Get options
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api private
 */

function getOptions(options, cb) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  options.sourceComments = options.sourceComments || false;
  if (options.hasOwnProperty('file')) ***REMOVED***
    options.file = getInputFile(options);
  ***REMOVED***
  options.outFile = getOutputFile(options);
  options.includePaths = (options.includePaths || []).join(path.delimiter);
  options.precision = parseInt(options.precision) || 5;
  options.sourceMap = getSourceMap(options);
  options.style = getStyle(options);
  options.indentWidth = getIndentWidth(options);
  options.indentType = getIndentType(options);
  options.linefeed = getLinefeed(options);

  // context object represents node-sass environment
  options.context = ***REMOVED*** options: options, callback: cb ***REMOVED***;

  options.result = ***REMOVED***
    stats: getStats(options)
  ***REMOVED***;

  return options;
***REMOVED***

/**
 * Executes a callback and transforms any exception raised into a sass error
 *
 * @param ***REMOVED***Function***REMOVED*** callback
 * @param ***REMOVED***Array***REMOVED*** arguments
 * @api private
 */

function tryCallback(callback, args) ***REMOVED***
  try ***REMOVED***
    return callback.apply(this, args);
  ***REMOVED*** catch (e) ***REMOVED***
    if (typeof e === 'string') ***REMOVED***
      return new binding.types.Error(e);
***REMOVED*** else if (e instanceof Error) ***REMOVED***
      return new binding.types.Error(e.message);
***REMOVED*** else ***REMOVED***
      return new binding.types.Error('An unexpected error occurred');
***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Normalizes the signature of custom functions to make it possible to just supply the
 * function name and have the signature default to `fn(...)`. The callback is adjusted
 * to transform the input sass list into discrete arguments.
 *
 * @param ***REMOVED***String***REMOVED*** signature
 * @param ***REMOVED***Function***REMOVED*** callback
 * @return ***REMOVED***Object***REMOVED***
 * @api private
 */

function normalizeFunctionSignature(signature, callback) ***REMOVED***
  if (!/^\*|@warn|@error|@debug|\w+\(.*\)$/.test(signature)) ***REMOVED***
    if (!/\w+/.test(signature)) ***REMOVED***
      throw new Error('Invalid function signature format "' + signature + '"');
***REMOVED***

    return ***REMOVED***
      signature: signature + '(...)',
      callback: function() ***REMOVED***
        var args = Array.prototype.slice.call(arguments),
            list = args.shift(),
            i;

        for (i = list.getLength() - 1; i >= 0; i--) ***REMOVED***
          args.unshift(list.getValue(i));
***REMOVED***

        return callback.apply(this, args);
  ***REMOVED***
***REMOVED***;
  ***REMOVED***

  return ***REMOVED***
    signature: signature,
    callback: callback
  ***REMOVED***;
***REMOVED***

/**
 * Render
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api public
 */

module.exports.render = function(options, cb) ***REMOVED***
  options = getOptions(options, cb);

  // options.error and options.success are for libsass binding
  options.error = function(err) ***REMOVED***
    var payload = util._extend(new Error(), JSON.parse(err));

    if (cb) ***REMOVED***
      options.context.callback.call(options.context, payload, null);
***REMOVED***
  ***REMOVED***;

  options.success = function() ***REMOVED***
    var result = options.result;
    var stats = endStats(result.stats);
    var payload = ***REMOVED***
      css: result.css,
      map: result.map,
      stats: stats
***REMOVED***;

    if (cb) ***REMOVED***
      options.context.callback.call(options.context, null, payload);
***REMOVED***
  ***REMOVED***;

  var importer = options.importer;

  if (importer) ***REMOVED***
    if (Array.isArray(importer)) ***REMOVED***
      importer.forEach(function(subject, index) ***REMOVED***
        options.importer[index] = function(file, prev, bridge) ***REMOVED***
          function done(data) ***REMOVED***
            bridge.success(data);
  ***REMOVED***

          var result = subject.call(options.context, file, prev, done);

          if (result) ***REMOVED***
            done(result === module.exports.NULL ? null : result);
  ***REMOVED***
***REMOVED***;
  ***REMOVED***);
***REMOVED*** else ***REMOVED***
      options.importer = function(file, prev, bridge) ***REMOVED***
        function done(data) ***REMOVED***
          bridge.success(data);
***REMOVED***

        var result = importer.call(options.context, file, prev, done);

        if (result) ***REMOVED***
          done(result === module.exports.NULL ? null : result);
***REMOVED***
  ***REMOVED***;
***REMOVED***
  ***REMOVED***

  var functions = options.functions;

  if (functions) ***REMOVED***
    options.functions = ***REMOVED******REMOVED***;

    Object.keys(functions).forEach(function(subject) ***REMOVED***
      var cb = normalizeFunctionSignature(subject, functions[subject]);

      options.functions[cb.signature] = function() ***REMOVED***
        var args = Array.prototype.slice.call(arguments),
            bridge = args.pop();

        function done(data) ***REMOVED***
          bridge.success(data);
***REMOVED***

        var result = tryCallback(cb.callback, args.concat(done));

        if (result) ***REMOVED***
          done(result);
***REMOVED***
  ***REMOVED***;
***REMOVED***);
  ***REMOVED***

  if (options.data) ***REMOVED***
    binding.render(options);
  ***REMOVED*** else if (options.file) ***REMOVED***
    binding.renderFile(options);
  ***REMOVED*** else ***REMOVED***
    cb(***REMOVED***status: 3, message: 'No input specified: provide a file name or a source string to process' ***REMOVED***);
  ***REMOVED***
***REMOVED***;

/**
 * Render sync
 *
 * @param ***REMOVED***Object***REMOVED*** options
 * @api public
 */

module.exports.renderSync = function(options) ***REMOVED***
  options = getOptions(options);

  var importer = options.importer;

  if (importer) ***REMOVED***
    if (Array.isArray(importer)) ***REMOVED***
      importer.forEach(function(subject, index) ***REMOVED***
        options.importer[index] = function(file, prev) ***REMOVED***
          var result = subject.call(options.context, file, prev);

          return result === module.exports.NULL ? null : result;
***REMOVED***;
  ***REMOVED***);
***REMOVED*** else ***REMOVED***
      options.importer = function(file, prev) ***REMOVED***
        var result = importer.call(options.context, file, prev);

        return result === module.exports.NULL ? null : result;
  ***REMOVED***;
***REMOVED***
  ***REMOVED***

  var functions = options.functions;

  if (options.functions) ***REMOVED***
    options.functions = ***REMOVED******REMOVED***;

    Object.keys(functions).forEach(function(signature) ***REMOVED***
      var cb = normalizeFunctionSignature(signature, functions[signature]);

      options.functions[cb.signature] = function() ***REMOVED***
        return tryCallback(cb.callback, arguments);
  ***REMOVED***;
***REMOVED***);
  ***REMOVED***

  var status;
  if (options.data) ***REMOVED***
     status = binding.renderSync(options);
  ***REMOVED*** else if (options.file) ***REMOVED***
     status = binding.renderFileSync(options);
  ***REMOVED*** else ***REMOVED***
     throw new Error('No input specified: provide a file name or a source string to process');
  ***REMOVED***

  var result = options.result;

  if (status) ***REMOVED***
    result.stats = endStats(result.stats);
    return result;
  ***REMOVED***

  throw util._extend(new Error(), JSON.parse(result.error));
***REMOVED***;

/**
 * API Info
 *
 * @api public
 */

process.sass.versionInfo = getVersionInfo(binding);
module.exports.info = process.sass.versionInfo;

/**
 * Expose sass types
 */

module.exports.types = binding.types;
module.exports.TRUE = binding.types.Boolean.TRUE;
module.exports.FALSE = binding.types.Boolean.FALSE;
module.exports.NULL = binding.types.Null.NULL;
