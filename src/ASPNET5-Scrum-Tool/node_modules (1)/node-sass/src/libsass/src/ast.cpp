#include "ast.hpp"
#include "context.hpp"
#include "node.hpp"
#include "extend.hpp"
#include "to_string.hpp"
#include "color_maps.hpp"
#include <set>
#include <iomanip>
#include <algorithm>
#include <iostream>

namespace Sass ***REMOVED***

  static Null sass_null(Sass::Null(ParserState("null")));

  bool Supports_Operator::needs_parens(Supports_Condition* cond) const ***REMOVED***
    return dynamic_cast<Supports_Negation*>(cond) ||
          (dynamic_cast<Supports_Operator*>(cond) &&
           dynamic_cast<Supports_Operator*>(cond)->operand() != operand());
  ***REMOVED***

  bool Supports_Negation::needs_parens(Supports_Condition* cond) const ***REMOVED***
    return dynamic_cast<Supports_Negation*>(cond) ||
          dynamic_cast<Supports_Operator*>(cond);
  ***REMOVED***

  void AST_Node::update_pstate(const ParserState& pstate)
  ***REMOVED***
    pstate_.offset += pstate - pstate_ + pstate.offset;
  ***REMOVED***

  inline bool is_ns_eq(const std::string& l, const std::string& r)
  ***REMOVED***
    if (l.empty() && r.empty()) return true;
    else if (l.empty() && r == "*") return true;
    else if (r.empty() && l == "*") return true;
    else return l == r;
  ***REMOVED***



  bool Compound_Selector::operator< (const Compound_Selector& rhs) const
  ***REMOVED***
    size_t L = std::min(length(), rhs.length());
    for (size_t i = 0; i < L; ++i)
***REMOVED***
      Simple_Selector* l = (*this)[i];
      Simple_Selector* r = rhs[i];
      if (!l && !r) return false;
      else if (!r) return false;
      else if (!l) return true;
      else if (*l != *r)
  ***REMOVED*** return *l < *r; ***REMOVED***
***REMOVED***
    // just compare the length now
    return length() < rhs.length();
  ***REMOVED***

  bool Compound_Selector::has_parent_ref()
  ***REMOVED***
    return has_parent_reference();
  ***REMOVED***

  bool Complex_Selector::has_parent_ref()
  ***REMOVED***
    return (head() && head()->has_parent_ref()) ||
           (tail() && tail()->has_parent_ref());
  ***REMOVED***

  bool Complex_Selector::operator< (const Complex_Selector& rhs) const
  ***REMOVED***
    // const iterators for tails
    const Complex_Selector* l = this;
    const Complex_Selector* r = &rhs;
    Compound_Selector* l_h = l ? l->head() : 0;
    Compound_Selector* r_h = r ? r->head() : 0;
    // process all tails
    while (true)
***REMOVED***
      // skip empty ancestor first
      if (l && l->is_empty_ancestor())
  ***REMOVED***
        l = l->tail();
        l_h = l ? l->head() : 0;
        continue;
  ***REMOVED***
      // skip empty ancestor first
      if (r && r->is_empty_ancestor())
  ***REMOVED***
        r = r->tail();
        r_h = r ? r->head() : 0;
        continue;
  ***REMOVED***
      // check for valid selectors
      if (!l) return !!r;
      if (!r) return false;
      // both are null
      else if (!l_h && !r_h)
  ***REMOVED***
        // check combinator after heads
        if (l->combinator() != r->combinator())
***REMOVED*** return l->combinator() < r->combinator(); ***REMOVED***
        // advance to next tails
        l = l->tail();
        r = r->tail();
        // fetch the next headers
        l_h = l ? l->head() : 0;
        r_h = r ? r->head() : 0;
  ***REMOVED***
      // one side is null
      else if (!r_h) return true;
      else if (!l_h) return false;
      // heads ok and equal
      else if (*l_h == *r_h)
  ***REMOVED***
        // check combinator after heads
        if (l->combinator() != r->combinator())
***REMOVED*** return l->combinator() < r->combinator(); ***REMOVED***
        // advance to next tails
        l = l->tail();
        r = r->tail();
        // fetch the next headers
        l_h = l ? l->head() : 0;
        r_h = r ? r->head() : 0;
  ***REMOVED***
      // heads are not equal
      else return *l_h < *r_h;
***REMOVED***
    return true;
  ***REMOVED***

  bool Complex_Selector::operator== (const Complex_Selector& rhs) const
  ***REMOVED***
    // const iterators for tails
    const Complex_Selector* l = this;
    const Complex_Selector* r = &rhs;
    Compound_Selector* l_h = l ? l->head() : 0;
    Compound_Selector* r_h = r ? r->head() : 0;
    // process all tails
    while (true)
***REMOVED***
      // skip empty ancestor first
      if (l && l->is_empty_ancestor())
  ***REMOVED***
        l = l->tail();
        l_h = l ? l->head() : 0;
        continue;
  ***REMOVED***
      // skip empty ancestor first
      if (r && r->is_empty_ancestor())
  ***REMOVED***
        r = r->tail();
        r_h = r ? r->head() : 0;
        continue;
  ***REMOVED***
      // check the pointers
      if (!r) return !l;
      if (!l) return !r;
      // both are null
      if (!l_h && !r_h)
  ***REMOVED***
        // check combinator after heads
        if (l->combinator() != r->combinator())
***REMOVED*** return l->combinator() < r->combinator(); ***REMOVED***
        // advance to next tails
        l = l->tail();
        r = r->tail();
        // fetch the next heads
        l_h = l ? l->head() : 0;
        r_h = r ? r->head() : 0;
  ***REMOVED***
      // fail if only one is null
      else if (!r_h) return !l_h;
      else if (!l_h) return !r_h;
      // heads ok and equal
      else if (*l_h == *r_h)
  ***REMOVED***
        // check combinator after heads
        if (l->combinator() != r->combinator())
***REMOVED*** return l->combinator() == r->combinator(); ***REMOVED***
        // advance to next tails
        l = l->tail();
        r = r->tail();
        // fetch the next heads
        l_h = l ? l->head() : 0;
        r_h = r ? r->head() : 0;
  ***REMOVED***
      // abort
      else break;
***REMOVED***
    // unreachable
    return false;
  ***REMOVED***

  Compound_Selector* Compound_Selector::unify_with(Compound_Selector* rhs, Context& ctx)
  ***REMOVED***
    Compound_Selector* unified = rhs;
    for (size_t i = 0, L = length(); i < L; ++i)
***REMOVED***
      if (!unified) break;
      unified = (*this)[i]->unify_with(unified, ctx);
***REMOVED***
    return unified;
  ***REMOVED***

  bool Simple_Selector::operator== (const Simple_Selector& rhs) const
  ***REMOVED***
    const Attribute_Selector* ll = dynamic_cast<const Attribute_Selector*>(this);
    const Attribute_Selector* rr = dynamic_cast<const Attribute_Selector*>(&rhs);
    if (ll && rr) return *ll == *rr;

    if (is_ns_eq(ns(), rhs.ns()))
***REMOVED*** return name() == rhs.name(); ***REMOVED***
    return ns() == rhs.ns();
  ***REMOVED***

  bool Simple_Selector::operator< (const Simple_Selector& rhs) const
  ***REMOVED***
    const Attribute_Selector* ll = dynamic_cast<const Attribute_Selector*>(this);
    const Attribute_Selector* rr = dynamic_cast<const Attribute_Selector*>(&rhs);
    if (ll && rr) return *ll < *rr;

    if (is_ns_eq(ns(), rhs.ns()))
***REMOVED*** return name() < rhs.name(); ***REMOVED***
    return ns() < rhs.ns();
  ***REMOVED***

  bool Selector_List::operator== (const Selector& rhs) const
  ***REMOVED***
    // solve the double dispatch problem by using RTTI information via dynamic cast
    if (const Selector_List* ls = dynamic_cast<const Selector_List*>(&rhs)) ***REMOVED*** return *this == *ls; ***REMOVED***
    else if (const Complex_Selector* ls = dynamic_cast<const Complex_Selector*>(&rhs)) ***REMOVED*** return *this == *ls; ***REMOVED***
    else if (const Compound_Selector* ls = dynamic_cast<const Compound_Selector*>(&rhs)) ***REMOVED*** return *this == *ls; ***REMOVED***
    // no compare method
    return this == &rhs;
  ***REMOVED***

  // Selector lists can be compared to comma lists
  bool Selector_List::operator==(const Expression& rhs) const
  ***REMOVED***
    // solve the double dispatch problem by using RTTI information via dynamic cast
    if (const List* ls = dynamic_cast<const List*>(&rhs)) ***REMOVED*** return *this == *ls; ***REMOVED***
    if (const Selector* ls = dynamic_cast<const Selector*>(&rhs)) ***REMOVED*** return *this == *ls; ***REMOVED***
    // compare invalid (maybe we should error?)
    return false;
  ***REMOVED***

  bool Selector_List::operator== (const Selector_List& rhs) const
  ***REMOVED***
    // for array access
    size_t i = 0, n = 0;
    size_t iL = length();
    size_t nL = rhs.length();
    // create temporary vectors and sort them
    std::vector<Complex_Selector*> l_lst = this->elements();
    std::vector<Complex_Selector*> r_lst = rhs.elements();
    std::sort(l_lst.begin(), l_lst.end(), cmp_complex_selector());
    std::sort(r_lst.begin(), r_lst.end(), cmp_complex_selector());
    // process loop
    while (true)
***REMOVED***
      // first check for valid index
      if (i == iL) return iL == nL;
      else if (n == nL) return iL == nL;
      // the access the vector items
      Complex_Selector* l = l_lst[i];
      Complex_Selector* r = r_lst[n];
      // skip nulls
      if (!l) ++i;
      else if (!r) ++n;
      // do the check
      else if (*l != *r)
  ***REMOVED*** return false; ***REMOVED***
      // advance
      ++i; ++n;
***REMOVED***
    // no mismatch
    return true;
  ***REMOVED***

  Compound_Selector* Simple_Selector::unify_with(Compound_Selector* rhs, Context& ctx)
  ***REMOVED***
    To_String to_string(&ctx);
    for (size_t i = 0, L = rhs->length(); i < L; ++i)
***REMOVED*** if (perform(&to_string) == (*rhs)[i]->perform(&to_string)) return rhs; ***REMOVED***

    // check for pseudo elements because they are always last
    size_t i, L;
    bool found = false;
    if (typeid(*this) == typeid(Pseudo_Selector) || typeid(*this) == typeid(Wrapped_Selector))
***REMOVED***
      for (i = 0, L = rhs->length(); i < L; ++i)
  ***REMOVED***
        if ((typeid(*(*rhs)[i]) == typeid(Pseudo_Selector) || typeid(*(*rhs)[i]) == typeid(Wrapped_Selector)) && (*rhs)[L-1]->is_pseudo_element())
***REMOVED*** found = true; break; ***REMOVED***
  ***REMOVED***
***REMOVED***
    else
***REMOVED***
      for (i = 0, L = rhs->length(); i < L; ++i)
  ***REMOVED***
        if (typeid(*(*rhs)[i]) == typeid(Pseudo_Selector) || typeid(*(*rhs)[i]) == typeid(Wrapped_Selector))
***REMOVED*** found = true; break; ***REMOVED***
  ***REMOVED***
***REMOVED***
    if (!found)
***REMOVED***
      Compound_Selector* cpy = SASS_MEMORY_NEW(ctx.mem, Compound_Selector, *rhs);
      (*cpy) << this;
      return cpy;
***REMOVED***
    Compound_Selector* cpy = SASS_MEMORY_NEW(ctx.mem, Compound_Selector, rhs->pstate());
    for (size_t j = 0; j < i; ++j)
***REMOVED*** (*cpy) << (*rhs)[j]; ***REMOVED***
    (*cpy) << this;
    for (size_t j = i; j < L; ++j)
***REMOVED*** (*cpy) << (*rhs)[j]; ***REMOVED***
    return cpy;
  ***REMOVED***

  Simple_Selector* Type_Selector::unify_with(Simple_Selector* rhs, Context& ctx)
  ***REMOVED***
    // check if ns can be extended
    // true for no ns or universal
    if (has_universal_ns())
***REMOVED***
      // but dont extend with universal
      // true for valid ns and universal
      if (!rhs->is_universal_ns())
  ***REMOVED***
        // creaty the copy inside (avoid unnecessary copies)
        Type_Selector* ts = SASS_MEMORY_NEW(ctx.mem, Type_Selector, *this);
        // overwrite the name if star is given as name
        if (ts->name() == "*") ***REMOVED*** ts->name(rhs->name()); ***REMOVED***
        // now overwrite the namespace name and flag
        ts->ns(rhs->ns()); ts->has_ns(rhs->has_ns());
        // return copy
        return ts;
  ***REMOVED***
***REMOVED***
    // namespace may changed, check the name now
    // overwrite star (but not with another star)
    if (name() == "*" && rhs->name() != "*")
***REMOVED***
      // creaty the copy inside (avoid unnecessary copies)
      Type_Selector* ts = SASS_MEMORY_NEW(ctx.mem, Type_Selector, *this);
      // simply set the new name
      ts->name(rhs->name());
      // return copy
      return ts;
***REMOVED***
    // return original
    return this;
  ***REMOVED***

  Compound_Selector* Type_Selector::unify_with(Compound_Selector* rhs, Context& ctx)
  ***REMOVED***
    // TODO: handle namespaces

    // if the rhs is empty, just return a copy of this
    if (rhs->length() == 0) ***REMOVED***
      Compound_Selector* cpy = SASS_MEMORY_NEW(ctx.mem, Compound_Selector, rhs->pstate());
      (*cpy) << this;
      return cpy;
***REMOVED***

    Simple_Selector* rhs_0 = (*rhs)[0];
    // otherwise, this is a tag name
    if (name() == "*")
***REMOVED***
      if (typeid(*rhs_0) == typeid(Type_Selector))
  ***REMOVED***
        // if rhs is universal, just return this tagname + rhs's qualifiers
        Compound_Selector* cpy = SASS_MEMORY_NEW(ctx.mem, Compound_Selector, *rhs);
        Type_Selector* ts = static_cast<Type_Selector*>(rhs_0);
        (*cpy)[0] = this->unify_with(ts, ctx);
        return cpy;
  ***REMOVED***
      else if (dynamic_cast<Selector_Qualifier*>(rhs_0)) ***REMOVED***
        // qualifier is `.class`, so we can prefix with `ns|*.class`
        Compound_Selector* cpy = SASS_MEMORY_NEW(ctx.mem, Compound_Selector, rhs->pstate());
        if (has_ns() && !rhs_0->has_ns()) ***REMOVED***
          if (ns() != "*") (*cpy) << this;
***REMOVED***
        for (size_t i = 0, L = rhs->length(); i < L; ++i)
***REMOVED*** (*cpy) << (*rhs)[i]; ***REMOVED***
        return cpy;
  ***REMOVED***


      return rhs;
***REMOVED***

    if (typeid(*rhs_0) == typeid(Type_Selector))
***REMOVED***
      // if rhs is universal, just return this tagname + rhs's qualifiers
      if (rhs_0->name() != "*" && rhs_0->ns() != "*" && rhs_0->name() != name()) return 0;
      // otherwise create new compound and unify first simple selector
      Compound_Selector* copy = SASS_MEMORY_NEW(ctx.mem, Compound_Selector, *rhs);
      (*copy)[0] = this->unify_with(rhs_0, ctx);
      return copy;

***REMOVED***
    // else it's a tag name and a bunch of qualifiers -- just append them
    Compound_Selector* cpy = SASS_MEMORY_NEW(ctx.mem, Compound_Selector, rhs->pstate());
    if (name() != "*") (*cpy) << this;
    (*cpy) += rhs;
    return cpy;
  ***REMOVED***

  Compound_Selector* Selector_Qualifier::unify_with(Compound_Selector* rhs, Context& ctx)
  ***REMOVED***
    if (name()[0] == '#')
***REMOVED***
      for (size_t i = 0, L = rhs->length(); i < L; ++i)
  ***REMOVED***
        Simple_Selector* rhs_i = (*rhs)[i];
        if (typeid(*rhs_i) == typeid(Selector_Qualifier) &&
            static_cast<Selector_Qualifier*>(rhs_i)->name()[0] == '#' &&
            static_cast<Selector_Qualifier*>(rhs_i)->name() != name())
          return 0;
  ***REMOVED***
***REMOVED***
    rhs->has_line_break(has_line_break());
    return Simple_Selector::unify_with(rhs, ctx);
  ***REMOVED***

  Compound_Selector* Pseudo_Selector::unify_with(Compound_Selector* rhs, Context& ctx)
  ***REMOVED***
    if (is_pseudo_element())
***REMOVED***
      for (size_t i = 0, L = rhs->length(); i < L; ++i)
  ***REMOVED***
        Simple_Selector* rhs_i = (*rhs)[i];
        if (typeid(*rhs_i) == typeid(Pseudo_Selector) &&
            static_cast<Pseudo_Selector*>(rhs_i)->is_pseudo_element() &&
            static_cast<Pseudo_Selector*>(rhs_i)->name() != name())
***REMOVED*** return 0; ***REMOVED***
  ***REMOVED***
***REMOVED***
    return Simple_Selector::unify_with(rhs, ctx);
  ***REMOVED***

  bool Attribute_Selector::operator< (const Attribute_Selector& rhs) const
  ***REMOVED***
    if (is_ns_eq(ns(), rhs.ns())) ***REMOVED***
      if (name() == rhs.name()) ***REMOVED***
        if (matcher() == rhs.matcher()) ***REMOVED***
          return value() < rhs.value();
***REMOVED*** else ***REMOVED*** return matcher() < rhs.matcher(); ***REMOVED***
  ***REMOVED*** else ***REMOVED*** return name() < rhs.name(); ***REMOVED***
***REMOVED***
    else return false;
  ***REMOVED***

  bool Attribute_Selector::operator< (const Simple_Selector& rhs) const
  ***REMOVED***
    if (const Attribute_Selector* w = dynamic_cast<const Attribute_Selector*>(&rhs))
***REMOVED***
      return *this < *w;
***REMOVED***
    if (is_ns_eq(ns(), rhs.ns()))
***REMOVED*** return name() < rhs.name(); ***REMOVED***
    return ns() < rhs.ns();
  ***REMOVED***

  bool Attribute_Selector::operator== (const Attribute_Selector& rhs) const
  ***REMOVED***
    if (is_ns_eq(ns(), rhs.ns()) && name() == rhs.name())
***REMOVED*** return matcher() == rhs.matcher() && value() == rhs.value(); ***REMOVED***
    else return false;
  ***REMOVED***

  bool Attribute_Selector::operator== (const Simple_Selector& rhs) const
  ***REMOVED***
    if (const Attribute_Selector* w = dynamic_cast<const Attribute_Selector*>(&rhs))
***REMOVED***
      return *this == *w;
***REMOVED***
    if (is_ns_eq(ns(), rhs.ns()))
***REMOVED*** return name() == rhs.name(); ***REMOVED***
    return ns() == rhs.ns();
  ***REMOVED***

  bool Wrapped_Selector::operator== (const Wrapped_Selector& rhs) const
  ***REMOVED***
    if (is_ns_eq(ns(), rhs.ns()) && name() == rhs.name())
***REMOVED*** return *(selector()) == *(rhs.selector()); ***REMOVED***
    else return false;
  ***REMOVED***

  bool Wrapped_Selector::operator== (const Simple_Selector& rhs) const
  ***REMOVED***
    if (const Wrapped_Selector* w = dynamic_cast<const Wrapped_Selector*>(&rhs))
***REMOVED***
      return *this == *w;
***REMOVED***
    if (is_ns_eq(ns(), rhs.ns()))
***REMOVED*** return name() == rhs.name(); ***REMOVED***
    return ns() == rhs.ns();
  ***REMOVED***

  bool Wrapped_Selector::is_superselector_of(Wrapped_Selector* sub)
  ***REMOVED***
    if (this->name() != sub->name()) return false;
    if (this->name() == ":current") return false;
    if (Selector_List* rhs_list = dynamic_cast<Selector_List*>(sub->selector())) ***REMOVED***
      if (Selector_List* lhs_list = dynamic_cast<Selector_List*>(selector())) ***REMOVED***
        return lhs_list->is_superselector_of(rhs_list);
  ***REMOVED***
      error("is_superselector expected a Selector_List", sub->pstate());
***REMOVED*** else ***REMOVED***
      error("is_superselector expected a Selector_List", sub->pstate());
***REMOVED***
    return false;
  ***REMOVED***

  bool Compound_Selector::is_superselector_of(Selector_List* rhs, std::string wrapped)
  ***REMOVED***
    for (Complex_Selector* item : rhs->elements()) ***REMOVED***
      if (is_superselector_of(item, wrapped)) return true;
***REMOVED***
    return false;
  ***REMOVED***

  bool Compound_Selector::is_superselector_of(Complex_Selector* rhs, std::string wrapped)
  ***REMOVED***
    if (rhs->head()) return is_superselector_of(rhs->head(), wrapped);
    return false;
  ***REMOVED***

  bool Compound_Selector::is_superselector_of(Compound_Selector* rhs, std::string wrapping)
  ***REMOVED***
    To_String to_string;

    Compound_Selector* lhs = this;
    Simple_Selector* lbase = lhs->base();
    Simple_Selector* rbase = rhs->base();

    // Check if pseudo-elements are the same between the selectors

    std::set<std::string> lpsuedoset, rpsuedoset;
    for (size_t i = 0, L = length(); i < L; ++i)
***REMOVED***
      if ((*this)[i]->is_pseudo_element()) ***REMOVED***
        std::string pseudo((*this)[i]->perform(&to_string));
        pseudo = pseudo.substr(pseudo.find_first_not_of(":")); // strip off colons to ensure :after matches ::after since ruby sass is forgiving
        lpsuedoset.insert(pseudo);
  ***REMOVED***
***REMOVED***
    for (size_t i = 0, L = rhs->length(); i < L; ++i)
***REMOVED***
      if ((*rhs)[i]->is_pseudo_element()) ***REMOVED***
        std::string pseudo((*rhs)[i]->perform(&to_string));
        pseudo = pseudo.substr(pseudo.find_first_not_of(":")); // strip off colons to ensure :after matches ::after since ruby sass is forgiving
        rpsuedoset.insert(pseudo);
  ***REMOVED***
***REMOVED***
    if (lpsuedoset != rpsuedoset) ***REMOVED***
      return false;
***REMOVED***

    std::set<std::string> lset, rset;

    if (lbase && rbase)
***REMOVED***
      if (lbase->perform(&to_string) == rbase->perform(&to_string)) ***REMOVED***
        for (size_t i = 1, L = length(); i < L; ++i)
***REMOVED*** lset.insert((*this)[i]->perform(&to_string)); ***REMOVED***
        for (size_t i = 1, L = rhs->length(); i < L; ++i)
***REMOVED*** rset.insert((*rhs)[i]->perform(&to_string)); ***REMOVED***
        return includes(rset.begin(), rset.end(), lset.begin(), lset.end());
  ***REMOVED***
      return false;
***REMOVED***

    for (size_t i = 0, iL = length(); i < iL; ++i)
***REMOVED***
      Selector* lhs = (*this)[i];
      // very special case for wrapped matches selector
      if (Wrapped_Selector* wrapped = dynamic_cast<Wrapped_Selector*>(lhs)) ***REMOVED***
        if (wrapped->name() == ":not") ***REMOVED***
          if (Selector_List* not_list = dynamic_cast<Selector_List*>(wrapped->selector())) ***REMOVED***
            if (not_list->is_superselector_of(rhs, wrapped->name())) return false;
  ***REMOVED*** else ***REMOVED***
            throw std::runtime_error("wrapped not selector is not a list");
  ***REMOVED***
***REMOVED***
        if (wrapped->name() == ":matches" || wrapped->name() == ":-moz-any") ***REMOVED***
          lhs = wrapped->selector();
          if (Selector_List* list = dynamic_cast<Selector_List*>(wrapped->selector())) ***REMOVED***
            if (Compound_Selector* comp = dynamic_cast<Compound_Selector*>(rhs)) ***REMOVED***
              if (!wrapping.empty() && wrapping != wrapped->name()) return false;
              if (wrapping.empty() || wrapping != wrapped->name()) ***REMOVED***;
                if (list->is_superselector_of(comp, wrapped->name())) return true;
  ***REMOVED***
***REMOVED***
  ***REMOVED***
***REMOVED***
        Simple_Selector* rhs_sel = rhs->elements().size() > i ? (*rhs)[i] : 0;
        if (Wrapped_Selector* wrapped_r = dynamic_cast<Wrapped_Selector*>(rhs_sel)) ***REMOVED***
          if (wrapped->name() == wrapped_r->name()) ***REMOVED***
          if (wrapped->is_superselector_of(wrapped_r)) ***REMOVED***
             continue;
             rset.insert(lhs->perform(&to_string));

  ***REMOVED******REMOVED***
***REMOVED***
  ***REMOVED***
      // match from here on as strings
      lset.insert(lhs->perform(&to_string));
***REMOVED***

    for (size_t n = 0, nL = rhs->length(); n < nL; ++n)
***REMOVED***
      auto r = (*rhs)[n];
      if (Wrapped_Selector* wrapped = dynamic_cast<Wrapped_Selector*>(r)) ***REMOVED***
        if (wrapped->name() == ":not") ***REMOVED***
          if (Selector_List* ls = dynamic_cast<Selector_List*>(wrapped->selector())) ***REMOVED***
            ls->remove_parent_selectors();
            if (is_superselector_of(ls, wrapped->name())) return false;
  ***REMOVED***
***REMOVED***
        if (wrapped->name() == ":matches" || wrapped->name() == ":-moz-any") ***REMOVED***
          if (!wrapping.empty()) ***REMOVED***
            if (wrapping != wrapped->name()) return false;
  ***REMOVED***
          if (Selector_List* ls = dynamic_cast<Selector_List*>(wrapped->selector())) ***REMOVED***
            ls->remove_parent_selectors();
            return (is_superselector_of(ls, wrapped->name()));
  ***REMOVED***
***REMOVED***
  ***REMOVED***
      rset.insert(r->perform(&to_string));
***REMOVED***

    //for (auto l : lset) ***REMOVED*** cerr << "l: " << l << endl; ***REMOVED***
    //for (auto r : rset) ***REMOVED*** cerr << "r: " << r << endl; ***REMOVED***

    if (lset.empty()) return true;
    // return true if rset contains all the elements of lset
    return includes(rset.begin(), rset.end(), lset.begin(), lset.end());

  ***REMOVED***

  // create complex selector (ancestor of) from compound selector
  Complex_Selector* Compound_Selector::to_complex(Memory_Manager& mem)
  ***REMOVED***
    // create an intermediate complex selector
    return SASS_MEMORY_NEW(mem, Complex_Selector,
                           pstate(),
                           Complex_Selector::ANCESTOR_OF,
                           this,
                           0);
  ***REMOVED***

  Selector_List* Complex_Selector::unify_with(Complex_Selector* other, Context& ctx)
  ***REMOVED***

    // get last tails (on the right side)
    Complex_Selector* l_last = this->last();
    Complex_Selector* r_last = other->last();

    // check valid pointers (assertion)
    SASS_ASSERT(l_last, "lhs is null");
    SASS_ASSERT(r_last, "rhs is null");

    // Not sure about this check, but closest way I could check
    // was to see if this is a ruby 'SimpleSequence' equivalent.
    // It seems to do the job correctly as some specs react to this
    if (l_last->combinator() != Combinator::ANCESTOR_OF) return 0;
    if (r_last->combinator() != Combinator::ANCESTOR_OF ) return 0;

    // get the headers for the last tails
    Compound_Selector* l_last_head = l_last->head();
    Compound_Selector* r_last_head = r_last->head();

    // check valid head pointers (assertion)
    SASS_ASSERT(l_last_head, "lhs head is null");
    SASS_ASSERT(r_last_head, "rhs head is null");

    // get the unification of the last compound selectors
    Compound_Selector* unified = r_last_head->unify_with(l_last_head, ctx);

    // abort if we could not unify heads
    if (unified == 0) return 0;

    // check for universal (star: `*`) selector
    bool is_universal = l_last_head->is_universal() ||
                        r_last_head->is_universal();

    if (is_universal)
***REMOVED***
      // move the head
      l_last->head(0);
      r_last->head(unified);
***REMOVED***

    // create nodes from both selectors
    Node lhsNode = complexSelectorToNode(this, ctx);
    Node rhsNode = complexSelectorToNode(other, ctx);

    // overwrite universal base
    if (!is_universal)
***REMOVED***
      // create some temporaries to convert to node
      Complex_Selector* fake = unified->to_complex(ctx.mem);
      Node unified_node = complexSelectorToNode(fake, ctx);
      // add to permutate the list?
      rhsNode.plus(unified_node);
***REMOVED***

    // do some magic we inherit from node and extend
    Node node = Extend::subweave(lhsNode, rhsNode, ctx);
    Selector_List* result = SASS_MEMORY_NEW(ctx.mem, Selector_List, pstate());
    NodeDequePtr col = node.collection(); // move from collection to list
    for (NodeDeque::iterator it = col->begin(), end = col->end(); it != end; it++)
***REMOVED*** (*result) << nodeToComplexSelector(Node::naiveTrim(*it, ctx), ctx); ***REMOVED***

    // only return if list has some entries
    return result->length() ? result : 0;

  ***REMOVED***

  bool Compound_Selector::operator== (const Compound_Selector& rhs) const
  ***REMOVED***
    // for array access
    size_t i = 0, n = 0;
    size_t iL = length();
    size_t nL = rhs.length();
    // create temporary vectors and sort them
    std::vector<Simple_Selector*> l_lst = this->elements();
    std::vector<Simple_Selector*> r_lst = rhs.elements();
    std::sort(l_lst.begin(), l_lst.end(), cmp_simple_selector());
    std::sort(r_lst.begin(), r_lst.end(), cmp_simple_selector());
    // process loop
    while (true)
***REMOVED***
      // first check for valid index
      if (i == iL) return iL == nL;
      else if (n == nL) return iL == nL;
      // the access the vector items
      Simple_Selector* l = l_lst[i];
      Simple_Selector* r = r_lst[n];
      // skip nulls
      if (!l) ++i;
      if (!r) ++n;
      // do the check now
      else if (*l != *r)
  ***REMOVED*** return false; ***REMOVED***
      // advance now
      ++i; ++n;
***REMOVED***
    // no mismatch
    return true;
  ***REMOVED***

  bool Complex_Selector_Pointer_Compare::operator() (const Complex_Selector* const pLeft, const Complex_Selector* const pRight) const ***REMOVED***
    return *pLeft < *pRight;
  ***REMOVED***

  bool Complex_Selector::is_superselector_of(Compound_Selector* rhs, std::string wrapping)
  ***REMOVED***
    return last()->head() && last()->head()->is_superselector_of(rhs, wrapping);
  ***REMOVED***

  bool Complex_Selector::is_superselector_of(Complex_Selector* rhs, std::string wrapping)
  ***REMOVED***
    Complex_Selector* lhs = this;
    To_String to_string;
    // check for selectors with leading or trailing combinators
    if (!lhs->head() || !rhs->head())
***REMOVED*** return false; ***REMOVED***
    const Complex_Selector* l_innermost = lhs->innermost();
    if (l_innermost->combinator() != Complex_Selector::ANCESTOR_OF)
***REMOVED*** return false; ***REMOVED***
    const Complex_Selector* r_innermost = rhs->innermost();
    if (r_innermost->combinator() != Complex_Selector::ANCESTOR_OF)
***REMOVED*** return false; ***REMOVED***
    // more complex (i.e., longer) selectors are always more specific
    size_t l_len = lhs->length(), r_len = rhs->length();
    if (l_len > r_len)
***REMOVED*** return false; ***REMOVED***

    if (l_len == 1)
***REMOVED*** return lhs->head()->is_superselector_of(rhs->last()->head(), wrapping); ***REMOVED***

    // we have to look one tail deeper, since we cary the
    // combinator around for it (which is important here)
    if (rhs->tail() && lhs->tail() && combinator() != Complex_Selector::ANCESTOR_OF) ***REMOVED***
      Complex_Selector* lhs_tail = lhs->tail();
      Complex_Selector* rhs_tail = rhs->tail();
      if (lhs_tail->combinator() != rhs_tail->combinator()) return false;
      if (lhs_tail->head() && !rhs_tail->head()) return false;
      if (!lhs_tail->head() && rhs_tail->head()) return false;
      if (lhs_tail->head() && lhs_tail->head()) ***REMOVED***
        if (!lhs_tail->head()->is_superselector_of(rhs_tail->head())) return false;
  ***REMOVED***
***REMOVED***

    bool found = false;
    Complex_Selector* marker = rhs;
    for (size_t i = 0, L = rhs->length(); i < L; ++i) ***REMOVED***
      if (i == L-1)
  ***REMOVED*** return false; ***REMOVED***
      if (lhs->head() && marker->head() && lhs->head()->is_superselector_of(marker->head(), wrapping))
  ***REMOVED*** found = true; break; ***REMOVED***
      marker = marker->tail();
***REMOVED***
    if (!found)
***REMOVED*** return false; ***REMOVED***

    /*
      Hmm, I hope I have the logic right:

      if lhs has a combinator:
        if !(marker has a combinator) return false
        if !(lhs.combinator == '~' ? marker.combinator != '>' : lhs.combinator == marker.combinator) return false
        return lhs.tail-without-innermost.is_superselector_of(marker.tail-without-innermost)
      else if marker has a combinator:
        if !(marker.combinator == ">") return false
        return lhs.tail.is_superselector_of(marker.tail)
      else
        return lhs.tail.is_superselector_of(marker.tail)
    */
    if (lhs->combinator() != Complex_Selector::ANCESTOR_OF)
***REMOVED***
      if (marker->combinator() == Complex_Selector::ANCESTOR_OF)
  ***REMOVED*** return false; ***REMOVED***
      if (!(lhs->combinator() == Complex_Selector::PRECEDES ? marker->combinator() != Complex_Selector::PARENT_OF : lhs->combinator() == marker->combinator()))
  ***REMOVED*** return false; ***REMOVED***
      return lhs->tail()->is_superselector_of(marker->tail());
***REMOVED***
    else if (marker->combinator() != Complex_Selector::ANCESTOR_OF)
***REMOVED***
      if (marker->combinator() != Complex_Selector::PARENT_OF)
  ***REMOVED*** return false; ***REMOVED***
      return lhs->tail()->is_superselector_of(marker->tail());
***REMOVED***
    else
***REMOVED***
      return lhs->tail()->is_superselector_of(marker->tail());
***REMOVED***
    // catch-all
    return false;
  ***REMOVED***

  size_t Complex_Selector::length() const
  ***REMOVED***
    // TODO: make this iterative
    if (!tail()) return 1;
    return 1 + tail()->length();
  ***REMOVED***

  Complex_Selector* Complex_Selector::context(Context& ctx)
  ***REMOVED***
    if (!tail()) return 0;
    if (!head()) return tail()->context(ctx);
    Complex_Selector* cpy = SASS_MEMORY_NEW(ctx.mem, Complex_Selector, pstate(), combinator(), head(), tail()->context(ctx));
    cpy->media_block(media_block());
    return cpy;
  ***REMOVED***

  // append another complex selector at the end
  // check if we need to append some headers
  // then we need to check for the combinator
  // only then we can safely set the new tail
  void Complex_Selector::append(Context& ctx, Complex_Selector* ss)
  ***REMOVED***

    Complex_Selector* t = ss->tail();
    Combinator c = ss->combinator();
    String* r = ss->reference();
    Compound_Selector* h = ss->head();

    if (ss->has_line_feed()) has_line_feed(true);
    if (ss->has_line_break()) has_line_break(true);

    // append old headers
    if (h && h->length()) ***REMOVED***
      if (last()->combinator() != ANCESTOR_OF && c != ANCESTOR_OF) ***REMOVED***
        error("Invalid parent selector", pstate_);
  ***REMOVED*** else if (last()->head_ && last()->head_->length()) ***REMOVED***
        Compound_Selector* rh = last()->head();
        size_t i = 0, L = h->length();
        if (dynamic_cast<Type_Selector*>(h->first())) ***REMOVED***
          if (Selector_Qualifier* sq = dynamic_cast<Selector_Qualifier*>(rh->last())) ***REMOVED***
            Selector_Qualifier* sqs = new Selector_Qualifier(*sq);
            sqs->name(sqs->name() + (*h)[0]->name());
            (*rh)[rh->length()-1] = sqs;
            for (i = 1; i < L; ++i) *rh << (*h)[i];
  ***REMOVED*** else if (Type_Selector* ts = dynamic_cast<Type_Selector*>(rh->last())) ***REMOVED***
            Type_Selector* tss = new Type_Selector(*ts);
            tss->name(tss->name() + (*h)[0]->name());
            (*rh)[rh->length()-1] = tss;
            for (i = 1; i < L; ++i) *rh << (*h)[i];
  ***REMOVED*** else if (Selector_Placeholder* ps = dynamic_cast<Selector_Placeholder*>(rh->last())) ***REMOVED***
            Selector_Placeholder* pss = new Selector_Placeholder(*ps);
            pss->name(pss->name() + (*h)[0]->name());
            (*rh)[rh->length()-1] = pss;
            for (i = 1; i < L; ++i) *rh << (*h)[i];
  ***REMOVED*** else ***REMOVED***
            *last()->head_ += h;
  ***REMOVED***
***REMOVED*** else ***REMOVED***
          *last()->head_ += h;
***REMOVED***
  ***REMOVED*** else ***REMOVED***
        *last()->head_ += h;
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      // std::cerr << "has no or empty head\n";
***REMOVED***

    if (last()) ***REMOVED***
      if (last()->combinator() != ANCESTOR_OF && c != ANCESTOR_OF) ***REMOVED***
        Complex_Selector* inter = SASS_MEMORY_NEW(ctx.mem, Complex_Selector, pstate());
        inter->reference(r);
        inter->combinator(c);
        inter->tail(t);
        last()->tail(inter);
  ***REMOVED*** else ***REMOVED***
        if (last()->combinator() == ANCESTOR_OF) ***REMOVED***
          last()->combinator(c);
          last()->reference(r);
***REMOVED***
        last()->tail(t);
  ***REMOVED***
***REMOVED***


  ***REMOVED***

  Selector_List* Selector_List::parentize(Selector_List* ps, Context& ctx)
  ***REMOVED***
    Selector_List* ss = SASS_MEMORY_NEW(ctx.mem, Selector_List, pstate());
    for (size_t pi = 0, pL = ps->length(); pi < pL; ++pi) ***REMOVED***
      Selector_List* list = SASS_MEMORY_NEW(ctx.mem, Selector_List, pstate());
      *list << (*ps)[pi];
      for (size_t si = 0, sL = this->length(); si < sL; ++si) ***REMOVED***
        *ss += (*this)[si]->parentize(list, ctx);
  ***REMOVED***
***REMOVED***
    return ss;
  ***REMOVED***

  Selector_List* Complex_Selector::parentize(Selector_List* parents, Context& ctx)
  ***REMOVED***

    Complex_Selector* tail = this->tail();
    Compound_Selector* head = this->head();

    // first parentize the tail (which may return an expanded list)
    Selector_List* tails = tail ? tail->parentize(parents, ctx) : 0;

    if (head && head->length() > 0) ***REMOVED***

      // we have a parent selector in a simple compound list
      // mix parent complex selector into the compound list
      if (dynamic_cast<Parent_Selector*>((*head)[0])) ***REMOVED***
        if (parents && parents->length()) ***REMOVED***
          Selector_List* retval = SASS_MEMORY_NEW(ctx.mem, Selector_List, pstate());
          if (tails && tails->length() > 0) ***REMOVED***
            for (size_t n = 0, nL = tails->length(); n < nL; ++n) ***REMOVED***
              for (size_t i = 0, iL = parents->length(); i < iL; ++i) ***REMOVED***
                Complex_Selector* t = (*tails)[n];
                Complex_Selector* parent = (*parents)[i];
                Complex_Selector* s = parent->cloneFully(ctx);
                Complex_Selector* ss = this->clone(ctx);
                ss->tail(t ? t->clone(ctx) : 0);
                Compound_Selector* h = head_->clone(ctx);
                if (h->length()) h->erase(h->begin());
                ss->head(h->length() ? h : 0);
                s->append(ctx, ss);
                *retval << s;
  ***REMOVED***
***REMOVED***
  ***REMOVED***
          // have no tails but parents
          // loop above is inside out
          else ***REMOVED***
            for (size_t i = 0, iL = parents->length(); i < iL; ++i) ***REMOVED***
              Complex_Selector* parent = (*parents)[i];
              Complex_Selector* s = parent->cloneFully(ctx);
              Complex_Selector* ss = this->clone(ctx);
              // this is only if valid if the parent has no trailing op
              // otherwise we cannot append more simple selectors to head
              if (parent->last()->combinator() != ANCESTOR_OF) ***REMOVED***
                throw Exception::InvalidParent(parent, ss);
  ***REMOVED***
              ss->tail(tail ? tail->clone(ctx) : 0);
              Compound_Selector* h = head_->clone(ctx);
              if (h->length()) h->erase(h->begin());
              ss->head(h->length() ? h : 0);
              // \/ IMO ruby sass bug \/
              ss->has_line_feed(false);
              s->append(ctx, ss);
              *retval << s;
***REMOVED***
  ***REMOVED***
          return retval;
***REMOVED***
        // have no parent but some tails
        else ***REMOVED***
          Selector_List* retval = SASS_MEMORY_NEW(ctx.mem, Selector_List, pstate());
          if (tails && tails->length() > 0) ***REMOVED***
            for (size_t n = 0, nL = tails->length(); n < nL; ++n) ***REMOVED***
              Complex_Selector* cpy = this->clone(ctx);
              cpy->tail((*tails)[n]->cloneFully(ctx));
              cpy->head(SASS_MEMORY_NEW(ctx.mem, Compound_Selector, head->pstate()));
              for (size_t i = 1, L = this->head()->length(); i < L; ++i)
                *cpy->head() << (*this->head())[i];
              if (!cpy->head()->length()) cpy->head(0);
              *retval << cpy->skip_empty_reference();
***REMOVED***
  ***REMOVED***
          // have no parent nor tails
          else ***REMOVED***
            Complex_Selector* cpy = this->clone(ctx);
            cpy->head(SASS_MEMORY_NEW(ctx.mem, Compound_Selector, head->pstate()));
            for (size_t i = 1, L = this->head()->length(); i < L; ++i)
              *cpy->head() << (*this->head())[i];
            if (!cpy->head()->length()) cpy->head(0);
            *retval << cpy->skip_empty_reference();
  ***REMOVED***
          return retval;
***REMOVED***
  ***REMOVED***
      // no parent selector in head
      else ***REMOVED***
        return this->tails(ctx, tails);
  ***REMOVED***

***REMOVED***
    // has no head
    else ***REMOVED***
      return this->tails(ctx, tails);
***REMOVED***

    // unreachable
    return 0;
  ***REMOVED***

  Selector_List* Complex_Selector::tails(Context& ctx, Selector_List* tails)
  ***REMOVED***
    Selector_List* rv = SASS_MEMORY_NEW(ctx.mem, Selector_List, pstate_);
    if (tails && tails->length()) ***REMOVED***
      for (size_t i = 0, iL = tails->length(); i < iL; ++i) ***REMOVED***
        Complex_Selector* pr = this->clone(ctx);
        pr->tail((*tails)[i]);
        *rv << pr;
  ***REMOVED***
***REMOVED***
    else ***REMOVED***
      *rv << this;
***REMOVED***
    return rv;
  ***REMOVED***

  // return the last tail that is defined
  Complex_Selector* Complex_Selector::first()
  ***REMOVED***
    // declare variables used in loop
    Complex_Selector* cur = this->tail_;
    const Compound_Selector* head = head_;
    // processing loop
    while (cur)
***REMOVED***
      // get the head
      head = cur->head_;
      // check for single parent ref
      if (head && head->length() == 1)
  ***REMOVED***
        // abort (and return) if it is not a parent selector
        if (!dynamic_cast<Parent_Selector*>((*head)[0])) break;
  ***REMOVED***
      // advance to next
      cur = cur->tail_;
***REMOVED***
    // result
    return cur;
  ***REMOVED***

  // return the last tail that is defined
  const Complex_Selector* Complex_Selector::first() const
  ***REMOVED***
    // declare variables used in loop
    const Complex_Selector* cur = this->tail_;
    const Compound_Selector* head = head_;
    // processing loop
    while (cur)
***REMOVED***
      // get the head
      head = cur->head_;
      // check for single parent ref
      if (head && head->length() == 1)
  ***REMOVED***
        // abort (and return) if it is not a parent selector
        if (!dynamic_cast<Parent_Selector*>((*head)[0])) break;
  ***REMOVED***
      // advance to next
      cur = cur->tail_;
***REMOVED***
    // result
    return cur;
  ***REMOVED***

  // return the last tail that is defined
  Complex_Selector* Complex_Selector::last()
  ***REMOVED***
    // ToDo: implement with a while loop
    return tail_? tail_->last() : this;
  ***REMOVED***

  // return the last tail that is defined
  const Complex_Selector* Complex_Selector::last() const
  ***REMOVED***
    // ToDo: implement with a while loop
    return tail_? tail_->last() : this;
  ***REMOVED***


  Complex_Selector::Combinator Complex_Selector::clear_innermost()
  ***REMOVED***
    Combinator c;
    if (!tail() || tail()->tail() == 0)
***REMOVED*** c = combinator(); combinator(ANCESTOR_OF); tail(0); ***REMOVED***
    else
***REMOVED*** c = tail()->clear_innermost(); ***REMOVED***
    return c;
  ***REMOVED***

  void Complex_Selector::set_innermost(Complex_Selector* val, Combinator c)
  ***REMOVED***
    if (!tail())
***REMOVED*** tail(val); combinator(c); ***REMOVED***
    else
***REMOVED*** tail()->set_innermost(val, c); ***REMOVED***
  ***REMOVED***

  Complex_Selector* Complex_Selector::clone(Context& ctx) const
  ***REMOVED***
    Complex_Selector* cpy = SASS_MEMORY_NEW(ctx.mem, Complex_Selector, *this);
    cpy->media_block(this->media_block());
    if (tail()) cpy->tail(tail()->clone(ctx));
    return cpy;
  ***REMOVED***

  Complex_Selector* Complex_Selector::cloneFully(Context& ctx) const
  ***REMOVED***
    Complex_Selector* cpy = SASS_MEMORY_NEW(ctx.mem, Complex_Selector, *this);

    if (head()) ***REMOVED***
      cpy->head(head()->clone(ctx));
***REMOVED***

    if (tail()) ***REMOVED***
      cpy->tail(tail()->cloneFully(ctx));
***REMOVED***

    return cpy;
  ***REMOVED***

  Compound_Selector* Compound_Selector::clone(Context& ctx) const
  ***REMOVED***
    Compound_Selector* cpy = SASS_MEMORY_NEW(ctx.mem, Compound_Selector, *this);
    cpy->media_block(this->media_block());
    return cpy;
  ***REMOVED***

  Selector_List* Selector_List::clone(Context& ctx) const
  ***REMOVED***
    Selector_List* cpy = SASS_MEMORY_NEW(ctx.mem, Selector_List, *this);
    cpy->media_block(this->media_block());
    return cpy;
  ***REMOVED***

  Selector_List* Selector_List::cloneFully(Context& ctx) const
  ***REMOVED***
    Selector_List* cpy = SASS_MEMORY_NEW(ctx.mem, Selector_List, pstate());
    for (size_t i = 0, L = length(); i < L; ++i) ***REMOVED***
      *cpy << (*this)[i]->cloneFully(ctx);
***REMOVED***
    return cpy;
  ***REMOVED***

  /* not used anymore - remove?
  Selector_Placeholder* Selector::find_placeholder()
  ***REMOVED***
    return 0;
  ***REMOVED****/

  // remove parent selector references
  // basically unwraps parsed selectors
  void Selector_List::remove_parent_selectors()
  ***REMOVED***
    // Check every rhs selector against left hand list
    for(size_t i = 0, L = length(); i < L; ++i) ***REMOVED***
      if (!(*this)[i]->head()) continue;
      if ((*this)[i]->head()->is_empty_reference()) ***REMOVED***
        // simply move to the next tail if we have "no" combinator
        if ((*this)[i]->combinator() == Complex_Selector::ANCESTOR_OF) ***REMOVED***
          if ((*this)[i]->tail() && (*this)[i]->has_line_feed()) ***REMOVED***
            (*this)[i]->tail()->has_line_feed(true);
  ***REMOVED***
          (*this)[i] = (*this)[i]->tail();
***REMOVED***
        // otherwise remove the first item from head
        else ***REMOVED***
          (*this)[i]->head()->erase((*this)[i]->head()->begin());
***REMOVED***
  ***REMOVED***
***REMOVED***
  ***REMOVED***

  void Selector_List::adjust_after_pushing(Complex_Selector* c)
  ***REMOVED***
    if (c->has_reference())   has_reference(true);
  ***REMOVED***

  // it's a superselector if every selector of the right side
  // list is a superselector of the given left side selector
  bool Complex_Selector::is_superselector_of(Selector_List *sub, std::string wrapping)
  ***REMOVED***
    // Check every rhs selector against left hand list
    for(size_t i = 0, L = sub->length(); i < L; ++i) ***REMOVED***
      if (!is_superselector_of((*sub)[i], wrapping)) return false;
***REMOVED***
    return true;
  ***REMOVED***

  // it's a superselector if every selector of the right side
  // list is a superselector of the given left side selector
  bool Selector_List::is_superselector_of(Selector_List *sub, std::string wrapping)
  ***REMOVED***
    // Check every rhs selector against left hand list
    for(size_t i = 0, L = sub->length(); i < L; ++i) ***REMOVED***
      if (!is_superselector_of((*sub)[i], wrapping)) return false;
***REMOVED***
    return true;
  ***REMOVED***

  // it's a superselector if every selector on the right side
  // is a superselector of any one of the left side selectors
  bool Selector_List::is_superselector_of(Compound_Selector *sub, std::string wrapping)
  ***REMOVED***
    // Check every lhs selector against right hand
    for(size_t i = 0, L = length(); i < L; ++i) ***REMOVED***
      if ((*this)[i]->is_superselector_of(sub, wrapping)) return true;
***REMOVED***
    return false;
  ***REMOVED***

  // it's a superselector if every selector on the right side
  // is a superselector of any one of the left side selectors
  bool Selector_List::is_superselector_of(Complex_Selector *sub, std::string wrapping)
  ***REMOVED***
    // Check every lhs selector against right hand
    for(size_t i = 0, L = length(); i < L; ++i) ***REMOVED***
      if ((*this)[i]->is_superselector_of(sub)) return true;
***REMOVED***
    return false;
  ***REMOVED***

  Selector_List* Selector_List::unify_with(Selector_List* rhs, Context& ctx) ***REMOVED***
    std::vector<Complex_Selector*> unified_complex_selectors;
    // Unify all of children with RHS's children, storing the results in `unified_complex_selectors`
    for (size_t lhs_i = 0, lhs_L = length(); lhs_i < lhs_L; ++lhs_i) ***REMOVED***
      Complex_Selector* seq1 = (*this)[lhs_i];
      for(size_t rhs_i = 0, rhs_L = rhs->length(); rhs_i < rhs_L; ++rhs_i) ***REMOVED***
        Complex_Selector* seq2 = (*rhs)[rhs_i];

        Selector_List* result = seq1->unify_with(seq2, ctx);
        if( result ) ***REMOVED***
          for(size_t i = 0, L = result->length(); i < L; ++i) ***REMOVED***
            unified_complex_selectors.push_back( (*result)[i] );
  ***REMOVED***
***REMOVED***
  ***REMOVED***
***REMOVED***

    // Creates the final Selector_List by combining all the complex selectors
    Selector_List* final_result = SASS_MEMORY_NEW(ctx.mem, Selector_List, pstate());
    for (auto itr = unified_complex_selectors.begin(); itr != unified_complex_selectors.end(); ++itr) ***REMOVED***
      *final_result << *itr;
***REMOVED***
    return final_result;
  ***REMOVED***

  void Selector_List::populate_extends(Selector_List* extendee, Context& ctx, ExtensionSubsetMap& extends) ***REMOVED***
    To_String to_string;

    Selector_List* extender = this;
    for (auto complex_sel : extendee->elements()) ***REMOVED***
      Complex_Selector* c = complex_sel;


      // Ignore any parent selectors, until we find the first non Selector_Reference head
      Compound_Selector* compound_sel = c->head();
      Complex_Selector* pIter = complex_sel;
      while (pIter) ***REMOVED***
        Compound_Selector* pHead = pIter->head();
        if (pHead && dynamic_cast<Parent_Selector*>(pHead->elements()[0]) == NULL) ***REMOVED***
          compound_sel = pHead;
          break;
***REMOVED***

        pIter = pIter->tail();
  ***REMOVED***

      if (!pIter->head() || pIter->tail()) ***REMOVED***
        error("nested selectors may not be extended", c->pstate());
  ***REMOVED***

      compound_sel->is_optional(extendee->is_optional());

      for (size_t i = 0, L = extender->length(); i < L; ++i) ***REMOVED***
        extends.put(compound_sel->to_str_vec(), std::make_pair((*extender)[i], compound_sel));
  ***REMOVED***
***REMOVED***
  ***REMOVED***;

  std::vector<std::string> Compound_Selector::to_str_vec()
  ***REMOVED***
    To_String to_string;
    std::vector<std::string> result;
    result.reserve(length());
    for (size_t i = 0, L = length(); i < L; ++i)
***REMOVED*** result.push_back((*this)[i]->perform(&to_string)); ***REMOVED***
    return result;
  ***REMOVED***

  Compound_Selector* Compound_Selector::minus(Compound_Selector* rhs, Context& ctx)
  ***REMOVED***
    To_String to_string(&ctx);
    Compound_Selector* result = SASS_MEMORY_NEW(ctx.mem, Compound_Selector, pstate());
    // result->has_parent_reference(has_parent_reference());

    // not very efficient because it needs to preserve order
    for (size_t i = 0, L = length(); i < L; ++i)
***REMOVED***
      bool found = false;
      std::string thisSelector((*this)[i]->perform(&to_string));
      for (size_t j = 0, M = rhs->length(); j < M; ++j)
  ***REMOVED***
        if (thisSelector == (*rhs)[j]->perform(&to_string))
***REMOVED***
          found = true;
          break;
***REMOVED***
  ***REMOVED***
      if (!found) (*result) << (*this)[i];
***REMOVED***

    return result;
  ***REMOVED***

  void Compound_Selector::mergeSources(SourcesSet& sources, Context& ctx)
  ***REMOVED***
    for (SourcesSet::iterator iterator = sources.begin(), endIterator = sources.end(); iterator != endIterator; ++iterator) ***REMOVED***
      this->sources_.insert((*iterator)->clone(ctx));
***REMOVED***
  ***REMOVED***

  void Arguments::adjust_after_pushing(Argument* a)
  ***REMOVED***
    if (!a->name().empty()) ***REMOVED***
      if (/* has_rest_argument_ || */ has_keyword_argument_) ***REMOVED***
        error("named arguments must precede variable-length argument", a->pstate());
  ***REMOVED***
      has_named_arguments_ = true;
***REMOVED***
    else if (a->is_rest_argument()) ***REMOVED***
      if (has_rest_argument_) ***REMOVED***
        error("functions and mixins may only be called with one variable-length argument", a->pstate());
  ***REMOVED***
      if (has_keyword_argument_) ***REMOVED***
        error("only keyword arguments may follow variable arguments", a->pstate());
  ***REMOVED***
      has_rest_argument_ = true;
***REMOVED***
    else if (a->is_keyword_argument()) ***REMOVED***
      if (has_keyword_argument_) ***REMOVED***
        error("functions and mixins may only be called with one keyword argument", a->pstate());
  ***REMOVED***
      has_keyword_argument_ = true;
***REMOVED***
    else ***REMOVED***
      if (has_rest_argument_) ***REMOVED***
        error("ordinal arguments must precede variable-length arguments", a->pstate());
  ***REMOVED***
      if (has_named_arguments_) ***REMOVED***
        error("ordinal arguments must precede named arguments", a->pstate());
  ***REMOVED***
***REMOVED***
  ***REMOVED***

  bool Ruleset::is_invisible() const ***REMOVED***
    Selector_List* sl = static_cast<Selector_List*>(selector());
    for (size_t i = 0, L = sl->length(); i < L; ++i)
      if (!(*sl)[i]->has_placeholder()) return false;
    return true;
  ***REMOVED***

  bool Media_Block::is_invisible() const ***REMOVED***
    for (size_t i = 0, L = block()->length(); i < L; ++i) ***REMOVED***
      if (!(*block())[i]->is_invisible()) return false;
***REMOVED***
    return true;
  ***REMOVED***

  Number::Number(ParserState pstate, double val, std::string u, bool zero)
  : Value(pstate),
    value_(val),
    zero_(zero),
    numerator_units_(std::vector<std::string>()),
    denominator_units_(std::vector<std::string>()),
    hash_(0)
  ***REMOVED***
    size_t l = 0, r = 0;
    if (!u.empty()) ***REMOVED***
      bool nominator = true;
      while (true) ***REMOVED***
        r = u.find_first_of("*/", l);
        std::string unit(u.substr(l, r == std::string::npos ? r : r - l));
        if (!unit.empty()) ***REMOVED***
          if (nominator) numerator_units_.push_back(unit);
          else denominator_units_.push_back(unit);
***REMOVED***
        if (r == std::string::npos) break;
        // ToDo: should error for multiple slashes
        // if (!nominator && u[r] == '/') error(...)
        if (u[r] == '/')
          nominator = false;
        l = r + 1;
  ***REMOVED***
***REMOVED***
    concrete_type(NUMBER);
  ***REMOVED***

  std::string Number::unit() const
  ***REMOVED***
    std::string u;
    for (size_t i = 0, S = numerator_units_.size(); i < S; ++i) ***REMOVED***
      if (i) u += '*';
      u += numerator_units_[i];
***REMOVED***
    if (!denominator_units_.empty()) u += '/';
    for (size_t i = 0, S = denominator_units_.size(); i < S; ++i) ***REMOVED***
      if (i) u += '*';
      u += denominator_units_[i];
***REMOVED***
    return u;
  ***REMOVED***

  bool Number::is_unitless()
  ***REMOVED*** return numerator_units_.empty() && denominator_units_.empty(); ***REMOVED***

  void Number::normalize(const std::string& prefered, bool strict)
  ***REMOVED***

    // first make sure same units cancel each other out
    // it seems that a map table will fit nicely to do this
    // we basically construct exponents for each unit
    // has the advantage that they will be pre-sorted
    std::map<std::string, int> exponents;

    // initialize by summing up occurences in unit vectors
    for (size_t i = 0, S = numerator_units_.size(); i < S; ++i) ++ exponents[numerator_units_[i]];
    for (size_t i = 0, S = denominator_units_.size(); i < S; ++i) -- exponents[denominator_units_[i]];

    // the final conversion factor
    double factor = 1;

    // get the first entry of numerators
    // forward it when entry is converted
    std::vector<std::string>::iterator nom_it = numerator_units_.begin();
    std::vector<std::string>::iterator nom_end = numerator_units_.end();
    std::vector<std::string>::iterator denom_it = denominator_units_.begin();
    std::vector<std::string>::iterator denom_end = denominator_units_.end();

    // main normalization loop
    // should be close to optimal
    while (denom_it != denom_end)
***REMOVED***
      // get and increment afterwards
      const std::string denom = *(denom_it ++);
      // skip already canceled out unit
      if (exponents[denom] >= 0) continue;
      // skip all units we don't know how to convert
      if (string_to_unit(denom) == UNKNOWN) continue;
      // now search for nominator
      while (nom_it != nom_end)
  ***REMOVED***
        // get and increment afterwards
        const std::string nom = *(nom_it ++);
        // skip already canceled out unit
        if (exponents[nom] <= 0) continue;
        // skip all units we don't know how to convert
        if (string_to_unit(nom) == UNKNOWN) continue;
        // we now have two convertable units
        // add factor for current conversion
        factor *= conversion_factor(nom, denom, strict);
        // update nominator/denominator exponent
        -- exponents[nom]; ++ exponents[denom];
        // inner loop done
        break;
  ***REMOVED***
***REMOVED***

    // now we can build up the new unit arrays
    numerator_units_.clear();
    denominator_units_.clear();

    // build them by iterating over the exponents
    for (auto exp : exponents)
***REMOVED***
      // maybe there is more effecient way to push
      // the same item multiple times to a vector?
      for(size_t i = 0, S = abs(exp.second); i < S; ++i)
  ***REMOVED***
        // opted to have these switches in the inner loop
        // makes it more readable and should not cost much
        if (!exp.first.empty()) ***REMOVED***
          if (exp.second < 0) denominator_units_.push_back(exp.first);
          else if (exp.second > 0) numerator_units_.push_back(exp.first);
***REMOVED***
  ***REMOVED***
***REMOVED***

    // apply factor to value_
    // best precision this way
    value_ *= factor;

    // maybe convert to other unit
    // easier implemented on its own
    try ***REMOVED*** convert(prefered, strict); ***REMOVED***
    catch (incompatibleUnits& err)
***REMOVED*** error(err.what(), pstate()); ***REMOVED***
    catch (...) ***REMOVED*** throw; ***REMOVED***

  ***REMOVED***

  void Number::convert(const std::string& prefered, bool strict)
  ***REMOVED***
    // abort if unit is empty
    if (prefered.empty()) return;

    // first make sure same units cancel each other out
    // it seems that a map table will fit nicely to do this
    // we basically construct exponents for each unit
    // has the advantage that they will be pre-sorted
    std::map<std::string, int> exponents;

    // initialize by summing up occurences in unit vectors
    for (size_t i = 0, S = numerator_units_.size(); i < S; ++i) ++ exponents[numerator_units_[i]];
    for (size_t i = 0, S = denominator_units_.size(); i < S; ++i) -- exponents[denominator_units_[i]];

    // the final conversion factor
    double factor = 1;

    std::vector<std::string>::iterator denom_it = denominator_units_.begin();
    std::vector<std::string>::iterator denom_end = denominator_units_.end();

    // main normalization loop
    // should be close to optimal
    while (denom_it != denom_end)
***REMOVED***
      // get and increment afterwards
      const std::string denom = *(denom_it ++);
      // check if conversion is needed
      if (denom == prefered) continue;
      // skip already canceled out unit
      if (exponents[denom] >= 0) continue;
      // skip all units we don't know how to convert
      if (string_to_unit(denom) == UNKNOWN) continue;
      // we now have two convertable units
      // add factor for current conversion
      factor *= conversion_factor(denom, prefered, strict);
      // update nominator/denominator exponent
      ++ exponents[denom]; -- exponents[prefered];
***REMOVED***

    std::vector<std::string>::iterator nom_it = numerator_units_.begin();
    std::vector<std::string>::iterator nom_end = numerator_units_.end();

    // now search for nominator
    while (nom_it != nom_end)
***REMOVED***
      // get and increment afterwards
      const std::string nom = *(nom_it ++);
      // check if conversion is needed
      if (nom == prefered) continue;
      // skip already canceled out unit
      if (exponents[nom] <= 0) continue;
      // skip all units we don't know how to convert
      if (string_to_unit(nom) == UNKNOWN) continue;
      // we now have two convertable units
      // add factor for current conversion
      factor *= conversion_factor(nom, prefered, strict);
      // update nominator/denominator exponent
      -- exponents[nom]; ++ exponents[prefered];
***REMOVED***

    // now we can build up the new unit arrays
    numerator_units_.clear();
    denominator_units_.clear();

    // build them by iterating over the exponents
    for (auto exp : exponents)
***REMOVED***
      // maybe there is more effecient way to push
      // the same item multiple times to a vector?
      for(size_t i = 0, S = abs(exp.second); i < S; ++i)
  ***REMOVED***
        // opted to have these switches in the inner loop
        // makes it more readable and should not cost much
        if (!exp.first.empty()) ***REMOVED***
          if (exp.second < 0) denominator_units_.push_back(exp.first);
          else if (exp.second > 0) numerator_units_.push_back(exp.first);
***REMOVED***
  ***REMOVED***
***REMOVED***

    // apply factor to value_
    // best precision this way
    value_ *= factor;

  ***REMOVED***

  // useful for making one number compatible with another
  std::string Number::find_convertible_unit() const
  ***REMOVED***
    for (size_t i = 0, S = numerator_units_.size(); i < S; ++i) ***REMOVED***
      std::string u(numerator_units_[i]);
      if (string_to_unit(u) != UNKNOWN) return u;
***REMOVED***
    for (size_t i = 0, S = denominator_units_.size(); i < S; ++i) ***REMOVED***
      std::string u(denominator_units_[i]);
      if (string_to_unit(u) != UNKNOWN) return u;
***REMOVED***
    return std::string();
  ***REMOVED***

  bool Custom_Warning::operator== (const Expression& rhs) const
  ***REMOVED***
    if (const Custom_Warning* r = dynamic_cast<const Custom_Warning*>(&rhs)) ***REMOVED***
      return message() == r->message();
***REMOVED***
    return false;
  ***REMOVED***

  bool Custom_Error::operator== (const Expression& rhs) const
  ***REMOVED***
    if (const Custom_Error* r = dynamic_cast<const Custom_Error*>(&rhs)) ***REMOVED***
      return message() == r->message();
***REMOVED***
    return false;
  ***REMOVED***

  bool Number::operator== (const Expression& rhs) const
  ***REMOVED***
    if (const Number* r = dynamic_cast<const Number*>(&rhs)) ***REMOVED***
      return (numerator_units_ == r->numerator_units_) &&
             (denominator_units_ == r->denominator_units_) &&
             std::fabs(value() - r->value()) < NUMBER_EPSILON;
***REMOVED***
    return false;
  ***REMOVED***

  bool Number::operator< (const Number& rhs) const
  ***REMOVED***
    Number tmp_r(rhs);
    tmp_r.normalize(find_convertible_unit());
    std::string l_unit(unit());
    std::string r_unit(tmp_r.unit());
    if (!l_unit.empty() && !r_unit.empty() && unit() != tmp_r.unit()) ***REMOVED***
      error("cannot compare numbers with incompatible units", pstate());
***REMOVED***
    return value() < tmp_r.value();
  ***REMOVED***

  bool String_Quoted::operator== (const Expression& rhs) const
  ***REMOVED***
    if (const String_Quoted* qstr = dynamic_cast<const String_Quoted*>(&rhs)) ***REMOVED***
      return (value() == qstr->value());
***REMOVED*** else if (const String_Constant* cstr = dynamic_cast<const String_Constant*>(&rhs)) ***REMOVED***
      return (value() == cstr->value());
***REMOVED***
    return false;
  ***REMOVED***

  bool String_Constant::operator== (const Expression& rhs) const
  ***REMOVED***
    if (const String_Quoted* qstr = dynamic_cast<const String_Quoted*>(&rhs)) ***REMOVED***
      return (value() == qstr->value());
***REMOVED*** else if (const String_Constant* cstr = dynamic_cast<const String_Constant*>(&rhs)) ***REMOVED***
      return (value() == cstr->value());
***REMOVED***
    return false;
  ***REMOVED***

  bool String_Schema::operator== (const Expression& rhs) const
  ***REMOVED***
    if (const String_Schema* r = dynamic_cast<const String_Schema*>(&rhs)) ***REMOVED***
      if (length() != r->length()) return false;
      for (size_t i = 0, L = length(); i < L; ++i) ***REMOVED***
        Expression* rv = (*r)[i];
        Expression* lv = (*this)[i];
        if (!lv || !rv) return false;
        if (!(*lv == *rv)) return false;
  ***REMOVED***
      return true;
***REMOVED***
    return false;
  ***REMOVED***

  bool Boolean::operator== (const Expression& rhs) const
  ***REMOVED***
    if (const Boolean* r = dynamic_cast<const Boolean*>(&rhs)) ***REMOVED***
      return (value() == r->value());
***REMOVED***
    return false;
  ***REMOVED***

  bool Color::operator== (const Expression& rhs) const
  ***REMOVED***
    if (const Color* r = dynamic_cast<const Color*>(&rhs)) ***REMOVED***
      return r_ == r->r() &&
             g_ == r->g() &&
             b_ == r->b() &&
             a_ == r->a();
***REMOVED***
    return false;
  ***REMOVED***

  bool List::operator== (const Expression& rhs) const
  ***REMOVED***
    if (const List* r = dynamic_cast<const List*>(&rhs)) ***REMOVED***
      if (length() != r->length()) return false;
      if (separator() != r->separator()) return false;
      for (size_t i = 0, L = length(); i < L; ++i) ***REMOVED***
        Expression* rv = (*r)[i];
        Expression* lv = (*this)[i];
        if (!lv || !rv) return false;
        if (!(*lv == *rv)) return false;
  ***REMOVED***
      return true;
***REMOVED***
    return false;
  ***REMOVED***

  bool Map::operator== (const Expression& rhs) const
  ***REMOVED***
    if (const Map* r = dynamic_cast<const Map*>(&rhs)) ***REMOVED***
      if (length() != r->length()) return false;
      for (auto key : keys()) ***REMOVED***
        Expression* lv = at(key);
        Expression* rv = r->at(key);
        if (!rv || !lv) return false;
        if (!(*lv == *rv)) return false;
  ***REMOVED***
      return true;
***REMOVED***
    return false;
  ***REMOVED***

  bool Null::operator== (const Expression& rhs) const
  ***REMOVED***
    return rhs.concrete_type() == NULL_VAL;
  ***REMOVED***

  size_t List::size() const ***REMOVED***
    if (!is_arglist_) return length();
    // arglist expects a list of arguments
    // so we need to break before keywords
    for (size_t i = 0, L = length(); i < L; ++i) ***REMOVED***
      if (Argument* arg = dynamic_cast<Argument*>((*this)[i])) ***REMOVED***
        if (!arg->name().empty()) return i;
  ***REMOVED***
***REMOVED***
    return length();
  ***REMOVED***

  Expression* Hashed::at(Expression* k) const
  ***REMOVED***
    if (elements_.count(k))
***REMOVED*** return elements_.at(k); ***REMOVED***
    else ***REMOVED*** return &sass_null; ***REMOVED***
  ***REMOVED***

  std::string Map::to_string(bool compressed, int precision) const
  ***REMOVED***
    std::string res("");
    if (empty()) return res;
    if (is_invisible()) return res;
    bool items_output = false;
    for (auto key : keys()) ***REMOVED***
      if (key->is_invisible()) continue;
      if (at(key)->is_invisible()) continue;
      if (items_output) res += compressed ? "," : ", ";
      Value* v_key = dynamic_cast<Value*>(key);
      Value* v_val = dynamic_cast<Value*>(at(key));
      if (v_key) res += v_key->to_string(compressed, precision);
      res += compressed ? ":" : ": ";
      if (v_val) res += v_val->to_string(compressed, precision);
      items_output = true;
***REMOVED***
    return res;
  ***REMOVED***

  std::string List::to_string(bool compressed, int precision) const
  ***REMOVED***
    std::string res("");
    if (empty()) return res;
    if (is_invisible()) return res;
    bool items_output = false;
    std::string sep = separator() == SASS_COMMA ? "," : " ";
    if (!compressed && sep == ",") sep += " ";
    for (size_t i = 0, L = size(); i < L; ++i) ***REMOVED***
      Expression* item = (*this)[i];
      if (item->is_invisible()) continue;
      if (items_output) res += sep;
      if (Value* v_val = dynamic_cast<Value*>(item))
  ***REMOVED*** res += v_val->to_string(compressed, precision); ***REMOVED***
      items_output = true;
***REMOVED***
    return res;
  ***REMOVED***

  std::string String_Schema::to_string(bool compressed, int precision) const
  ***REMOVED***
    std::string res("");
    for (size_t i = 0, L = length(); i < L; ++i) ***REMOVED***
      if ((*this)[i]->is_interpolant()) res += "#***REMOVED***";
      if (Value* val = dynamic_cast<Value*>((*this)[i]))
  ***REMOVED*** res += val->to_string(compressed, precision); ***REMOVED***
      if ((*this)[i]->is_interpolant()) res += "***REMOVED***";
***REMOVED***
    return res;
  ***REMOVED***

  std::string Null::to_string(bool compressed, int precision) const
  ***REMOVED***
    return "null";
  ***REMOVED***

  std::string Boolean::to_string(bool compressed, int precision) const
  ***REMOVED***
    return value_ ? "true" : "false";
  ***REMOVED***

  // helper function for serializing colors
  template <size_t range>
  static double cap_channel(double c) ***REMOVED***
    if      (c > range) return range;
    else if (c < 0)     return 0;
    else                return c;
  ***REMOVED***

  std::string Color::to_string(bool compressed, int precision) const
  ***REMOVED***
    std::stringstream ss;

    // original color name
    // maybe an unknown token
    std::string name = disp();

    // resolved color
    std::string res_name = name;

    double r = Sass::round(cap_channel<0xff>(r_));
    double g = Sass::round(cap_channel<0xff>(g_));
    double b = Sass::round(cap_channel<0xff>(b_));
    double a = cap_channel<1>   (a_);

    // get color from given name (if one was given at all)
    if (name != "" && name_to_color(name)) ***REMOVED***
      const Color* n = name_to_color(name);
      r = Sass::round(cap_channel<0xff>(n->r()));
      g = Sass::round(cap_channel<0xff>(n->g()));
      b = Sass::round(cap_channel<0xff>(n->b()));
      a = cap_channel<1>   (n->a());
***REMOVED***
    // otherwise get the possible resolved color name
    else ***REMOVED***
      double numval = r * 0x10000 + g * 0x100 + b;
      if (color_to_name(numval))
        res_name = color_to_name(numval);
***REMOVED***

    std::stringstream hexlet;
    hexlet << '#' << std::setw(1) << std::setfill('0');
    // create a short color hexlet if there is any need for it
    if (compressed && is_color_doublet(r, g, b) && a == 1) ***REMOVED***
      hexlet << std::hex << std::setw(1) << (static_cast<unsigned long>(r) >> 4);
      hexlet << std::hex << std::setw(1) << (static_cast<unsigned long>(g) >> 4);
      hexlet << std::hex << std::setw(1) << (static_cast<unsigned long>(b) >> 4);
***REMOVED*** else ***REMOVED***
      hexlet << std::hex << std::setw(2) << static_cast<unsigned long>(r);
      hexlet << std::hex << std::setw(2) << static_cast<unsigned long>(g);
      hexlet << std::hex << std::setw(2) << static_cast<unsigned long>(b);
***REMOVED***

    if (compressed && !this->is_delayed()) name = "";

    // retain the originally specified color definition if unchanged
    if (name != "") ***REMOVED***
      ss << name;
***REMOVED***
    else if (r == 0 && g == 0 && b == 0 && a == 0) ***REMOVED***
        ss << "transparent";
***REMOVED***
    else if (a >= 1) ***REMOVED***
      if (res_name != "") ***REMOVED***
        if (compressed && hexlet.str().size() < res_name.size()) ***REMOVED***
          ss << hexlet.str();
***REMOVED*** else ***REMOVED***
          ss << res_name;
***REMOVED***
  ***REMOVED***
      else ***REMOVED***
        ss << hexlet.str();
  ***REMOVED***
***REMOVED***
    else ***REMOVED***
      ss << "rgba(";
      ss << static_cast<unsigned long>(r) << ",";
      if (!compressed) ss << " ";
      ss << static_cast<unsigned long>(g) << ",";
      if (!compressed) ss << " ";
      ss << static_cast<unsigned long>(b) << ",";
      if (!compressed) ss << " ";
      ss << a << ')';
***REMOVED***

    return ss.str();

  ***REMOVED***

  std::string Number::to_string(bool compressed, int precision) const
  ***REMOVED***

    std::string res;

    // check if the fractional part of the value equals to zero
    // neat trick from http://stackoverflow.com/a/1521682/1550314
    // double int_part; bool is_int = modf(value, &int_part) == 0.0;

    // this all cannot be done with one run only, since fixed
    // output differs from normal output and regular output
    // can contain scientific notation which we do not want!

    // first sample
    std::stringstream ss;
    ss.precision(12);
    ss << value_;

    // check if we got scientific notation in result
    if (ss.str().find_first_of("e") != std::string::npos) ***REMOVED***
      ss.clear(); ss.str(std::string());
      ss.precision(std::max(12, precision));
      ss << std::fixed << value_;
***REMOVED***

    std::string tmp = ss.str();
    size_t pos_point = tmp.find_first_of(".,");
    size_t pos_fract = tmp.find_last_not_of("0");
    bool is_int = pos_point == pos_fract ||
                  pos_point == std::string::npos;

    // reset stream for another run
    ss.clear(); ss.str(std::string());

    // take a shortcut for integers
    if (is_int)
***REMOVED***
      ss.precision(0);
      ss << std::fixed << value_;
      res = std::string(ss.str());
***REMOVED***
    // process floats
    else
***REMOVED***
      // do we have have too much precision?
      if (pos_fract < precision + pos_point)
  ***REMOVED*** precision = (int)(pos_fract - pos_point); ***REMOVED***
      // round value again
      ss.precision(precision);
      ss << std::fixed << value_;
      res = std::string(ss.str());
      // maybe we truncated up to decimal point
      size_t pos = res.find_last_not_of("0");
      bool at_dec_point = res[pos] == '.' ||
                          res[pos] == ',';
      // don't leave a blank point
      if (at_dec_point) ++ pos;
      res.resize (pos + 1);
***REMOVED***

    // some final cosmetics
    if (res == "-0.0") res.erase(0, 1);
    else if (res == "-0") res.erase(0, 1);
    else if (res == "") res = "0";

    // add unit now
    res += unit();

    // and return
    return res;

  ***REMOVED***

  std::string String_Quoted::to_string(bool compressed, int precision) const
  ***REMOVED***
    return quote_mark_ ? quote(value_, quote_mark_, true) : value_;
  ***REMOVED***

  std::string String_Constant::to_string(bool compressed, int precision) const
  ***REMOVED***
    return quote_mark_ ? quote(value_, quote_mark_, true) : value_;
  ***REMOVED***

  std::string Custom_Error::to_string(bool compressed, int precision) const
  ***REMOVED***
    return message();
  ***REMOVED***
  std::string Custom_Warning::to_string(bool compressed, int precision) const
  ***REMOVED***
    return message();
  ***REMOVED***

  std::string Selector_List::to_string(bool compressed, int precision) const
  ***REMOVED***
    std::string str("");
    auto end = this->end();
    auto start = this->begin();
    while (start < end && *start) ***REMOVED***
      Complex_Selector* sel = *start;
      if (!str.empty()) str += ", ";
      str += sel->to_string(compressed, precision);
      ++ start;
***REMOVED***
    return str;
  ***REMOVED***

  std::string Compound_Selector::to_string(bool compressed, int precision) const
  ***REMOVED***
    std::string str("");
    auto end = this->end();
    auto start = this->begin();
    while (start < end && *start) ***REMOVED***
      Simple_Selector* sel = *start;
      str += sel->to_string(compressed, precision);
      ++ start;
***REMOVED***
    return str;
  ***REMOVED***

  std::string Complex_Selector::to_string(bool compressed, int precision) const
  ***REMOVED***
    // first render head and tail if they are available
    std::string str_head(head() ? head()->to_string(compressed, precision) : "");
    std::string str_tail(tail() ? tail()->to_string(compressed, precision) : "");
    std::string str_ref(reference() ? reference()->to_string(compressed, precision) : "");
    // combinator in between
    std::string str_op("");
    // use a switch statement
    switch (combinator()) ***REMOVED***
      case ANCESTOR_OF: str_op = " "; break;
      case PARENT_OF:   str_op = ">"; break;
      case PRECEDES:    str_op = "~"; break;
      case ADJACENT_TO: str_op = "+"; break;
      case REFERENCE:   str_op = "/" + str_ref + "/"; break;
***REMOVED***
    // prettify for non ancestors
    if (combinator() != ANCESTOR_OF) ***REMOVED***
      // no spaces needed for compressed
      if (compressed == false) ***REMOVED***
        // make sure we add some spaces where needed
        if (str_tail != "") str_op += " ";
        if (str_head != "") str_head += " ";
  ***REMOVED***
***REMOVED***
    // is ancestor with no tail
    else if (str_tail == "") ***REMOVED***
      str_op = ""; // superflous
***REMOVED***
    // now build the final result
    return str_head + str_op + str_tail;
  ***REMOVED***

  std::string Selector_Schema::to_string(bool compressed, int precision) const
  ***REMOVED***
    return contents()->to_string(compressed, precision);
  ***REMOVED***

  std::string Parent_Selector::to_string(bool compressed, int precision) const
  ***REMOVED***
    return "&";
  ***REMOVED***

  std::string Attribute_Selector::to_string(bool compressed, int precision) const
  ***REMOVED***
    std::string val(value() ? value()->to_string(compressed, precision) : "");
    return "[" + this->ns_name() + this->matcher() + val + "]";
  ***REMOVED***

  std::string Wrapped_Selector::to_string(bool compressed, int precision) const
  ***REMOVED***
    // first render the
    std::string main(this->Simple_Selector::to_string(compressed, precision));
    std::string wrapped(selector() ? selector()->to_string(compressed, precision) : "");
    // now build the final result
    return main + "(" + wrapped + ")";
  ***REMOVED***

  //////////////////////////////////////////////////////////////////////////////////////////
  // Additional method on Lists to retrieve values directly or from an encompassed Argument.
  //////////////////////////////////////////////////////////////////////////////////////////
  Expression* List::value_at_index(size_t i) ***REMOVED***
    if (is_arglist_) ***REMOVED***
      if (Argument* arg = dynamic_cast<Argument*>((*this)[i])) ***REMOVED***
        return arg->value();
  ***REMOVED*** else ***REMOVED***
        return (*this)[i];
  ***REMOVED***
***REMOVED*** else ***REMOVED***
      return (*this)[i];
***REMOVED***
  ***REMOVED***

***REMOVED***

