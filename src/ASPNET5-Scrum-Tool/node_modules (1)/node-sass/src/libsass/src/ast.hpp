#ifndef SASS_AST_H
#define SASS_AST_H

#include <set>
#include <deque>
#include <vector>
#include <string>
#include <sstream>
#include <iostream>
#include <typeinfo>
#include <algorithm>
#include <unordered_map>
#include "sass/base.h"

#ifdef __clang__

/*
 * There are some overloads used here that trigger the clang overload
 * hiding warning. Specifically:
 *
 * Type type() which hides string type() from Expression
 *
 * and
 *
 * Block* block() which hides virtual Block* block() from Statement
 *
 */

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Woverloaded-virtual"

#endif

#include "util.hpp"
#include "units.hpp"
#include "context.hpp"
#include "position.hpp"
#include "constants.hpp"
#include "operation.hpp"
#include "position.hpp"
#include "inspect.hpp"
#include "source_map.hpp"
#include "environment.hpp"
#include "error_handling.hpp"
#include "ast_def_macros.hpp"
#include "ast_fwd_decl.hpp"
#include "to_string.hpp"
#include "source_map.hpp"

#include "sass.h"

namespace Sass ***REMOVED***

  const double NUMBER_EPSILON = 0.00000000000001;

  // from boost (functional/hash):
  // http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html
  // Boost Software License - Version 1.0
  // http://www.boost.org/users/license.html
  template <typename T>
  void hash_combine (std::size_t& seed, const T& val)
  ***REMOVED***
    seed ^= std::hash<T>()(val) + 0x9e3779b9
             + (seed<<6) + (seed>>2);
  ***REMOVED***

  //////////////////////////////////////////////////////////
  // Abstract base class for all abstract syntax tree nodes.
  //////////////////////////////////////////////////////////
  class AST_Node : public Memory_Object ***REMOVED***
    ADD_PROPERTY(ParserState, pstate)
  public:
    AST_Node(ParserState pstate)
    : pstate_(pstate)
***REMOVED*** ***REMOVED***
    virtual ~AST_Node() = 0;
    // virtual Block* block() ***REMOVED*** return 0; ***REMOVED***
  public:
    void update_pstate(const ParserState& pstate);
  public:
    Offset off() ***REMOVED*** return pstate(); ***REMOVED***
    Position pos() ***REMOVED*** return pstate(); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;
  inline AST_Node::~AST_Node() ***REMOVED*** ***REMOVED***


  //////////////////////////////////////////////////////////////////////
  // Abstract base class for expressions. This side of the AST hierarchy
  // represents elements in value contexts, which exist primarily to be
  // evaluated and returned.
  //////////////////////////////////////////////////////////////////////
  class Expression : public AST_Node ***REMOVED***
  public:
    enum Concrete_Type ***REMOVED***
      NONE,
      BOOLEAN,
      NUMBER,
      COLOR,
      STRING,
      LIST,
      MAP,
      SELECTOR,
      NULL_VAL,
      C_WARNING,
      C_ERROR,
      NUM_TYPES
***REMOVED***;
  private:
    // expressions in some contexts shouldn't be evaluated
    ADD_PROPERTY(bool, is_delayed)
    ADD_PROPERTY(bool, is_expanded)
    ADD_PROPERTY(bool, is_interpolant)
    ADD_PROPERTY(Concrete_Type, concrete_type)
  public:
    Expression(ParserState pstate,
               bool d = false, bool e = false, bool i = false, Concrete_Type ct = NONE)
    : AST_Node(pstate),
      is_delayed_(d),
      is_expanded_(d),
      is_interpolant_(i),
      concrete_type_(ct)
***REMOVED*** ***REMOVED***
    virtual operator bool() ***REMOVED*** return true; ***REMOVED***
    virtual ~Expression() ***REMOVED*** ***REMOVED***
    virtual std::string type() ***REMOVED*** return ""; /* TODO: raise an error? */ ***REMOVED***
    virtual bool is_invisible() const ***REMOVED*** return false; ***REMOVED***
    static std::string type_name() ***REMOVED*** return ""; ***REMOVED***
    virtual bool is_false() ***REMOVED*** return false; ***REMOVED***
    virtual bool operator== (const Expression& rhs) const ***REMOVED*** return false; ***REMOVED***
    virtual void set_delayed(bool delayed) ***REMOVED*** is_delayed(delayed); ***REMOVED***
    virtual size_t hash() ***REMOVED*** return 0; ***REMOVED***
  ***REMOVED***;

  //////////////////////////////////////////////////////////////////////
  // base class for values that support operations
  //////////////////////////////////////////////////////////////////////
  class Value : public Expression ***REMOVED***
  public:
    Value(ParserState pstate,
          bool d = false, bool e = false, bool i = false, Concrete_Type ct = NONE)
    : Expression(pstate, d, e, i, ct)
***REMOVED*** ***REMOVED***
    virtual bool operator== (const Expression& rhs) const = 0;
    virtual std::string to_string(bool compressed = false, int precision = 5) const = 0;
  ***REMOVED***;
***REMOVED***

/////////////////////////////////////////////////////////////////////////////////////
// Hash method specializations for std::unordered_map to work with Sass::Expression
/////////////////////////////////////////////////////////////////////////////////////

namespace std ***REMOVED***
  template<>
  struct hash<Sass::Expression*>
  ***REMOVED***
    size_t operator()(Sass::Expression* s) const
***REMOVED***
      return s->hash();
***REMOVED***
  ***REMOVED***;
  template<>
  struct equal_to<Sass::Expression*>
  ***REMOVED***
    bool operator()( Sass::Expression* lhs,  Sass::Expression* rhs) const
***REMOVED***
      return lhs->hash() == rhs->hash();
***REMOVED***
  ***REMOVED***;
***REMOVED***

namespace Sass ***REMOVED***

  /////////////////////////////////////////////////////////////////////////////
  // Mixin class for AST nodes that should behave like vectors. Uses the
  // "Template Method" design pattern to allow subclasses to adjust their flags
  // when certain objects are pushed.
  /////////////////////////////////////////////////////////////////////////////
  template <typename T>
  class Vectorized ***REMOVED***
    std::vector<T> elements_;
  protected:
    size_t hash_;
    void reset_hash() ***REMOVED*** hash_ = 0; ***REMOVED***
    virtual void adjust_after_pushing(T element) ***REMOVED*** ***REMOVED***
  public:
    Vectorized(size_t s = 0) : elements_(std::vector<T>())
***REMOVED*** elements_.reserve(s); ***REMOVED***
    virtual ~Vectorized() = 0;
    size_t length() const   ***REMOVED*** return elements_.size(); ***REMOVED***
    bool empty() const  ***REMOVED*** return elements_.empty(); ***REMOVED***
    T last()***REMOVED*** return elements_.back(); ***REMOVED***
    T first()   ***REMOVED*** return elements_.front(); ***REMOVED***
    T& operator[](size_t i) ***REMOVED*** return elements_[i]; ***REMOVED***
    virtual const T& at(size_t i) const ***REMOVED*** return elements_.at(i); ***REMOVED***
    const T& operator[](size_t i) const ***REMOVED*** return elements_[i]; ***REMOVED***
    Vectorized& operator<<(T element)
***REMOVED***
      if (!element) return *this;
      reset_hash();
      elements_.push_back(element);
      adjust_after_pushing(element);
      return *this;
***REMOVED***
    Vectorized& operator+=(Vectorized* v)
***REMOVED***
      for (size_t i = 0, L = v->length(); i < L; ++i) *this << (*v)[i];
      return *this;
***REMOVED***
    Vectorized& unshift(T element)
***REMOVED***
      elements_.insert(elements_.begin(), element);
      return *this;
***REMOVED***
    std::vector<T>& elements() ***REMOVED*** return elements_; ***REMOVED***
    const std::vector<T>& elements() const ***REMOVED*** return elements_; ***REMOVED***
    std::vector<T>& elements(std::vector<T>& e) ***REMOVED*** elements_ = e; return elements_; ***REMOVED***

    typename std::vector<T>::iterator end() ***REMOVED*** return elements_.end(); ***REMOVED***
    typename std::vector<T>::iterator begin() ***REMOVED*** return elements_.begin(); ***REMOVED***
    typename std::vector<T>::const_iterator end() const ***REMOVED*** return elements_.end(); ***REMOVED***
    typename std::vector<T>::const_iterator begin() const ***REMOVED*** return elements_.begin(); ***REMOVED***
    typename std::vector<T>::iterator erase(typename std::vector<T>::iterator el) ***REMOVED*** return elements_.erase(el); ***REMOVED***
    typename std::vector<T>::const_iterator erase(typename std::vector<T>::const_iterator el) ***REMOVED*** return elements_.erase(el); ***REMOVED***

  ***REMOVED***;
  template <typename T>
  inline Vectorized<T>::~Vectorized() ***REMOVED*** ***REMOVED***

  /////////////////////////////////////////////////////////////////////////////
  // Mixin class for AST nodes that should behave like a hash table. Uses an
  // extra <std::vector> internally to maintain insertion order for interation.
  /////////////////////////////////////////////////////////////////////////////
  class Hashed ***REMOVED***
  private:
    std::unordered_map<Expression*, Expression*> elements_;
    std::vector<Expression*> list_;
  protected:
    size_t hash_;
    Expression* duplicate_key_;
    void reset_hash() ***REMOVED*** hash_ = 0; ***REMOVED***
    void reset_duplicate_key() ***REMOVED*** duplicate_key_ = 0; ***REMOVED***
    virtual void adjust_after_pushing(std::pair<Expression*, Expression*> p) ***REMOVED*** ***REMOVED***
  public:
    Hashed(size_t s = 0) : elements_(std::unordered_map<Expression*, Expression*>(s)), list_(std::vector<Expression*>())
***REMOVED*** elements_.reserve(s); list_.reserve(s); reset_duplicate_key(); ***REMOVED***
    virtual ~Hashed();
    size_t length() const  ***REMOVED*** return list_.size(); ***REMOVED***
    bool empty() const ***REMOVED*** return list_.empty(); ***REMOVED***
    bool has(Expression* k) const  ***REMOVED*** return elements_.count(k) == 1; ***REMOVED***
    Expression* at(Expression* k) const;
    bool has_duplicate_key() const ***REMOVED*** return duplicate_key_ != 0; ***REMOVED***
    Expression* get_duplicate_key() const  ***REMOVED*** return duplicate_key_; ***REMOVED***
    const std::unordered_map<Expression*, Expression*> elements() ***REMOVED*** return elements_; ***REMOVED***
    Hashed& operator<<(std::pair<Expression*, Expression*> p)
***REMOVED***
      reset_hash();

      if (!has(p.first)) list_.push_back(p.first);
      else if (!duplicate_key_) duplicate_key_ = p.first;

      elements_[p.first] = p.second;

      adjust_after_pushing(p);
      return *this;
***REMOVED***
    Hashed& operator+=(Hashed* h)
***REMOVED***
      if (length() == 0) ***REMOVED***
        this->elements_ = h->elements_;
        this->list_ = h->list_;
        return *this;
  ***REMOVED***

      for (auto key : h->keys()) ***REMOVED***
        *this << std::make_pair(key, h->at(key));
  ***REMOVED***

      reset_duplicate_key();
      return *this;
***REMOVED***
    const std::unordered_map<Expression*, Expression*>& pairs() const ***REMOVED*** return elements_; ***REMOVED***
    const std::vector<Expression*>& keys() const ***REMOVED*** return list_; ***REMOVED***

    std::unordered_map<Expression*, Expression*>::iterator end() ***REMOVED*** return elements_.end(); ***REMOVED***
    std::unordered_map<Expression*, Expression*>::iterator begin() ***REMOVED*** return elements_.begin(); ***REMOVED***
    std::unordered_map<Expression*, Expression*>::const_iterator end() const ***REMOVED*** return elements_.end(); ***REMOVED***
    std::unordered_map<Expression*, Expression*>::const_iterator begin() const ***REMOVED*** return elements_.begin(); ***REMOVED***

  ***REMOVED***;
  inline Hashed::~Hashed() ***REMOVED*** ***REMOVED***


  /////////////////////////////////////////////////////////////////////////
  // Abstract base class for statements. This side of the AST hierarchy
  // represents elements in expansion contexts, which exist primarily to be
  // rewritten and macro-expanded.
  /////////////////////////////////////////////////////////////////////////
  class Statement : public AST_Node ***REMOVED***
  public:
    enum Statement_Type ***REMOVED***
      NONE,
      RULESET,
      MEDIA,
      DIRECTIVE,
      SUPPORTS,
      ATROOT,
      BUBBLE,
      CONTENT,
      KEYFRAMERULE,
      DECLARATION,
      ASSIGNMENT,
      IMPORT_STUB,
      IMPORT,
      COMMENT,
      WARNING,
      RETURN,
      EXTEND,
      ERROR,
      DEBUGSTMT,
      WHILE,
      EACH,
      FOR,
      IF
***REMOVED***;
  private:
    ADD_PROPERTY(Block*, block)
    ADD_PROPERTY(Statement_Type, statement_type)
    ADD_PROPERTY(size_t, tabs)
    ADD_PROPERTY(bool, group_end)
  public:
    Statement(ParserState pstate, Statement_Type st = NONE, size_t t = 0)
    : AST_Node(pstate), statement_type_(st), tabs_(t), group_end_(false)
 ***REMOVED*** ***REMOVED***
    virtual ~Statement() = 0;
    // needed for rearranging nested rulesets during CSS emission
    virtual bool   is_hoistable() ***REMOVED*** return false; ***REMOVED***
    virtual bool   is_invisible() const ***REMOVED*** return false; ***REMOVED***
    virtual bool   bubbles() ***REMOVED*** return false; ***REMOVED***
    virtual Block* block()  ***REMOVED*** return 0; ***REMOVED***
    virtual bool has_content()
***REMOVED***
      return statement_type_ == CONTENT;
***REMOVED***
  ***REMOVED***;
  inline Statement::~Statement() ***REMOVED*** ***REMOVED***

  ////////////////////////
  // Blocks of statements.
  ////////////////////////
  class Block : public Statement, public Vectorized<Statement*> ***REMOVED***
    ADD_PROPERTY(bool, is_root)
    ADD_PROPERTY(bool, is_at_root);
    // needed for properly formatted CSS emission
    ADD_PROPERTY(bool, has_hoistable)
    ADD_PROPERTY(bool, has_non_hoistable)
  protected:
    void adjust_after_pushing(Statement* s)
***REMOVED***
      if (s->is_hoistable()) has_hoistable_     = true;
      else                   has_non_hoistable_ = true;
***REMOVED***
  public:
    Block(ParserState pstate, size_t s = 0, bool r = false)
    : Statement(pstate),
      Vectorized<Statement*>(s),
      is_root_(r),
      is_at_root_(false),
      has_hoistable_(false),
      has_non_hoistable_(false)
***REMOVED*** ***REMOVED***
    virtual bool has_content()
***REMOVED***
      for (size_t i = 0, L = elements().size(); i < L; ++i) ***REMOVED***
        if (elements()[i]->has_content()) return true;
  ***REMOVED***
      return Statement::has_content();
***REMOVED***
    Block* block() ***REMOVED*** return this; ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////////////////////
  // Abstract base class for statements that contain blocks of statements.
  ////////////////////////////////////////////////////////////////////////
  class Has_Block : public Statement ***REMOVED***
    ADD_PROPERTY(Block*, block)
  public:
    Has_Block(ParserState pstate, Block* b)
    : Statement(pstate), block_(b)
***REMOVED*** ***REMOVED***
    virtual bool has_content()
***REMOVED***
      return (block_ && block_->has_content()) || Statement::has_content();
***REMOVED***
    virtual ~Has_Block() = 0;
  ***REMOVED***;
  inline Has_Block::~Has_Block() ***REMOVED*** ***REMOVED***

  /////////////////////////////////////////////////////////////////////////////
  // Rulesets (i.e., sets of styles headed by a selector and containing a block
  // of style declarations.
  /////////////////////////////////////////////////////////////////////////////
  class Ruleset : public Has_Block ***REMOVED***
    ADD_PROPERTY(Selector*, selector)
    ADD_PROPERTY(bool, at_root);
    ADD_PROPERTY(bool, is_root);
  public:
    Ruleset(ParserState pstate, Selector* s = 0, Block* b = 0)
    : Has_Block(pstate, b), selector_(s), at_root_(false), is_root_(false)
***REMOVED*** statement_type(RULESET); ***REMOVED***
    bool is_invisible() const;
    // nested rulesets need to be hoisted out of their enclosing blocks
    bool is_hoistable() ***REMOVED*** return true; ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////////////////////////
  // Nested declaration sets (i.e., namespaced properties).
  /////////////////////////////////////////////////////////
  class Propset : public Has_Block ***REMOVED***
    ADD_PROPERTY(String*, property_fragment)
  public:
    Propset(ParserState pstate, String* pf, Block* b = 0)
    : Has_Block(pstate, b), property_fragment_(pf)
***REMOVED*** ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////
  // Bubble.
  /////////////////
  class Bubble : public Statement ***REMOVED***
    ADD_PROPERTY(Statement*, node)
    ADD_PROPERTY(bool, group_end)
  public:
    Bubble(ParserState pstate, Statement* n, Statement* g = 0, size_t t = 0)
    : Statement(pstate, Statement::BUBBLE, t), node_(n), group_end_(g == 0)
***REMOVED*** ***REMOVED***
    bool bubbles() ***REMOVED*** return true; ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////
  // Media queries.
  /////////////////
  class Media_Block : public Has_Block ***REMOVED***
    ADD_PROPERTY(List*, media_queries)
  public:
    Media_Block(ParserState pstate, List* mqs, Block* b)
    : Has_Block(pstate, b), media_queries_(mqs)
***REMOVED*** statement_type(MEDIA); ***REMOVED***
    Media_Block(ParserState pstate, List* mqs, Block* b, Selector* s)
    : Has_Block(pstate, b), media_queries_(mqs)
***REMOVED*** statement_type(MEDIA); ***REMOVED***
    bool bubbles() ***REMOVED*** return true; ***REMOVED***
    bool is_hoistable() ***REMOVED*** return true; ***REMOVED***
    bool is_invisible() const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////////////////////////////////////////////
  // At-rules -- arbitrary directives beginning with "@" that may have an
  // optional statement block.
  ///////////////////////////////////////////////////////////////////////
  class At_Rule : public Has_Block ***REMOVED***
    ADD_PROPERTY(std::string, keyword)
    ADD_PROPERTY(Selector*, selector)
    ADD_PROPERTY(Expression*, value)
  public:
    At_Rule(ParserState pstate, std::string kwd, Selector* sel = 0, Block* b = 0, Expression* val = 0)
    : Has_Block(pstate, b), keyword_(kwd), selector_(sel), value_(val) // set value manually if needed
***REMOVED*** statement_type(DIRECTIVE); ***REMOVED***
    bool bubbles() ***REMOVED*** return is_keyframes() || is_media(); ***REMOVED***
    bool is_media() ***REMOVED***
      return keyword_.compare("@-webkit-media") == 0 ||
             keyword_.compare("@-moz-media") == 0 ||
             keyword_.compare("@-o-media") == 0 ||
             keyword_.compare("@media") == 0;
***REMOVED***
    bool is_keyframes() ***REMOVED***
      return keyword_.compare("@-webkit-keyframes") == 0 ||
             keyword_.compare("@-moz-keyframes") == 0 ||
             keyword_.compare("@-o-keyframes") == 0 ||
             keyword_.compare("@keyframes") == 0;
***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////////////////////////////////////////////
  // Keyframe-rules -- the child blocks of "@keyframes" nodes.
  ///////////////////////////////////////////////////////////////////////
  class Keyframe_Rule : public Has_Block ***REMOVED***
    ADD_PROPERTY(Selector*, selector)
  public:
    Keyframe_Rule(ParserState pstate, Block* b)
    : Has_Block(pstate, b), selector_(0)
***REMOVED*** statement_type(KEYFRAMERULE); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////////////////////
  // Declarations -- style rules consisting of a property name and values.
  ////////////////////////////////////////////////////////////////////////
  class Declaration : public Statement ***REMOVED***
    ADD_PROPERTY(String*, property)
    ADD_PROPERTY(Expression*, value)
    ADD_PROPERTY(bool, is_important)
    ADD_PROPERTY(bool, is_indented)
  public:
    Declaration(ParserState pstate,
                String* prop, Expression* val, bool i = false)
    : Statement(pstate), property_(prop), value_(val), is_important_(i), is_indented_(false)
***REMOVED*** statement_type(DECLARATION); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////
  // Assignments -- variable and value.
  /////////////////////////////////////
  class Assignment : public Statement ***REMOVED***
    ADD_PROPERTY(std::string, variable)
    ADD_PROPERTY(Expression*, value)
    ADD_PROPERTY(bool, is_default)
    ADD_PROPERTY(bool, is_global)
  public:
    Assignment(ParserState pstate,
               std::string var, Expression* val,
               bool is_default = false,
               bool is_global = false)
    : Statement(pstate), variable_(var), value_(val), is_default_(is_default), is_global_(is_global)
***REMOVED*** statement_type(ASSIGNMENT); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////////////////////////
  // Import directives. CSS and Sass import lists can be intermingled, so it's
  // necessary to store a list of each in an Import node.
  ////////////////////////////////////////////////////////////////////////////
  class Import : public Statement ***REMOVED***
    std::vector<Expression*> urls_;
    std::vector<Include>     incs_;
    ADD_PROPERTY(List*,      media_queries);
  public:
    Import(ParserState pstate)
    : Statement(pstate),
      urls_(std::vector<Expression*>()),
      incs_(std::vector<Include>()),
      media_queries_(0)
***REMOVED*** statement_type(IMPORT); ***REMOVED***
    std::vector<Expression*>& urls() ***REMOVED*** return urls_; ***REMOVED***
    std::vector<Include>& incs() ***REMOVED*** return incs_; ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  // not yet resolved single import
  // so far we only know requested name
  class Import_Stub : public Statement ***REMOVED***
    Include resource_;
  public:
    std::string abs_path() ***REMOVED*** return resource_.abs_path; ***REMOVED***;
    std::string imp_path() ***REMOVED*** return resource_.imp_path; ***REMOVED***;
    Include resource() ***REMOVED*** return resource_; ***REMOVED***;

    Import_Stub(ParserState pstate, Include res)
    : Statement(pstate), resource_(res)
***REMOVED*** statement_type(IMPORT_STUB); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////////////////
  // The Sass `@warn` directive.
  //////////////////////////////
  class Warning : public Statement ***REMOVED***
    ADD_PROPERTY(Expression*, message)
  public:
    Warning(ParserState pstate, Expression* msg)
    : Statement(pstate), message_(msg)
***REMOVED*** statement_type(WARNING); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////
  // The Sass `@error` directive.
  ///////////////////////////////
  class Error : public Statement ***REMOVED***
    ADD_PROPERTY(Expression*, message)
  public:
    Error(ParserState pstate, Expression* msg)
    : Statement(pstate), message_(msg)
***REMOVED*** statement_type(ERROR); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////
  // The Sass `@debug` directive.
  ///////////////////////////////
  class Debug : public Statement ***REMOVED***
    ADD_PROPERTY(Expression*, value)
  public:
    Debug(ParserState pstate, Expression* val)
    : Statement(pstate), value_(val)
***REMOVED*** statement_type(DEBUGSTMT); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////////////////
  // CSS comments. These may be interpolated.
  ///////////////////////////////////////////
  class Comment : public Statement ***REMOVED***
    ADD_PROPERTY(String*, text)
    ADD_PROPERTY(bool, is_important)
  public:
    Comment(ParserState pstate, String* txt, bool is_important)
    : Statement(pstate), text_(txt), is_important_(is_important)
***REMOVED*** statement_type(COMMENT); ***REMOVED***
    virtual bool is_invisible() const
***REMOVED*** return is_important() == false; ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////
  // The Sass `@if` control directive.
  ////////////////////////////////////
  class If : public Has_Block ***REMOVED***
    ADD_PROPERTY(Expression*, predicate)
    ADD_PROPERTY(Block*, alternative)
  public:
    If(ParserState pstate, Expression* pred, Block* con, Block* alt = 0)
    : Has_Block(pstate, con), predicate_(pred), alternative_(alt)
***REMOVED*** statement_type(IF); ***REMOVED***
    virtual bool has_content()
***REMOVED***
      return Has_Block::has_content() || (alternative_ && alternative_->has_content());
***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////
  // The Sass `@for` control directive.
  /////////////////////////////////////
  class For : public Has_Block ***REMOVED***
    ADD_PROPERTY(std::string, variable)
    ADD_PROPERTY(Expression*, lower_bound)
    ADD_PROPERTY(Expression*, upper_bound)
    ADD_PROPERTY(bool, is_inclusive)
  public:
    For(ParserState pstate,
        std::string var, Expression* lo, Expression* hi, Block* b, bool inc)
    : Has_Block(pstate, b),
      variable_(var), lower_bound_(lo), upper_bound_(hi), is_inclusive_(inc)
***REMOVED*** statement_type(FOR); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////////////////////////
  // The Sass `@each` control directive.
  //////////////////////////////////////
  class Each : public Has_Block ***REMOVED***
    ADD_PROPERTY(std::vector<std::string>, variables)
    ADD_PROPERTY(Expression*, list)
  public:
    Each(ParserState pstate, std::vector<std::string> vars, Expression* lst, Block* b)
    : Has_Block(pstate, b), variables_(vars), list_(lst)
***REMOVED*** statement_type(EACH); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////////////
  // The Sass `@while` control directive.
  ///////////////////////////////////////
  class While : public Has_Block ***REMOVED***
    ADD_PROPERTY(Expression*, predicate)
  public:
    While(ParserState pstate, Expression* pred, Block* b)
    : Has_Block(pstate, b), predicate_(pred)
***REMOVED*** statement_type(WHILE); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////////////////////////////
  // The @return directive for use inside SassScript functions.
  /////////////////////////////////////////////////////////////
  class Return : public Statement ***REMOVED***
    ADD_PROPERTY(Expression*, value)
  public:
    Return(ParserState pstate, Expression* val)
    : Statement(pstate), value_(val)
***REMOVED*** statement_type(RETURN); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////
  // The Sass `@extend` directive.
  ////////////////////////////////
  class Extension : public Statement ***REMOVED***
    ADD_PROPERTY(Selector*, selector)
  public:
    Extension(ParserState pstate, Selector* s)
    : Statement(pstate), selector_(s)
***REMOVED*** statement_type(EXTEND); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////////////////////////////////////////////
  // Definitions for both mixins and functions. The two cases are distinguished
  // by a type tag.
  /////////////////////////////////////////////////////////////////////////////
  struct Backtrace;
  typedef Environment<AST_Node*> Env;
  typedef const char* Signature;
  typedef Expression* (*Native_Function)(Env&, Env&, Context&, Signature, ParserState, Backtrace*);
  typedef const char* Signature;
  class Definition : public Has_Block ***REMOVED***
  public:
    enum Type ***REMOVED*** MIXIN, FUNCTION ***REMOVED***;
    ADD_PROPERTY(std::string, name)
    ADD_PROPERTY(Parameters*, parameters)
    ADD_PROPERTY(Env*, environment)
    ADD_PROPERTY(Type, type)
    ADD_PROPERTY(Native_Function, native_function)
    ADD_PROPERTY(Sass_Function_Entry, c_function)
    ADD_PROPERTY(void*, cookie)
    ADD_PROPERTY(bool, is_overload_stub)
    ADD_PROPERTY(Signature, signature)
  public:
    Definition(ParserState pstate,
               std::string n,
               Parameters* params,
               Block* b,
               Type t)
    : Has_Block(pstate, b),
      name_(n),
      parameters_(params),
      environment_(0),
      type_(t),
      native_function_(0),
      c_function_(0),
      cookie_(0),
      is_overload_stub_(false),
      signature_(0)
***REMOVED*** ***REMOVED***
    Definition(ParserState pstate,
               Signature sig,
               std::string n,
               Parameters* params,
               Native_Function func_ptr,
               bool overload_stub = false)
    : Has_Block(pstate, 0),
      name_(n),
      parameters_(params),
      environment_(0),
      type_(FUNCTION),
      native_function_(func_ptr),
      c_function_(0),
      cookie_(0),
      is_overload_stub_(overload_stub),
      signature_(sig)
***REMOVED*** ***REMOVED***
    Definition(ParserState pstate,
               Signature sig,
               std::string n,
               Parameters* params,
               Sass_Function_Entry c_func,
               bool whatever,
               bool whatever2)
    : Has_Block(pstate, 0),
      name_(n),
      parameters_(params),
      environment_(0),
      type_(FUNCTION),
      native_function_(0),
      c_function_(c_func),
      cookie_(sass_function_get_cookie(c_func)),
      is_overload_stub_(false),
      signature_(sig)
***REMOVED*** ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////////////////////////
  // Mixin calls (i.e., `@include ...`).
  //////////////////////////////////////
  class Mixin_Call : public Has_Block ***REMOVED***
    ADD_PROPERTY(std::string, name)
    ADD_PROPERTY(Arguments*, arguments)
  public:
    Mixin_Call(ParserState pstate, std::string n, Arguments* args, Block* b = 0)
    : Has_Block(pstate, b), name_(n), arguments_(args)
***REMOVED*** ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////////////////////////
  // The @content directive for mixin content blocks.
  ///////////////////////////////////////////////////
  class Content : public Statement ***REMOVED***
  public:
    Content(ParserState pstate) : Statement(pstate)
***REMOVED*** statement_type(CONTENT); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////////////////////////////////////////////
  // Lists of values, both comma- and space-separated (distinguished by a
  // type-tag.) Also used to represent variable-length argument lists.
  ///////////////////////////////////////////////////////////////////////
  class List : public Value, public Vectorized<Expression*> ***REMOVED***
    void adjust_after_pushing(Expression* e) ***REMOVED*** is_expanded(false); ***REMOVED***
  private:
    ADD_PROPERTY(enum Sass_Separator, separator)
    ADD_PROPERTY(bool, is_arglist)
  public:
    List(ParserState pstate,
         size_t size = 0, enum Sass_Separator sep = SASS_SPACE, bool argl = false)
    : Value(pstate),
      Vectorized<Expression*>(size),
      separator_(sep), is_arglist_(argl)
***REMOVED*** concrete_type(LIST); ***REMOVED***
    std::string type() ***REMOVED*** return is_arglist_ ? "arglist" : "list"; ***REMOVED***
    static std::string type_name() ***REMOVED*** return "list"; ***REMOVED***
    const char* sep_string(bool compressed = false) const ***REMOVED***
      return separator() == SASS_COMMA ?
        (compressed ? "," : ", ") : " ";
***REMOVED***
    bool is_invisible() const ***REMOVED*** return empty(); ***REMOVED***
    Expression* value_at_index(size_t i);

    virtual size_t size() const;

    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        hash_ = std::hash<std::string>()(sep_string());
        for (size_t i = 0, L = length(); i < L; ++i)
          hash_combine(hash_, (elements()[i])->hash());
  ***REMOVED***
      return hash_;
***REMOVED***

    virtual void set_delayed(bool delayed)
***REMOVED***
      for (size_t i = 0, L = length(); i < L; ++i)
        (elements()[i])->set_delayed(delayed);
      is_delayed(delayed);
***REMOVED***

    virtual bool operator== (const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;

    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////////////////////////////////////////////
  // Key value paris.
  ///////////////////////////////////////////////////////////////////////
  class Map : public Value, public Hashed ***REMOVED***
    void adjust_after_pushing(std::pair<Expression*, Expression*> p) ***REMOVED*** is_expanded(false); ***REMOVED***
  public:
    Map(ParserState pstate,
         size_t size = 0)
    : Value(pstate),
      Hashed(size)
***REMOVED*** concrete_type(MAP); ***REMOVED***
    std::string type() ***REMOVED*** return "map"; ***REMOVED***
    static std::string type_name() ***REMOVED*** return "map"; ***REMOVED***
    bool is_invisible() const ***REMOVED*** return empty(); ***REMOVED***

    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        for (auto key : keys()) ***REMOVED***
          hash_combine(hash_, key->hash());
          hash_combine(hash_, at(key)->hash());
***REMOVED***
  ***REMOVED***

      return hash_;
***REMOVED***

    virtual bool operator== (const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;

    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////////////////////////////////////////////////////////////
  // Binary expressions. Represents logical, relational, and arithmetic
  // operations. Templatized to avoid large switch statements and repetitive
  // subclassing.
  //////////////////////////////////////////////////////////////////////////
  class Binary_Expression : public Expression ***REMOVED***
  private:
    ADD_HASHED(enum Sass_OP, type)
    ADD_HASHED(Expression*, left)
    ADD_HASHED(Expression*, right)
    size_t hash_;
  public:
    Binary_Expression(ParserState pstate,
                      enum Sass_OP t, Expression* lhs, Expression* rhs)
    : Expression(pstate), type_(t), left_(lhs), right_(rhs), hash_(0)
***REMOVED*** ***REMOVED***
    const std::string type_name() ***REMOVED***
      switch (type_) ***REMOVED***
        case AND: return "and"; break;
        case OR: return "or"; break;
        case EQ: return "eq"; break;
        case NEQ: return "neq"; break;
        case GT: return "gt"; break;
        case GTE: return "gte"; break;
        case LT: return "lt"; break;
        case LTE: return "lte"; break;
        case ADD: return "add"; break;
        case SUB: return "sub"; break;
        case MUL: return "mul"; break;
        case DIV: return "div"; break;
        case MOD: return "mod"; break;
        case NUM_OPS: return "num_ops"; break;
        default: return "invalid"; break;
  ***REMOVED***
***REMOVED***
    virtual void set_delayed(bool delayed)
***REMOVED***
      right()->set_delayed(delayed);
      left()->set_delayed(delayed);
      is_delayed(delayed);
***REMOVED***
    virtual bool operator==(const Expression& rhs) const
***REMOVED***
      try
  ***REMOVED***
        const Binary_Expression* m = dynamic_cast<const Binary_Expression*>(&rhs);
        if (m == 0) return false;
        return type() == m->type() &&
               left() == m->left() &&
               right() == m->right();
  ***REMOVED***
      catch (std::bad_cast&)
  ***REMOVED***
        return false;
  ***REMOVED***
      catch (...) ***REMOVED*** throw; ***REMOVED***
***REMOVED***
    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        hash_ = std::hash<size_t>()(type_);
        hash_combine(hash_, left()->hash());
        hash_combine(hash_, right()->hash());
  ***REMOVED***
      return hash_;
***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////////////////////////
  // Arithmetic negation (logical negation is just an ordinary function call).
  ////////////////////////////////////////////////////////////////////////////
  class Unary_Expression : public Expression ***REMOVED***
  public:
    enum Type ***REMOVED*** PLUS, MINUS, NOT ***REMOVED***;
  private:
    ADD_HASHED(Type, type)
    ADD_HASHED(Expression*, operand)
    size_t hash_;
  public:
    Unary_Expression(ParserState pstate, Type t, Expression* o)
    : Expression(pstate), type_(t), operand_(o), hash_(0)
***REMOVED*** ***REMOVED***
    const std::string type_name() ***REMOVED***
      switch (type_) ***REMOVED***
        case PLUS: return "plus"; break;
        case MINUS: return "minus"; break;
        case NOT: return "not"; break;
        default: return "invalid"; break;
  ***REMOVED***
***REMOVED***
    virtual bool operator==(const Expression& rhs) const
***REMOVED***
      try
  ***REMOVED***
        const Unary_Expression* m = dynamic_cast<const Unary_Expression*>(&rhs);
        if (m == 0) return false;
        return type() == m->type() &&
               operand() == m->operand();
  ***REMOVED***
      catch (std::bad_cast&)
  ***REMOVED***
        return false;
  ***REMOVED***
      catch (...) ***REMOVED*** throw; ***REMOVED***
***REMOVED***
    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        hash_ = std::hash<size_t>()(type_);
        hash_combine(hash_, operand()->hash());
  ***REMOVED***;
      return hash_;
***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////////
  // Individual argument objects for mixin and function calls.
  ////////////////////////////////////////////////////////////
  class Argument : public Expression ***REMOVED***
    ADD_HASHED(Expression*, value)
    ADD_HASHED(std::string, name)
    ADD_PROPERTY(bool, is_rest_argument)
    ADD_PROPERTY(bool, is_keyword_argument)
    size_t hash_;
  public:
    Argument(ParserState pstate, Expression* val, std::string n = "", bool rest = false, bool keyword = false)
    : Expression(pstate), value_(val), name_(n), is_rest_argument_(rest), is_keyword_argument_(keyword), hash_(0)
***REMOVED***
      if (!name_.empty() && is_rest_argument_) ***REMOVED***
        error("variable-length argument may not be passed by name", pstate);
  ***REMOVED***
***REMOVED***

    virtual bool operator==(const Expression& rhs) const
***REMOVED***
      try
  ***REMOVED***
        const Argument* m = dynamic_cast<const Argument*>(&rhs);
        if (!(m && name() == m->name())) return false;
        return *value() == *m->value();
  ***REMOVED***
      catch (std::bad_cast&)
  ***REMOVED***
        return false;
  ***REMOVED***
      catch (...) ***REMOVED*** throw; ***REMOVED***
***REMOVED***

    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        hash_ = std::hash<std::string>()(name());
        hash_combine(hash_, value()->hash());
  ***REMOVED***
      return hash_;
***REMOVED***

    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////////////////////
  // Argument lists -- in their own class to facilitate context-sensitive
  // error checking (e.g., ensuring that all ordinal arguments precede all
  // named arguments).
  ////////////////////////////////////////////////////////////////////////
  class Arguments : public Expression, public Vectorized<Argument*> ***REMOVED***
    ADD_PROPERTY(bool, has_named_arguments)
    ADD_PROPERTY(bool, has_rest_argument)
    ADD_PROPERTY(bool, has_keyword_argument)
  protected:
    void adjust_after_pushing(Argument* a);
  public:
    Arguments(ParserState pstate)
    : Expression(pstate),
      Vectorized<Argument*>(),
      has_named_arguments_(false),
      has_rest_argument_(false),
      has_keyword_argument_(false)
***REMOVED*** ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////
  // Function calls.
  //////////////////
  class Function_Call : public Expression ***REMOVED***
    ADD_HASHED(std::string, name)
    ADD_HASHED(Arguments*, arguments)
    ADD_PROPERTY(void*, cookie)
    size_t hash_;
  public:
    Function_Call(ParserState pstate, std::string n, Arguments* args, void* cookie)
    : Expression(pstate), name_(n), arguments_(args), cookie_(cookie), hash_(0)
***REMOVED*** concrete_type(STRING); ***REMOVED***
    Function_Call(ParserState pstate, std::string n, Arguments* args)
    : Expression(pstate), name_(n), arguments_(args), cookie_(0), hash_(0)
***REMOVED*** concrete_type(STRING); ***REMOVED***

    virtual bool operator==(const Expression& rhs) const
***REMOVED***
      try
  ***REMOVED***
        const Function_Call* m = dynamic_cast<const Function_Call*>(&rhs);
        if (!(m && name() == m->name())) return false;
        if (!(m && arguments()->length() == m->arguments()->length())) return false;
        for (size_t i =0, L = arguments()->length(); i < L; ++i)
          if (!((*arguments())[i] == (*m->arguments())[i])) return false;
        return true;
  ***REMOVED***
      catch (std::bad_cast&)
  ***REMOVED***
        return false;
  ***REMOVED***
      catch (...) ***REMOVED*** throw; ***REMOVED***
***REMOVED***

    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        hash_ = std::hash<std::string>()(name());
        for (auto argument : arguments()->elements())
          hash_combine(hash_, argument->hash());
  ***REMOVED***
      return hash_;
***REMOVED***

    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////
  // Function call schemas.
  /////////////////////////
  class Function_Call_Schema : public Expression ***REMOVED***
    ADD_PROPERTY(String*, name)
    ADD_PROPERTY(Arguments*, arguments)
  public:
    Function_Call_Schema(ParserState pstate, String* n, Arguments* args)
    : Expression(pstate), name_(n), arguments_(args)
***REMOVED*** concrete_type(STRING); ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////
  // Variable references.
  ///////////////////////
  class Variable : public Expression ***REMOVED***
    ADD_PROPERTY(std::string, name)
  public:
    Variable(ParserState pstate, std::string n)
    : Expression(pstate), name_(n)
***REMOVED*** ***REMOVED***

    virtual bool operator==(const Expression& rhs) const
***REMOVED***
      try
  ***REMOVED***
        const Variable* e = dynamic_cast<const Variable*>(&rhs);
        return e && name() == e->name();
  ***REMOVED***
      catch (std::bad_cast&)
  ***REMOVED***
        return false;
  ***REMOVED***
      catch (...) ***REMOVED*** throw; ***REMOVED***
***REMOVED***

    virtual size_t hash()
***REMOVED***
      return std::hash<std::string>()(name());
***REMOVED***

    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////////////////////////
  // Textual (i.e., unevaluated) numeric data. Variants are distinguished with
  // a type tag.
  ////////////////////////////////////////////////////////////////////////////
  class Textual : public Expression ***REMOVED***
  public:
    enum Type ***REMOVED*** NUMBER, PERCENTAGE, DIMENSION, HEX ***REMOVED***;
  private:
    ADD_HASHED(Type, type)
    ADD_HASHED(std::string, value)
    size_t hash_;
  public:
    Textual(ParserState pstate, Type t, std::string val)
    : Expression(pstate, true), type_(t), value_(val),
      hash_(0)
***REMOVED*** ***REMOVED***

    virtual bool operator==(const Expression& rhs) const
***REMOVED***
      try
  ***REMOVED***
        const Textual* e = dynamic_cast<const Textual*>(&rhs);
        return e && value() == e->value() && type() == e->type();
  ***REMOVED***
      catch (std::bad_cast&)
  ***REMOVED***
        return false;
  ***REMOVED***
      catch (...) ***REMOVED*** throw; ***REMOVED***
***REMOVED***

    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        hash_ = std::hash<std::string>()(value_);
        hash_combine(hash_, std::hash<int>()(type_));
  ***REMOVED***
      return hash_;
***REMOVED***

    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////
  // Numbers, percentages, dimensions, and colors.
  ////////////////////////////////////////////////
  class Number : public Value ***REMOVED***
    ADD_HASHED(double, value)
    ADD_PROPERTY(bool, zero)
    std::vector<std::string> numerator_units_;
    std::vector<std::string> denominator_units_;
    size_t hash_;
  public:
    Number(ParserState pstate, double val, std::string u = "", bool zero = true);
    bool            zero()  ***REMOVED*** return zero_; ***REMOVED***
    std::vector<std::string>& numerator_units()   ***REMOVED*** return numerator_units_; ***REMOVED***
    std::vector<std::string>& denominator_units() ***REMOVED*** return denominator_units_; ***REMOVED***
    const std::vector<std::string>& numerator_units() const   ***REMOVED*** return numerator_units_; ***REMOVED***
    const std::vector<std::string>& denominator_units() const ***REMOVED*** return denominator_units_; ***REMOVED***
    std::string type() ***REMOVED*** return "number"; ***REMOVED***
    static std::string type_name() ***REMOVED*** return "number"; ***REMOVED***
    std::string unit() const;

    bool is_unitless();
    void convert(const std::string& unit = "", bool strict = false);
    void normalize(const std::string& unit = "", bool strict = false);
    // useful for making one number compatible with another
    std::string find_convertible_unit() const;

    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        hash_ = std::hash<double>()(value_);
        for (const auto numerator : numerator_units())
          hash_combine(hash_, std::hash<std::string>()(numerator));
        for (const auto denominator : denominator_units())
          hash_combine(hash_, std::hash<std::string>()(denominator));
  ***REMOVED***
      return hash_;
***REMOVED***

    virtual bool operator< (const Number& rhs) const;
    virtual bool operator== (const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;

    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////
  // Colors.
  //////////
  class Color : public Value ***REMOVED***
    ADD_HASHED(double, r)
    ADD_HASHED(double, g)
    ADD_HASHED(double, b)
    ADD_HASHED(double, a)
    ADD_PROPERTY(bool, sixtuplet)
    ADD_PROPERTY(std::string, disp)
    size_t hash_;
  public:
    Color(ParserState pstate, double r, double g, double b, double a = 1, bool sixtuplet = true, const std::string disp = "")
    : Value(pstate), r_(r), g_(g), b_(b), a_(a), sixtuplet_(sixtuplet), disp_(disp),
      hash_(0)
***REMOVED*** concrete_type(COLOR); ***REMOVED***
    std::string type() ***REMOVED*** return "color"; ***REMOVED***
    static std::string type_name() ***REMOVED*** return "color"; ***REMOVED***

    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        hash_ = std::hash<double>()(a_);
        hash_combine(hash_, std::hash<double>()(r_));
        hash_combine(hash_, std::hash<double>()(g_));
        hash_combine(hash_, std::hash<double>()(b_));
  ***REMOVED***
      return hash_;
***REMOVED***

    virtual bool operator== (const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;

    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////////////////
  // Errors from Sass_Values.
  //////////////////////////////
  class Custom_Error : public Value ***REMOVED***
    ADD_PROPERTY(std::string, message)
  public:
    Custom_Error(ParserState pstate, std::string msg)
    : Value(pstate), message_(msg)
***REMOVED*** concrete_type(C_ERROR); ***REMOVED***
    virtual bool operator== (const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////////////////
  // Warnings from Sass_Values.
  //////////////////////////////
  class Custom_Warning : public Value ***REMOVED***
    ADD_PROPERTY(std::string, message)
  public:
    Custom_Warning(ParserState pstate, std::string msg)
    : Value(pstate), message_(msg)
***REMOVED*** concrete_type(C_WARNING); ***REMOVED***
    virtual bool operator== (const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////
  // Booleans.
  ////////////
  class Boolean : public Value ***REMOVED***
    ADD_HASHED(bool, value)
    size_t hash_;
  public:
    Boolean(ParserState pstate, bool val)
    : Value(pstate), value_(val),
      hash_(0)
***REMOVED*** concrete_type(BOOLEAN); ***REMOVED***
    virtual operator bool() ***REMOVED*** return value_; ***REMOVED***
    std::string type() ***REMOVED*** return "bool"; ***REMOVED***
    static std::string type_name() ***REMOVED*** return "bool"; ***REMOVED***
    virtual bool is_false() ***REMOVED*** return !value_; ***REMOVED***

    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        hash_ = std::hash<bool>()(value_);
  ***REMOVED***
      return hash_;
***REMOVED***

    virtual bool operator== (const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;

    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////////////////////
  // Abstract base class for Sass string values. Includes interpolated and
  // "flat" strings.
  ////////////////////////////////////////////////////////////////////////
  class String : public Value ***REMOVED***
    ADD_PROPERTY(bool, sass_fix_1291)
  public:
    String(ParserState pstate, bool delayed = false, bool sass_fix_1291 = false)
    : Value(pstate, delayed), sass_fix_1291_(sass_fix_1291)
***REMOVED*** concrete_type(STRING); ***REMOVED***
    static std::string type_name() ***REMOVED*** return "string"; ***REMOVED***
    virtual ~String() = 0;
    virtual bool operator==(const Expression& rhs) const = 0;
    virtual std::string to_string(bool compressed = false, int precision = 5) const = 0;
    ATTACH_OPERATIONS()
  ***REMOVED***;
  inline String::~String() ***REMOVED*** ***REMOVED***;

  ///////////////////////////////////////////////////////////////////////
  // Interpolated strings. Meant to be reduced to flat strings during the
  // evaluation phase.
  ///////////////////////////////////////////////////////////////////////
  class String_Schema : public String, public Vectorized<Expression*> ***REMOVED***
    ADD_PROPERTY(bool, has_interpolants)
    size_t hash_;
  public:
    String_Schema(ParserState pstate, size_t size = 0, bool has_interpolants = false)
    : String(pstate), Vectorized<Expression*>(size), has_interpolants_(has_interpolants), hash_(0)
***REMOVED*** concrete_type(STRING); ***REMOVED***
    std::string type() ***REMOVED*** return "string"; ***REMOVED***
    static std::string type_name() ***REMOVED*** return "string"; ***REMOVED***

    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        for (auto string : elements())
          hash_combine(hash_, string->hash());
  ***REMOVED***
      return hash_;
***REMOVED***

    virtual bool operator==(const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;

    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////
  // Flat strings -- the lowest level of raw textual data.
  ////////////////////////////////////////////////////////
  class String_Constant : public String ***REMOVED***
    ADD_PROPERTY(char, quote_mark)
    ADD_PROPERTY(bool, can_compress_whitespace)
    ADD_HASHED(std::string, value)
  protected:
    size_t hash_;
  public:
    String_Constant(ParserState pstate, std::string val)
    : String(pstate), quote_mark_(0), can_compress_whitespace_(false), value_(read_css_string(val)), hash_(0)
***REMOVED*** ***REMOVED***
    String_Constant(ParserState pstate, const char* beg)
    : String(pstate), quote_mark_(0), can_compress_whitespace_(false), value_(read_css_string(std::string(beg))), hash_(0)
***REMOVED*** ***REMOVED***
    String_Constant(ParserState pstate, const char* beg, const char* end)
    : String(pstate), quote_mark_(0), can_compress_whitespace_(false), value_(read_css_string(std::string(beg, end-beg))), hash_(0)
***REMOVED*** ***REMOVED***
    String_Constant(ParserState pstate, const Token& tok)
    : String(pstate), quote_mark_(0), can_compress_whitespace_(false), value_(read_css_string(std::string(tok.begin, tok.end))), hash_(0)
***REMOVED*** ***REMOVED***
    std::string type() ***REMOVED*** return "string"; ***REMOVED***
    static std::string type_name() ***REMOVED*** return "string"; ***REMOVED***

    virtual size_t hash()
***REMOVED***
      if (hash_ == 0) ***REMOVED***
        hash_ = std::hash<std::string>()(value_);
  ***REMOVED***
      return hash_;
***REMOVED***

    virtual bool operator==(const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;

    // static char auto_quote() ***REMOVED*** return '*'; ***REMOVED***
    static char double_quote() ***REMOVED*** return '"'; ***REMOVED***
    static char single_quote() ***REMOVED*** return '\''; ***REMOVED***

    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////
  // Possibly quoted string (unquote on instantiation)
  ////////////////////////////////////////////////////////
  class String_Quoted : public String_Constant ***REMOVED***
  public:
    String_Quoted(ParserState pstate, std::string val, char q = 0, bool keep_utf8_escapes = false)
    : String_Constant(pstate, val)
***REMOVED***
      value_ = unquote(value_, &quote_mark_, keep_utf8_escapes);
      if (q && quote_mark_) quote_mark_ = q;
***REMOVED***
    virtual bool operator==(const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////
  // Media queries.
  /////////////////
  class Media_Query : public Expression,
                      public Vectorized<Media_Query_Expression*> ***REMOVED***
    ADD_PROPERTY(String*, media_type)
    ADD_PROPERTY(bool, is_negated)
    ADD_PROPERTY(bool, is_restricted)
  public:
    Media_Query(ParserState pstate,
                String* t = 0, size_t s = 0, bool n = false, bool r = false)
    : Expression(pstate), Vectorized<Media_Query_Expression*>(s),
      media_type_(t), is_negated_(n), is_restricted_(r)
***REMOVED*** ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////
  // Media expressions (for use inside media queries).
  ////////////////////////////////////////////////////
  class Media_Query_Expression : public Expression ***REMOVED***
    ADD_PROPERTY(Expression*, feature)
    ADD_PROPERTY(Expression*, value)
    ADD_PROPERTY(bool, is_interpolated)
  public:
    Media_Query_Expression(ParserState pstate,
                           Expression* f, Expression* v, bool i = false)
    : Expression(pstate), feature_(f), value_(v), is_interpolated_(i)
***REMOVED*** ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////
  // `@supports` rule.
  ////////////////////
  class Supports_Block : public Has_Block ***REMOVED***
    ADD_PROPERTY(Supports_Condition*, condition)
  public:
    Supports_Block(ParserState pstate, Supports_Condition* condition, Block* block = 0)
    : Has_Block(pstate, block), condition_(condition)
***REMOVED*** statement_type(SUPPORTS); ***REMOVED***
    bool is_hoistable() ***REMOVED*** return true; ***REMOVED***
    bool bubbles() ***REMOVED*** return true; ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////////////////////////////////////////
  // The abstract superclass of all Supports conditions.
  //////////////////////////////////////////////////////
  class Supports_Condition : public Expression ***REMOVED***
  public:
    Supports_Condition(ParserState pstate)
    : Expression(pstate)
***REMOVED*** ***REMOVED***
    virtual bool needs_parens(Supports_Condition* cond) const ***REMOVED*** return false; ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////////
  // An operator condition (e.g. `CONDITION1 and CONDITION2`).
  ////////////////////////////////////////////////////////////
  class Supports_Operator : public Supports_Condition ***REMOVED***
  public:
    enum Operand ***REMOVED*** AND, OR ***REMOVED***;
  private:
    ADD_PROPERTY(Supports_Condition*, left);
    ADD_PROPERTY(Supports_Condition*, right);
    ADD_PROPERTY(Operand, operand);
  public:
    Supports_Operator(ParserState pstate, Supports_Condition* l, Supports_Condition* r, Operand o)
    : Supports_Condition(pstate), left_(l), right_(r), operand_(o)
***REMOVED*** ***REMOVED***
    virtual bool needs_parens(Supports_Condition* cond) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////////////////////////////
  // A negation condition (`not CONDITION`).
  //////////////////////////////////////////
  class Supports_Negation : public Supports_Condition ***REMOVED***
  private:
    ADD_PROPERTY(Supports_Condition*, condition);
  public:
    Supports_Negation(ParserState pstate, Supports_Condition* c)
    : Supports_Condition(pstate), condition_(c)
***REMOVED*** ***REMOVED***
    virtual bool needs_parens(Supports_Condition* cond) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////////////////////
  // A declaration condition (e.g. `(feature: value)`).
  /////////////////////////////////////////////////////
  class Supports_Declaration : public Supports_Condition ***REMOVED***
  private:
    ADD_PROPERTY(Expression*, feature);
    ADD_PROPERTY(Expression*, value);
  public:
    Supports_Declaration(ParserState pstate, Expression* f, Expression* v)
    : Supports_Condition(pstate), feature_(f), value_(v)
***REMOVED*** ***REMOVED***
    virtual bool needs_parens(Supports_Condition* cond) const ***REMOVED*** return false; ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////////////////////
  // An interpolation condition (e.g. `#***REMOVED***$var***REMOVED***`).
  ///////////////////////////////////////////////
  class Supports_Interpolation : public Supports_Condition ***REMOVED***
  private:
    ADD_PROPERTY(Expression*, value);
  public:
    Supports_Interpolation(ParserState pstate, Expression* v)
    : Supports_Condition(pstate), value_(v)
***REMOVED*** ***REMOVED***
    virtual bool needs_parens(Supports_Condition* cond) const ***REMOVED*** return false; ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////////////////
  // At root expressions (for use inside @at-root).
  /////////////////////////////////////////////////
  class At_Root_Expression : public Expression ***REMOVED***
  private:
    ADD_PROPERTY(String*, feature)
    ADD_PROPERTY(Expression*, value)
    ADD_PROPERTY(bool, is_interpolated)
  public:
    At_Root_Expression(ParserState pstate, String* f = 0, Expression* v = 0, bool i = false)
    : Expression(pstate), feature_(f), value_(v), is_interpolated_(i)
***REMOVED*** ***REMOVED***
    bool exclude(std::string str)
***REMOVED***
      To_String to_string;
      bool with = feature() && unquote(feature()->perform(&to_string)).compare("with") == 0;
      List* l = static_cast<List*>(value());
      std::string v;

      if (with)
  ***REMOVED***
        if (!l || l->length() == 0) return str.compare("rule") != 0;
        for (size_t i = 0, L = l->length(); i < L; ++i)
***REMOVED***
          v = unquote((*l)[i]->perform(&to_string));
          if (v.compare("all") == 0 || v == str) return false;
***REMOVED***
        return true;
  ***REMOVED***
      else
  ***REMOVED***
        if (!l || !l->length()) return str.compare("rule") == 0;
        for (size_t i = 0, L = l->length(); i < L; ++i)
***REMOVED***
          v = unquote((*l)[i]->perform(&to_string));
          if (v.compare("all") == 0 || v == str) return true;
***REMOVED***
        return false;
  ***REMOVED***
***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////
  // At-root.
  ///////////
  class At_Root_Block : public Has_Block ***REMOVED***
    ADD_PROPERTY(At_Root_Expression*, expression)
  public:
    At_Root_Block(ParserState pstate, Block* b = 0, At_Root_Expression* e = 0)
    : Has_Block(pstate, b), expression_(e)
***REMOVED*** statement_type(ATROOT); ***REMOVED***
    bool is_hoistable() ***REMOVED*** return true; ***REMOVED***
    bool bubbles() ***REMOVED*** return true; ***REMOVED***
    bool exclude_node(Statement* s) ***REMOVED***
      if (s->statement_type() == Statement::DIRECTIVE)
  ***REMOVED***
        return expression()->exclude(static_cast<At_Rule*>(s)->keyword().erase(0, 1));
  ***REMOVED***
      if (s->statement_type() == Statement::MEDIA)
  ***REMOVED***
        return expression()->exclude("media");
  ***REMOVED***
      if (s->statement_type() == Statement::RULESET)
  ***REMOVED***
        return expression()->exclude("rule");
  ***REMOVED***
      if (s->statement_type() == Statement::SUPPORTS)
  ***REMOVED***
        return expression()->exclude("supports");
  ***REMOVED***
      if (static_cast<At_Rule*>(s)->is_keyframes())
  ***REMOVED***
        return expression()->exclude("keyframes");
  ***REMOVED***
      return false;
***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////
  // The null value.
  //////////////////
  class Null : public Value ***REMOVED***
  public:
    Null(ParserState pstate) : Value(pstate) ***REMOVED*** concrete_type(NULL_VAL); ***REMOVED***
    std::string type() ***REMOVED*** return "null"; ***REMOVED***
    static std::string type_name() ***REMOVED*** return "null"; ***REMOVED***
    bool is_invisible() const ***REMOVED*** return true; ***REMOVED***
    operator bool() ***REMOVED*** return false; ***REMOVED***
    bool is_false() ***REMOVED*** return true; ***REMOVED***

    virtual size_t hash()
***REMOVED***
      return -1;
***REMOVED***

    virtual bool operator== (const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;

    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////
  // Thunks for delayed evaluation.
  /////////////////////////////////
  class Thunk : public Expression ***REMOVED***
    ADD_PROPERTY(Expression*, expression)
    ADD_PROPERTY(Env*, environment)
  public:
    Thunk(ParserState pstate, Expression* exp, Env* env = 0)
    : Expression(pstate), expression_(exp), environment_(env)
***REMOVED*** ***REMOVED***
  ***REMOVED***;

  /////////////////////////////////////////////////////////
  // Individual parameter objects for mixins and functions.
  /////////////////////////////////////////////////////////
  class Parameter : public AST_Node ***REMOVED***
    ADD_PROPERTY(std::string, name)
    ADD_PROPERTY(Expression*, default_value)
    ADD_PROPERTY(bool, is_rest_parameter)
  public:
    Parameter(ParserState pstate,
              std::string n, Expression* def = 0, bool rest = false)
    : AST_Node(pstate), name_(n), default_value_(def), is_rest_parameter_(rest)
***REMOVED***
      if (default_value_ && is_rest_parameter_) ***REMOVED***
        error("variable-length parameter may not have a default value", pstate);
  ***REMOVED***
***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////////////////////////////////////////
  // Parameter lists -- in their own class to facilitate context-sensitive
  // error checking (e.g., ensuring that all optional parameters follow all
  // required parameters).
  /////////////////////////////////////////////////////////////////////////
  class Parameters : public AST_Node, public Vectorized<Parameter*> ***REMOVED***
    ADD_PROPERTY(bool, has_optional_parameters)
    ADD_PROPERTY(bool, has_rest_parameter)
  protected:
    void adjust_after_pushing(Parameter* p)
***REMOVED***
      if (p->default_value()) ***REMOVED***
        if (has_rest_parameter_) ***REMOVED***
          error("optional parameters may not be combined with variable-length parameters", p->pstate());
***REMOVED***
        has_optional_parameters_ = true;
  ***REMOVED***
      else if (p->is_rest_parameter()) ***REMOVED***
        if (has_rest_parameter_) ***REMOVED***
          error("functions and mixins cannot have more than one variable-length parameter", p->pstate());
***REMOVED***
        has_rest_parameter_ = true;
  ***REMOVED***
      else ***REMOVED***
        if (has_rest_parameter_) ***REMOVED***
          error("required parameters must precede variable-length parameters", p->pstate());
***REMOVED***
        if (has_optional_parameters_) ***REMOVED***
          error("required parameters must precede optional parameters", p->pstate());
***REMOVED***
  ***REMOVED***
***REMOVED***
  public:
    Parameters(ParserState pstate)
    : AST_Node(pstate),
      Vectorized<Parameter*>(),
      has_optional_parameters_(false),
      has_rest_parameter_(false)
***REMOVED*** ***REMOVED***
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////////
  // Abstract base class for CSS selectors.
  /////////////////////////////////////////
  class Selector : public Expression ***REMOVED***
    ADD_PROPERTY(bool, has_reference)
    ADD_PROPERTY(bool, has_placeholder)
    // line break before list separator
    ADD_PROPERTY(bool, has_line_feed)
    // line break after list separator
    ADD_PROPERTY(bool, has_line_break)
    // maybe we have optional flag
    ADD_PROPERTY(bool, is_optional)
    // parent block pointers
    ADD_PROPERTY(Media_Block*, media_block)
  public:
    Selector(ParserState pstate, bool r = false, bool h = false)
    : Expression(pstate),
      has_reference_(r),
      has_placeholder_(h),
      has_line_feed_(false),
      has_line_break_(false),
      is_optional_(false),
      media_block_(0)
***REMOVED*** concrete_type(SELECTOR); ***REMOVED***
    virtual ~Selector() = 0;
    virtual unsigned long specificity() ***REMOVED***
      return Constants::Specificity_Universal;
***REMOVED***
    virtual std::string to_string(bool compressed = false, int precision = 5) const = 0;
  ***REMOVED***;
  inline Selector::~Selector() ***REMOVED*** ***REMOVED***

  /////////////////////////////////////////////////////////////////////////
  // Interpolated selectors -- the interpolated String will be expanded and
  // re-parsed into a normal selector class.
  /////////////////////////////////////////////////////////////////////////
  class Selector_Schema : public Selector ***REMOVED***
    ADD_PROPERTY(String*, contents)
    ADD_PROPERTY(bool, at_root);
  public:
    Selector_Schema(ParserState pstate, String* c)
    : Selector(pstate), contents_(c), at_root_(false)
***REMOVED*** ***REMOVED***
    virtual std::string to_string(bool compressed = false, int precision = 5) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////
  // Abstract base class for simple selectors.
  ////////////////////////////////////////////
  class Simple_Selector : public Selector ***REMOVED***
    ADD_PROPERTY(std::string, ns);
    ADD_PROPERTY(std::string, name)
    ADD_PROPERTY(bool, has_ns)
  public:
    Simple_Selector(ParserState pstate, std::string n = "")
    : Selector(pstate), ns_(""), name_(n), has_ns_(false)
***REMOVED***
      size_t pos = n.find('|');
      // found some namespace
      if (pos != std::string::npos) ***REMOVED***
        has_ns_ = true;
        ns_ = n.substr(0, pos);
        name_ = n.substr(pos + 1);
  ***REMOVED***
***REMOVED***
    virtual std::string ns_name() const
***REMOVED***
      std::string name("");
      if (has_ns_)
        name += ns_ + "|";
      return name + name_;
***REMOVED***
    // namespace query functions
    bool is_universal_ns() const
***REMOVED***
      return has_ns_ && ns_ == "*";
***REMOVED***
    bool has_universal_ns() const
***REMOVED***
      return !has_ns_ || ns_ == "*";
***REMOVED***
    bool is_empty_ns() const
***REMOVED***
      return !has_ns_ || ns_ == "";
***REMOVED***
    bool has_empty_ns() const
***REMOVED***
      return has_ns_ && ns_ == "";
***REMOVED***
    bool has_qualified_ns() const
***REMOVED***
      return has_ns_ && ns_ != "" && ns_ != "*";
***REMOVED***
    // name query functions
    bool is_universal() const
***REMOVED***
      return name_ == "*";
***REMOVED***

    virtual ~Simple_Selector() = 0;
    virtual Compound_Selector* unify_with(Compound_Selector*, Context&);
    virtual bool has_parent_ref() ***REMOVED*** return false; ***REMOVED***;
    virtual bool is_pseudo_element() ***REMOVED*** return false; ***REMOVED***
    virtual bool is_pseudo_class() ***REMOVED*** return false; ***REMOVED***

    virtual bool is_superselector_of(Compound_Selector* sub) ***REMOVED*** return false; ***REMOVED***

    bool operator==(const Simple_Selector& rhs) const;
    inline bool operator!=(const Simple_Selector& rhs) const ***REMOVED*** return !(*this == rhs); ***REMOVED***

    bool operator<(const Simple_Selector& rhs) const;
    // default implementation should work for most of the simple selectors (otherwise overload)
    virtual std::string to_string(bool compressed = false, int precision = 5) const ***REMOVED*** return this->ns_name(); ***REMOVED***;
    ATTACH_OPERATIONS();
  ***REMOVED***;
  inline Simple_Selector::~Simple_Selector() ***REMOVED*** ***REMOVED***


  //////////////////////////////////
  // The Parent Selector Expression.
  //////////////////////////////////
  // parent selectors can occur in selectors but also
  // inside strings in declarations (Compound_Selector).
  // only one simple parent selector means the first case.
  class Parent_Selector : public Simple_Selector ***REMOVED***
  public:
    Parent_Selector(ParserState pstate)
    : Simple_Selector(pstate, "&")
***REMOVED*** has_reference(true); ***REMOVED***
    virtual bool has_parent_ref() ***REMOVED*** return true; ***REMOVED***;
    virtual unsigned long specificity()
***REMOVED***
      return 0;
***REMOVED***
    std::string type() ***REMOVED*** return "selector"; ***REMOVED***
    static std::string type_name() ***REMOVED*** return "selector"; ***REMOVED***
    virtual std::string to_string(bool compressed = false, int precision = 5) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////////////////////////////////////////
  // Placeholder selectors (e.g., "%foo") for use in extend-only selectors.
  /////////////////////////////////////////////////////////////////////////
  class Selector_Placeholder : public Simple_Selector ***REMOVED***
  public:
    Selector_Placeholder(ParserState pstate, std::string n)
    : Simple_Selector(pstate, n)
***REMOVED*** has_placeholder(true); ***REMOVED***
    // virtual Selector_Placeholder* find_placeholder();
    virtual ~Selector_Placeholder() ***REMOVED******REMOVED***;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////////////////////////////////////
  // Type selectors (and the universal selector) -- e.g., div, span, *.
  /////////////////////////////////////////////////////////////////////
  class Type_Selector : public Simple_Selector ***REMOVED***
  public:
    Type_Selector(ParserState pstate, std::string n)
    : Simple_Selector(pstate, n)
***REMOVED*** ***REMOVED***
    virtual unsigned long specificity()
***REMOVED***
      // ToDo: What is the specificity of the star selector?
      if (name() == "*") return Constants::Specificity_Universal;
      else               return Constants::Specificity_Type;
***REMOVED***
    virtual Simple_Selector* unify_with(Simple_Selector*, Context&);
    virtual Compound_Selector* unify_with(Compound_Selector*, Context&);
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////
  // Selector qualifiers -- i.e., classes and ids.
  ////////////////////////////////////////////////
  class Selector_Qualifier : public Simple_Selector ***REMOVED***
  public:
    Selector_Qualifier(ParserState pstate, std::string n)
    : Simple_Selector(pstate, n)
***REMOVED*** ***REMOVED***
    virtual unsigned long specificity()
***REMOVED***
      if (name()[0] == '#') return Constants::Specificity_ID;
      if (name()[0] == '.') return Constants::Specificity_Class;
      else                  return Constants::Specificity_Type;
***REMOVED***
    virtual Compound_Selector* unify_with(Compound_Selector*, Context&);
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ///////////////////////////////////////////////////
  // Attribute selectors -- e.g., [src*=".jpg"], etc.
  ///////////////////////////////////////////////////
  class Attribute_Selector : public Simple_Selector ***REMOVED***
    ADD_PROPERTY(std::string, matcher)
    ADD_PROPERTY(String*, value) // might be interpolated
  public:
    Attribute_Selector(ParserState pstate, std::string n, std::string m, String* v)
    : Simple_Selector(pstate, n), matcher_(m), value_(v)
***REMOVED*** ***REMOVED***
    virtual unsigned long specificity()
***REMOVED***
      return Constants::Specificity_Attr;
***REMOVED***
    bool operator==(const Simple_Selector& rhs) const;
    bool operator==(const Attribute_Selector& rhs) const;
    bool operator<(const Simple_Selector& rhs) const;
    bool operator<(const Attribute_Selector& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  //////////////////////////////////////////////////////////////////
  // Pseudo selectors -- e.g., :first-child, :nth-of-type(...), etc.
  //////////////////////////////////////////////////////////////////
  /* '::' starts a pseudo-element, ':' a pseudo-class */
  /* Except :first-line, :first-letter, :before and :after */
  /* Note that pseudo-elements are restricted to one per selector */
  /* and occur only in the last simple_selector_sequence. */
  inline bool is_pseudo_class_element(const std::string& name)
  ***REMOVED***
    return name == ":before"       ||
           name == ":after"        ||
           name == ":first-line"   ||
           name == ":first-letter";
  ***REMOVED***

  class Pseudo_Selector : public Simple_Selector ***REMOVED***
    ADD_PROPERTY(String*, expression)
  public:
    Pseudo_Selector(ParserState pstate, std::string n, String* expr = 0)
    : Simple_Selector(pstate, n), expression_(expr)
***REMOVED*** ***REMOVED***

    // A pseudo-class always consists of a "colon" (:) followed by the name
    // of the pseudo-class and optionally by a value between parentheses.
    virtual bool is_pseudo_class()
***REMOVED***
      return (name_[0] == ':' && name_[1] != ':')
             && ! is_pseudo_class_element(name_);
***REMOVED***

    // A pseudo-element is made of two colons (::) followed by the name.
    // The `::` notation is introduced by the current document in order to
    // establish a discrimination between pseudo-classes and pseudo-elements.
    // For compatibility with existing style sheets, user agents must also
    // accept the previous one-colon notation for pseudo-elements introduced
    // in CSS levels 1 and 2 (namely, :first-line, :first-letter, :before and
    // :after). This compatibility is not allowed for the new pseudo-elements
    // introduced in this specification.
    virtual bool is_pseudo_element()
***REMOVED***
      return (name_[0] == ':' && name_[1] == ':')
             || is_pseudo_class_element(name_);
***REMOVED***
    virtual unsigned long specificity()
***REMOVED***
      if (is_pseudo_element())
        return Constants::Specificity_Type;
      return Constants::Specificity_Pseudo;
***REMOVED***
    virtual Compound_Selector* unify_with(Compound_Selector*, Context&);
    ATTACH_OPERATIONS()
  ***REMOVED***;

  /////////////////////////////////////////////////
  // Wrapped selector -- pseudo selector that takes a list of selectors as argument(s) e.g., :not(:first-of-type), :-moz-any(ol p.blah, ul, menu, dir)
  /////////////////////////////////////////////////
  class Wrapped_Selector : public Simple_Selector ***REMOVED***
    ADD_PROPERTY(Selector*, selector)
  public:
    Wrapped_Selector(ParserState pstate, std::string n, Selector* sel)
    : Simple_Selector(pstate, n), selector_(sel)
***REMOVED*** ***REMOVED***
    virtual bool is_superselector_of(Wrapped_Selector* sub);
    // Selectors inside the negation pseudo-class are counted like any
    // other, but the negation itself does not count as a pseudo-class.
    virtual unsigned long specificity()
***REMOVED***
      return selector_ ? selector_->specificity() : 0;
***REMOVED***
    bool operator==(const Simple_Selector& rhs) const;
    bool operator==(const Wrapped_Selector& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  struct Complex_Selector_Pointer_Compare ***REMOVED***
    bool operator() (const Complex_Selector* const pLeft, const Complex_Selector* const pRight) const;
  ***REMOVED***;

  ////////////////////////////////////////////////////////////////////////////
  // Simple selector sequences. Maintains flags indicating whether it contains
  // any parent references or placeholders, to simplify expansion.
  ////////////////////////////////////////////////////////////////////////////
  typedef std::set<Complex_Selector*, Complex_Selector_Pointer_Compare> SourcesSet;
  class Compound_Selector : public Selector, public Vectorized<Simple_Selector*> ***REMOVED***
  private:
    SourcesSet sources_;
    ADD_PROPERTY(bool, has_parent_reference);
  protected:
    void adjust_after_pushing(Simple_Selector* s)
***REMOVED***
      if (s->has_reference())   has_reference(true);
      if (s->has_placeholder()) has_placeholder(true);
***REMOVED***
  public:
    Compound_Selector(ParserState pstate, size_t s = 0)
    : Selector(pstate),
      Vectorized<Simple_Selector*>(s),
      has_parent_reference_(false)
***REMOVED*** ***REMOVED***
    bool contains_placeholder() ***REMOVED***
      for (size_t i = 0, L = length(); i < L; ++i) ***REMOVED***
        if ((*this)[i]->has_placeholder()) return true;
  ***REMOVED***
      return false;
***REMOVED***;

    bool is_universal() const
***REMOVED***
      return length() == 1 && (*this)[0]->is_universal();
***REMOVED***

    Complex_Selector* to_complex(Memory_Manager& mem);
    Compound_Selector* unify_with(Compound_Selector* rhs, Context& ctx);
    // virtual Selector_Placeholder* find_placeholder();
    virtual bool has_parent_ref();
    Simple_Selector* base()
***REMOVED***
      // Implement non-const in terms of const. Safe to const_cast since this method is non-const
      return const_cast<Simple_Selector*>(static_cast<const Compound_Selector*>(this)->base());
***REMOVED***
    const Simple_Selector* base() const ***REMOVED***
      if (length() == 0) return 0;
      if (typeid(*(*this)[0]) == typeid(Type_Selector))
        return (*this)[0];
//      else cerr << "SERIOUSELY " << "\n";
      return 0;
***REMOVED***
    virtual bool is_superselector_of(Compound_Selector* sub, std::string wrapped = "");
    virtual bool is_superselector_of(Complex_Selector* sub, std::string wrapped = "");
    virtual bool is_superselector_of(Selector_List* sub, std::string wrapped = "");
    virtual unsigned long specificity()
***REMOVED***
      int sum = 0;
      for (size_t i = 0, L = length(); i < L; ++i)
  ***REMOVED*** sum += (*this)[i]->specificity(); ***REMOVED***
      return sum;
***REMOVED***

    bool is_empty_reference()
***REMOVED***
      return length() == 1 &&
             typeid(*(*this)[0]) == typeid(Parent_Selector);
***REMOVED***
    std::vector<std::string> to_str_vec(); // sometimes need to convert to a flat "by-value" data structure

    bool operator<(const Compound_Selector& rhs) const;

    bool operator==(const Compound_Selector& rhs) const;
    inline bool operator!=(const Compound_Selector& rhs) const ***REMOVED*** return !(*this == rhs); ***REMOVED***

    SourcesSet& sources() ***REMOVED*** return sources_; ***REMOVED***
    void clearSources() ***REMOVED*** sources_.clear(); ***REMOVED***
    void mergeSources(SourcesSet& sources, Context& ctx);

    Compound_Selector* clone(Context&) const; // does not clone the Simple_Selector*s

    Compound_Selector* minus(Compound_Selector* rhs, Context& ctx);
    virtual std::string to_string(bool compressed = false, int precision = 5) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  ////////////////////////////////////////////////////////////////////////////
  // General selectors -- i.e., simple sequences combined with one of the four
  // CSS selector combinators (">", "+", "~", and whitespace). Essentially a
  // linked list.
  ////////////////////////////////////////////////////////////////////////////
  class Complex_Selector : public Selector ***REMOVED***
  public:
    enum Combinator ***REMOVED*** ANCESTOR_OF, PARENT_OF, PRECEDES, ADJACENT_TO, REFERENCE ***REMOVED***;
  private:
    ADD_PROPERTY(Combinator, combinator)
    ADD_PROPERTY(Compound_Selector*, head)
    ADD_PROPERTY(Complex_Selector*, tail)
    ADD_PROPERTY(String*, reference);
  public:
    bool contains_placeholder() ***REMOVED***
      if (head() && head()->contains_placeholder()) return true;
      if (tail() && tail()->contains_placeholder()) return true;
      return false;
***REMOVED***;
    Complex_Selector(ParserState pstate,
                     Combinator c = ANCESTOR_OF,
                     Compound_Selector* h = 0,
                     Complex_Selector* t = 0,
                     String* r = 0)
    : Selector(pstate),
      combinator_(c),
      head_(h), tail_(t),
      reference_(r)
***REMOVED***
      if ((h && h->has_reference())   || (t && t->has_reference()))   has_reference(true);
      if ((h && h->has_placeholder()) || (t && t->has_placeholder())) has_placeholder(true);
***REMOVED***
    virtual bool has_parent_ref();

    Complex_Selector* skip_empty_reference()
***REMOVED***
      if ((!head_ || !head_->length() || head_->is_empty_reference()) &&
          combinator() == Combinator::ANCESTOR_OF)
  ***REMOVED***
        if (!tail_) return 0;
        tail_->has_line_feed_ = this->has_line_feed_;
        // tail_->has_line_break_ = this->has_line_break_;
        return tail_->skip_empty_reference();
  ***REMOVED***
      return this;
***REMOVED***

    // can still have a tail
    bool is_empty_ancestor() const
***REMOVED***
      return (!head() || head()->length() == 0) &&
             combinator() == Combinator::ANCESTOR_OF;
***REMOVED***

    Complex_Selector* context(Context&);


    // front returns the first real tail
    // skips over parent and empty ones
    const Complex_Selector* first() const;

    // last returns the last real tail
    const Complex_Selector* last() const;

    Selector_List* tails(Context& ctx, Selector_List* tails);

    // unconstant accessors
    Complex_Selector* first();
    Complex_Selector* last();

    // some shortcuts that should be removed
    const Complex_Selector* innermost() const ***REMOVED*** return last(); ***REMOVED***;
    Complex_Selector* innermost() ***REMOVED*** return last(); ***REMOVED***;

    size_t length() const;
    Selector_List* parentize(Selector_List* parents, Context& ctx);
    virtual bool is_superselector_of(Compound_Selector* sub, std::string wrapping = "");
    virtual bool is_superselector_of(Complex_Selector* sub, std::string wrapping = "");
    virtual bool is_superselector_of(Selector_List* sub, std::string wrapping = "");
    // virtual Selector_Placeholder* find_placeholder();
    Selector_List* unify_with(Complex_Selector* rhs, Context& ctx);
    Combinator clear_innermost();
    void append(Context&, Complex_Selector*);
    void set_innermost(Complex_Selector*, Combinator);
    virtual unsigned long specificity() const
***REMOVED***
      int sum = 0;
      if (head()) sum += head()->specificity();
      if (tail()) sum += tail()->specificity();
      return sum;
***REMOVED***
    bool operator<(const Complex_Selector& rhs) const;
    bool operator==(const Complex_Selector& rhs) const;
    inline bool operator!=(const Complex_Selector& rhs) const ***REMOVED*** return !(*this == rhs); ***REMOVED***
    SourcesSet sources()
***REMOVED***
      //s = Set.new
      //seq.map ***REMOVED***|sseq_or_op| s.merge sseq_or_op.sources if sseq_or_op.is_a?(SimpleSequence)***REMOVED***
      //s

      SourcesSet srcs;

      Compound_Selector* pHead = head();
      Complex_Selector*  pTail = tail();

      if (pHead) ***REMOVED***
        SourcesSet& headSources = pHead->sources();
        srcs.insert(headSources.begin(), headSources.end());
  ***REMOVED***

      if (pTail) ***REMOVED***
        SourcesSet tailSources = pTail->sources();
        srcs.insert(tailSources.begin(), tailSources.end());
  ***REMOVED***

      return srcs;
***REMOVED***
    void addSources(SourcesSet& sources, Context& ctx) ***REMOVED***
      // members.map! ***REMOVED***|m| m.is_a?(SimpleSequence) ? m.with_more_sources(sources) : m***REMOVED***
      Complex_Selector* pIter = this;
      while (pIter) ***REMOVED***
        Compound_Selector* pHead = pIter->head();

        if (pHead) ***REMOVED***
          pHead->mergeSources(sources, ctx);
***REMOVED***

        pIter = pIter->tail();
  ***REMOVED***
***REMOVED***
    void clearSources() ***REMOVED***
      Complex_Selector* pIter = this;
      while (pIter) ***REMOVED***
        Compound_Selector* pHead = pIter->head();

        if (pHead) ***REMOVED***
          pHead->clearSources();
***REMOVED***

        pIter = pIter->tail();
  ***REMOVED***
***REMOVED***
    Complex_Selector* clone(Context&) const;      // does not clone Compound_Selector*s
    Complex_Selector* cloneFully(Context&) const; // clones Compound_Selector*s
    // std::vector<Compound_Selector*> to_vector();
    virtual std::string to_string(bool compressed = false, int precision = 5) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  typedef std::deque<Complex_Selector*> ComplexSelectorDeque;
  typedef Subset_Map<std::string, std::pair<Complex_Selector*, Compound_Selector*> > ExtensionSubsetMap;

  ///////////////////////////////////
  // Comma-separated selector groups.
  ///////////////////////////////////
  class Selector_List : public Selector, public Vectorized<Complex_Selector*> ***REMOVED***
    ADD_PROPERTY(std::vector<std::string>, wspace)
  protected:
    void adjust_after_pushing(Complex_Selector* c);
  public:
    Selector_List(ParserState pstate, size_t s = 0)
    : Selector(pstate), Vectorized<Complex_Selector*>(s), wspace_(0)
***REMOVED*** ***REMOVED***
    std::string type() ***REMOVED*** return "list"; ***REMOVED***
    // remove parent selector references
    // basically unwraps parsed selectors
    void remove_parent_selectors();
    // virtual Selector_Placeholder* find_placeholder();
    Selector_List* parentize(Selector_List* parents, Context& ctx);
    virtual bool is_superselector_of(Compound_Selector* sub, std::string wrapping = "");
    virtual bool is_superselector_of(Complex_Selector* sub, std::string wrapping = "");
    virtual bool is_superselector_of(Selector_List* sub, std::string wrapping = "");
    Selector_List* unify_with(Selector_List*, Context&);
    void populate_extends(Selector_List*, Context&, ExtensionSubsetMap&);
    virtual unsigned long specificity()
***REMOVED***
      unsigned long sum = 0;
      unsigned long specificity = 0;
      for (size_t i = 0, L = length(); i < L; ++i)
  ***REMOVED***
        specificity = (*this)[i]->specificity();
        if (sum < specificity) sum = specificity;
  ***REMOVED***
      return sum;
***REMOVED***
    Selector_List* clone(Context&) const;      // does not clone Compound_Selector*s
    Selector_List* cloneFully(Context&) const; // clones Compound_Selector*s
    virtual bool operator==(const Selector& rhs) const;
    virtual bool operator==(const Selector_List& rhs) const;
    // Selector Lists can be compared to comma lists
    virtual bool operator==(const Expression& rhs) const;
    virtual std::string to_string(bool compressed = false, int precision = 5) const;
    ATTACH_OPERATIONS()
  ***REMOVED***;

  template<typename SelectorType>
  bool selectors_equal(const SelectorType& one, const SelectorType& two, bool simpleSelectorOrderDependent) ***REMOVED***
    // Test for equality among selectors while differentiating between checks that demand the underlying Simple_Selector
    // ordering to be the same or not. This works because operator< (which doesn't make a whole lot of sense for selectors, but
    // is required for proper stl collection ordering) is implemented using string comparision. This gives stable sorting
    // behavior, and can be used to determine if the selectors would have exactly idential output. operator== matches the
    // ruby sass implementations for eql, which sometimes perform order independent comparisions (like set comparisons of the
    // members of a SimpleSequence (Compound_Selector)).
    //
    // Due to the reliance on operator== and operater< behavior, this templated method is currently only intended for
    // use with Compound_Selector and Complex_Selector objects.
    if (simpleSelectorOrderDependent) ***REMOVED***
      return !(one < two) && !(two < one);
***REMOVED*** else ***REMOVED***
      return one == two;
***REMOVED***
  ***REMOVED***

  // compare function for sorting and probably other other uses
  struct cmp_complex_selector ***REMOVED*** inline bool operator() (const Complex_Selector* l, const Complex_Selector* r) ***REMOVED*** return (*l < *r); ***REMOVED*** ***REMOVED***;
  struct cmp_compound_selector ***REMOVED*** inline bool operator() (const Compound_Selector* l, const Compound_Selector* r) ***REMOVED*** return (*l < *r); ***REMOVED*** ***REMOVED***;
  struct cmp_simple_selector ***REMOVED*** inline bool operator() (const Simple_Selector* l, const Simple_Selector* r) ***REMOVED*** return (*l < *r); ***REMOVED*** ***REMOVED***;

***REMOVED***

#ifdef __clang__

#pragma clang diagnostic pop

#endif

#endif
