#include "bind.hpp"
#include "ast.hpp"
#include "context.hpp"
#include "eval.hpp"
#include <map>
#include <iostream>
#include <sstream>
#include "to_string.hpp"

namespace Sass ***REMOVED***

  void bind(std::string type, std::string name, Parameters* ps, Arguments* as, Context* ctx, Env* env, Eval* eval)
  ***REMOVED***
    std::string callee(type + " " + name);
    Listize listize(*ctx);
    std::map<std::string, Parameter*> param_map;

    for (size_t i = 0, L = as->length(); i < L; ++i) ***REMOVED***
      if (auto str = dynamic_cast<String_Quoted*>((*as)[i]->value())) ***REMOVED***
        // force optional quotes (only if needed)
        if (str->quote_mark()) ***REMOVED***
          str->quote_mark('*');
          str->is_delayed(true);
***REMOVED***
  ***REMOVED***
***REMOVED***

    // Set up a map to ensure named arguments refer to actual parameters. Also
    // eval each default value left-to-right, wrt env, populating env as we go.
    for (size_t i = 0, L = ps->length(); i < L; ++i) ***REMOVED***
      Parameter*  p = (*ps)[i];
      param_map[p->name()] = p;
      // if (p->default_value()) ***REMOVED***
      //   env->local_frame()[p->name()] = p->default_value()->perform(eval->with(env));
      // ***REMOVED***
***REMOVED***

    // plug in all args; if we have leftover params, deal with it later
    size_t ip = 0, LP = ps->length();
    size_t ia = 0, LA = as->length();
    while (ia < LA) ***REMOVED***
      Argument* a = (*as)[ia];
      if (ip >= LP) ***REMOVED***
        // skip empty rest arguments
        if (a->is_rest_argument()) ***REMOVED***
          if (List* l = dynamic_cast<List*>(a->value())) ***REMOVED***
            if (l->length() == 0) ***REMOVED***
              ++ ia; continue;
***REMOVED***
  ***REMOVED***
***REMOVED***
        std::stringstream msg;
        msg << "wrong number of arguments (" << LA << " for " << LP << ")";
        msg << " for `" << name << "'";
        return error(msg.str(), as->pstate());
  ***REMOVED***
      Parameter* p = (*ps)[ip];

      // If the current parameter is the rest parameter, process and break the loop
      if (p->is_rest_parameter()) ***REMOVED***
        // The next argument by coincidence provides a rest argument
        if (a->is_rest_argument()) ***REMOVED***
          // We should always get a list for rest arguments
          if (List* rest = dynamic_cast<List*>(a->value())) ***REMOVED***
            // arg contains a list
            List* args = rest;
            // make sure it's an arglist
            if (rest->is_arglist()) ***REMOVED***
              // can pass it through as it was
              env->local_frame()[p->name()] = args;
***REMOVED***
            // create a new list and wrap each item as an argument
            // otherwise we will not be able to fetch it again
            else ***REMOVED***
              // create a new list object for wrapped items
              List* arglist = SASS_MEMORY_NEW(ctx->mem, List,
                                              p->pstate(),
                                              0,
                                              rest->separator(),
                                              true);
              // wrap each item from list as an argument
              for (Expression* item : rest->elements()) ***REMOVED***
                (*arglist) << SASS_MEMORY_NEW(ctx->mem, Argument,
                                              item->pstate(),
                                              item,
                                              "",
                                              false,
                                              false);
  ***REMOVED***
              // assign new arglist to environment
              env->local_frame()[p->name()] = arglist;
***REMOVED***
  ***REMOVED***
          // invalid state
          else ***REMOVED***
            throw std::runtime_error("invalid state");
  ***REMOVED***
***REMOVED*** else if (a->is_keyword_argument()) ***REMOVED***

          // expand keyword arguments into their parameters
          List* arglist = SASS_MEMORY_NEW(ctx->mem, List, p->pstate(), 0, SASS_COMMA, true);
          env->local_frame()[p->name()] = arglist;
          Map* argmap = static_cast<Map*>(a->value());
          for (auto key : argmap->keys()) ***REMOVED***
            std::string name = unquote(static_cast<String_Constant*>(key)->value());
            (*arglist) << SASS_MEMORY_NEW(ctx->mem, Argument,
                                          key->pstate(),
                                          argmap->at(key),
                                          "$" + name,
                                          false,
                                          false);
  ***REMOVED***

***REMOVED*** else ***REMOVED***

          // create a new list object for wrapped items
          List* arglist = SASS_MEMORY_NEW(ctx->mem, List,
                                          p->pstate(),
                                          0,
                                          SASS_COMMA,
                                          true);
          // consume the next args
          while (ia < LA) ***REMOVED***
            // get and post inc
            a = (*as)[ia++];
            // maybe we have another list as argument
            List* ls = dynamic_cast<List*>(a->value());
            // skip any list completely if empty
            if (ls && ls->empty() && a->is_rest_argument()) continue;
            // flatten all nested arglists
            if (ls && ls->is_arglist()) ***REMOVED***
              for (size_t i = 0, L = ls->size(); i < L; ++i) ***REMOVED***
                // already have a wrapped argument
                if (Argument* arg = dynamic_cast<Argument*>((*ls)[i])) ***REMOVED***
                  (*arglist) << SASS_MEMORY_NEW(ctx->mem, Argument, *arg);
***REMOVED***
                // wrap all other value types into Argument
                else ***REMOVED***
                  (*arglist) << SASS_MEMORY_NEW(ctx->mem, Argument,
                                                (*ls)[i]->pstate(),
                                                (*ls)[i],
                                                "",
                                                false,
                                                false);
***REMOVED***
  ***REMOVED***
***REMOVED***
            // already have a wrapped argument
            else if (Argument* arg = dynamic_cast<Argument*>(a->value())) ***REMOVED***
              (*arglist) << SASS_MEMORY_NEW(ctx->mem, Argument, *arg);
***REMOVED***
            // wrap all other value types into Argument
            else ***REMOVED***
              (*arglist) << SASS_MEMORY_NEW(ctx->mem, Argument,
                                            a->pstate(),
                                            a->value(),
                                            a->name(),
                                            false,
                                            false);
***REMOVED***
            // check if we have rest argument
            if (a->is_rest_argument()) ***REMOVED***
              // preserve the list separator from rest args
              if (List* rest = dynamic_cast<List*>(a->value())) ***REMOVED***
                arglist->separator(rest->separator());
  ***REMOVED***
              // no more arguments
              break;
***REMOVED***
  ***REMOVED***
          // assign new arglist to environment
          env->local_frame()[p->name()] = arglist;
***REMOVED***
        // consumed parameter
        ++ip;
        // no more paramaters
        break;
  ***REMOVED***

      // If the current argument is the rest argument, extract a value for processing
      else if (a->is_rest_argument()) ***REMOVED***
        // normal param and rest arg
        List* arglist = static_cast<List*>(a->value());
        // empty rest arg - treat all args as default values
        if (!arglist->length()) ***REMOVED***
          break;
***REMOVED*** else ***REMOVED***
          if (arglist->length() + ia > LP && !ps->has_rest_parameter()) ***REMOVED***
            int arg_count = (arglist->length() + LA - 1);
            std::stringstream msg;
            msg << callee << " takes " << LP;
            msg << (LP == 1 ? " argument" : " arguments");
            msg << " but " << arg_count;
            msg << (arg_count == 1 ? " was passed" : " were passed.");
            deprecated_bind(msg.str(), as->pstate());
  ***REMOVED***
***REMOVED***
        // otherwise move one of the rest args into the param, converting to argument if necessary
        if (!(a = dynamic_cast<Argument*>((*arglist)[0]))) ***REMOVED***
          Expression* a_to_convert = (*arglist)[0];
          a = SASS_MEMORY_NEW(ctx->mem, Argument,
                              a_to_convert->pstate(),
                              a_to_convert,
                              "",
                              false,
                              false);
***REMOVED***
        arglist->elements().erase(arglist->elements().begin());
        if (!arglist->length() || (!arglist->is_arglist() && ip + 1 == LP)) ***REMOVED***
          ++ia;
***REMOVED***
  ***REMOVED*** else if (a->is_keyword_argument()) ***REMOVED***
        Map* argmap = static_cast<Map*>(a->value());

        for (auto key : argmap->keys()) ***REMOVED***
          std::string name = "$" + unquote(static_cast<String_Constant*>(key)->value());

          if (!param_map.count(name)) ***REMOVED***
            std::stringstream msg;
            msg << callee << " has no parameter named " << name;
            error(msg.str(), a->pstate());
  ***REMOVED***
          env->local_frame()[name] = argmap->at(key);
***REMOVED***
        ++ia;
        continue;
  ***REMOVED*** else ***REMOVED***
        ++ia;
  ***REMOVED***

      if (a->name().empty()) ***REMOVED***
        if (env->has_local(p->name())) ***REMOVED***
          std::stringstream msg;
          msg << "parameter " << p->name()
          << " provided more than once in call to " << callee;
          error(msg.str(), a->pstate());
***REMOVED***
        // ordinal arg -- bind it to the next param
        env->local_frame()[p->name()] = a->value();
        ++ip;
  ***REMOVED***
      else ***REMOVED***
        // named arg -- bind it to the appropriately named param
        if (!param_map.count(a->name())) ***REMOVED***
          std::stringstream msg;
          msg << callee << " has no parameter named " << a->name();
          error(msg.str(), a->pstate());
***REMOVED***
        if (param_map[a->name()]->is_rest_parameter()) ***REMOVED***
          std::stringstream msg;
          msg << "argument " << a->name() << " of " << callee
              << "cannot be used as named argument";
          error(msg.str(), a->pstate());
***REMOVED***
        if (env->has_local(a->name())) ***REMOVED***
          std::stringstream msg;
          msg << "parameter " << p->name()
              << "provided more than once in call to " << callee;
          error(msg.str(), a->pstate());
***REMOVED***
        env->local_frame()[a->name()] = a->value();
  ***REMOVED***
***REMOVED***
    // EO while ia

    // If we make it here, we're out of args but may have leftover params.
    // That's only okay if they have default values, or were already bound by
    // named arguments, or if it's a single rest-param.
    for (size_t i = ip; i < LP; ++i) ***REMOVED***
      To_String to_string(ctx);
      Parameter* leftover = (*ps)[i];
      // cerr << "env for default params:" << endl;
      // env->print();
      // cerr << "********" << endl;
      if (!env->has_local(leftover->name())) ***REMOVED***
        if (leftover->is_rest_parameter()) ***REMOVED***
          env->local_frame()[leftover->name()] = SASS_MEMORY_NEW(ctx->mem, List,
                                                                   leftover->pstate(),
                                                                   0,
                                                                   SASS_COMMA,
                                                                   true);
***REMOVED***
        else if (leftover->default_value()) ***REMOVED***
          Expression* dv = leftover->default_value()->perform(eval);
          env->local_frame()[leftover->name()] = dv;
***REMOVED***
        else ***REMOVED***
          // param is unbound and has no default value -- error
          std::stringstream msg;
          msg << "required parameter " << leftover->name()
              << " is missing in call to " << callee;
          error(msg.str(), as->pstate());
***REMOVED***
  ***REMOVED***
***REMOVED***

    return;
  ***REMOVED***


***REMOVED***
