#include "ast.hpp"
#include "environment.hpp"

namespace Sass ***REMOVED***

  template <typename T>
  Environment<T>::Environment() : local_frame_(std::map<std::string, T>()), parent_(0) ***REMOVED*** ***REMOVED***
  template <typename T>
  Environment<T>::Environment(Environment<T>* env) : local_frame_(std::map<std::string, T>()), parent_(env) ***REMOVED*** ***REMOVED***
  template <typename T>
  Environment<T>::Environment(Environment<T>& env) : local_frame_(std::map<std::string, T>()), parent_(&env) ***REMOVED*** ***REMOVED***

  // link parent to create a stack
  template <typename T>
  void Environment<T>::link(Environment& env) ***REMOVED*** parent_ = &env; ***REMOVED***
  template <typename T>
  void Environment<T>::link(Environment* env) ***REMOVED*** parent_ = env; ***REMOVED***

  // this is used to find the global frame
  // which is the second last on the stack
  template <typename T>
  bool Environment<T>::is_lexical() const
  ***REMOVED***
    return !! parent_ && parent_->parent_;
  ***REMOVED***

  // only match the real root scope
  // there is still a parent around
  // not sure what it is actually use for
  // I guess we store functions etc. there
  template <typename T>
  bool Environment<T>::is_global() const
  ***REMOVED***
    return parent_ && ! parent_->parent_;
  ***REMOVED***

  template <typename T>
  std::map<std::string, T>& Environment<T>::local_frame() ***REMOVED***
    return local_frame_;
  ***REMOVED***

  template <typename T>
  bool Environment<T>::has_local(const std::string& key) const
  ***REMOVED*** return local_frame_.find(key) != local_frame_.end(); ***REMOVED***

  template <typename T>
  T& Environment<T>::get_local(const std::string& key)
  ***REMOVED*** return local_frame_[key]; ***REMOVED***

  template <typename T>
  void Environment<T>::set_local(const std::string& key, T val)
  ***REMOVED***
    local_frame_[key] = val;
  ***REMOVED***

  template <typename T>
  void Environment<T>::del_local(const std::string& key)
  ***REMOVED*** local_frame_.erase(key); ***REMOVED***

  template <typename T>
  Environment<T>* Environment<T>::global_env()
  ***REMOVED***
    Environment* cur = this;
    while (cur->is_lexical()) ***REMOVED***
      cur = cur->parent_;
***REMOVED***
    return cur;
  ***REMOVED***

  template <typename T>
  bool Environment<T>::has_global(const std::string& key)
  ***REMOVED*** return global_env()->has(key); ***REMOVED***

  template <typename T>
  T& Environment<T>::get_global(const std::string& key)
  ***REMOVED*** return (*global_env())[key]; ***REMOVED***

  template <typename T>
  void Environment<T>::set_global(const std::string& key, T val)
  ***REMOVED***
    global_env()->local_frame_[key] = val;
  ***REMOVED***

  template <typename T>
  void Environment<T>::del_global(const std::string& key)
  ***REMOVED*** global_env()->local_frame_.erase(key); ***REMOVED***

  template <typename T>
  Environment<T>* Environment<T>::lexical_env(const std::string& key)
  ***REMOVED***
    Environment* cur = this;
    while (cur) ***REMOVED***
      if (cur->has_local(key)) ***REMOVED***
        return cur;
  ***REMOVED***
      cur = cur->parent_;
***REMOVED***
    return this;
  ***REMOVED***

  // see if we have a lexical variable
  // move down the stack but stop before we
  // reach the global frame (is not included)
  template <typename T>
  bool Environment<T>::has_lexical(const std::string& key) const
  ***REMOVED***
    auto cur = this;
    while (cur->is_lexical()) ***REMOVED***
      if (cur->has_local(key)) return true;
      cur = cur->parent_;
***REMOVED***
    return false;
  ***REMOVED***

  // see if we have a lexical we could update
  // either update already existing lexical value
  // or if flag is set, we create one if no lexical found
  template <typename T>
  void Environment<T>::set_lexical(const std::string& key, T val)
  ***REMOVED***
    auto cur = this;
    while (cur->is_lexical()) ***REMOVED***
      if (cur->has_local(key)) ***REMOVED***
        cur->set_local(key, val);
        return;
  ***REMOVED***
      cur = cur->parent_;
***REMOVED***
    set_local(key, val);
  ***REMOVED***

  // look on the full stack for key
  // include all scopes available
  template <typename T>
  bool Environment<T>::has(const std::string& key) const
  ***REMOVED***
    auto cur = this;
    while (cur) ***REMOVED***
      if (cur->has_local(key)) ***REMOVED***
        return true;
  ***REMOVED***
      cur = cur->parent_;
***REMOVED***
    return false;
  ***REMOVED***

  // use array access for getter and setter functions
  template <typename T>
  T& Environment<T>::operator[](const std::string& key)
  ***REMOVED***
    auto cur = this;
    while (cur) ***REMOVED***
      if (cur->has_local(key)) ***REMOVED***
        return cur->get_local(key);
  ***REMOVED***
      cur = cur->parent_;
***REMOVED***
    return get_local(key);
  ***REMOVED***

  #ifdef DEBUG
  template <typename T>
  size_t Environment<T>::print(std::string prefix)
  ***REMOVED***
    size_t indent = 0;
    if (parent_) indent = parent_->print(prefix) + 1;
    std::cerr << prefix << std::string(indent, ' ') << "== " << this << std::endl;
    for (typename std::map<std::string, T>::iterator i = local_frame_.begin(); i != local_frame_.end(); ++i) ***REMOVED***
      if (!ends_with(i->first, "[f]") && !ends_with(i->first, "[f]4") && !ends_with(i->first, "[f]2")) ***REMOVED***
        std::cerr << prefix << std::string(indent, ' ') << i->first << " "  << i->second;
        if (Value* val = dynamic_cast<Value*>(i->second))
***REMOVED*** std::cerr << " : " << val->to_string(true, 5); ***REMOVED***
        std::cerr << std::endl;
  ***REMOVED***
***REMOVED***
    return indent ;
  ***REMOVED***
  #endif

  // compile implementation for AST_Node
  template class Environment<AST_Node*>;

***REMOVED***

