#include <cctype>
#include <cstddef>
#include <iostream>
#include <iomanip>
#include "lexer.hpp"
#include "constants.hpp"


namespace Sass ***REMOVED***
  using namespace Constants;

  namespace Prelexer ***REMOVED***

    //####################################
    // BASIC CHARACTER MATCHERS
    //####################################

    // Match standard control chars
    const char* kwd_at(const char* src) ***REMOVED*** return exactly<'@'>(src); ***REMOVED***
    const char* kwd_dot(const char* src) ***REMOVED*** return exactly<'.'>(src); ***REMOVED***
    const char* kwd_comma(const char* src) ***REMOVED*** return exactly<','>(src); ***REMOVED***;
    const char* kwd_colon(const char* src) ***REMOVED*** return exactly<':'>(src); ***REMOVED***;
    const char* kwd_star(const char* src) ***REMOVED*** return exactly<'*'>(src); ***REMOVED***;
    const char* kwd_plus(const char* src) ***REMOVED*** return exactly<'+'>(src); ***REMOVED***;
    const char* kwd_minus(const char* src) ***REMOVED*** return exactly<'-'>(src); ***REMOVED***;
    const char* kwd_slash(const char* src) ***REMOVED*** return exactly<'/'>(src); ***REMOVED***;

    //####################################
    // implement some function that do exist in the standard
    // but those are locale aware which brought some trouble
    // this even seems to improve performance by quite a bit
    //####################################

    bool is_alpha(const char& chr)
***REMOVED***
      return unsigned(chr - 'A') <= 'Z' - 'A' ||
             unsigned(chr - 'a') <= 'z' - 'a';
***REMOVED***

    bool is_space(const char& chr)
***REMOVED***
      // adapted the technique from is_alpha
      return chr == ' ' || unsigned(chr - '\t') <= '\r' - '\t';
***REMOVED***

    bool is_digit(const char& chr)
***REMOVED***
      // adapted the technique from is_alpha
      return unsigned(chr - '0') <= '9' - '0';
***REMOVED***

    bool is_xdigit(const char& chr)
***REMOVED***
      // adapted the technique from is_alpha
      return unsigned(chr - '0') <= '9' - '0' ||
             unsigned(chr - 'a') <= 'f' - 'a' ||
             unsigned(chr - 'A') <= 'F' - 'A';
***REMOVED***

    bool is_punct(const char& chr)
***REMOVED***
      // locale independent
      return chr == '.';
***REMOVED***

    bool is_alnum(const char& chr)
***REMOVED***
      return is_alpha(chr) || is_digit(chr);
***REMOVED***

    // check if char is outside ascii range
    bool is_unicode(const char& chr)
***REMOVED***
      // check for unicode range
      return unsigned(chr) > 127;
***REMOVED***

    // check if char is outside ascii range
    // but with specific ranges (copied from Ruby Sass)
    bool is_nonascii(const char& chr)
***REMOVED***
      return (
        (unsigned(chr) > 127 && unsigned(chr) < 55296) ||
        (unsigned(chr) > 57343 && unsigned(chr) < 65534) ||
        (unsigned(chr) > 65535 && unsigned(chr) < 1114111)
      );
***REMOVED***

    // check if char is within a reduced ascii range
    // valid in a uri (copied from Ruby Sass)
    bool is_uri_character(const char& chr)
***REMOVED***
      return unsigned(chr) > 41 && unsigned(chr) < 127;
***REMOVED***

    // check if char is within a reduced ascii range
    // valid for escaping (copied from Ruby Sass)
    bool is_escapable_character(const char& chr)
***REMOVED***
      return unsigned(chr) > 31 && unsigned(chr) < 127;
***REMOVED***

    // Match word character (look ahead)
    bool is_character(const char& chr)
***REMOVED***
      // valid alpha, numeric or unicode char (plus hyphen)
      return is_alnum(chr) || is_unicode(chr) || chr == '-';
***REMOVED***

    //####################################
    // BASIC CLASS MATCHERS
    //####################################

    // create matchers that advance the position
    const char* space(const char* src) ***REMOVED*** return is_space(*src) ? src + 1 : 0; ***REMOVED***
    const char* alpha(const char* src) ***REMOVED*** return is_alpha(*src) ? src + 1 : 0; ***REMOVED***
    const char* unicode(const char* src) ***REMOVED*** return is_unicode(*src) ? src + 1 : 0; ***REMOVED***
    const char* nonascii(const char* src) ***REMOVED*** return is_nonascii(*src) ? src + 1 : 0; ***REMOVED***
    const char* digit(const char* src) ***REMOVED*** return is_digit(*src) ? src + 1 : 0; ***REMOVED***
    const char* xdigit(const char* src) ***REMOVED*** return is_xdigit(*src) ? src + 1 : 0; ***REMOVED***
    const char* alnum(const char* src) ***REMOVED*** return is_alnum(*src) ? src + 1 : 0; ***REMOVED***
    const char* punct(const char* src) ***REMOVED*** return is_punct(*src) ? src + 1 : 0; ***REMOVED***
    const char* character(const char* src) ***REMOVED*** return is_character(*src) ? src + 1 : 0; ***REMOVED***
    const char* uri_character(const char* src) ***REMOVED*** return is_uri_character(*src) ? src + 1 : 0; ***REMOVED***
    const char* escapable_character(const char* src) ***REMOVED*** return is_escapable_character(*src) ? src + 1 : 0; ***REMOVED***

    // Match multiple ctype characters.
    const char* spaces(const char* src) ***REMOVED*** return one_plus<space>(src); ***REMOVED***
    const char* digits(const char* src) ***REMOVED*** return one_plus<digit>(src); ***REMOVED***

    // Whitespace handling.
    const char* no_spaces(const char* src) ***REMOVED*** return negate< space >(src); ***REMOVED***
    const char* optional_spaces(const char* src) ***REMOVED*** return zero_plus< space >(src); ***REMOVED***

    // Match any single character.
    const char* any_char(const char* src) ***REMOVED*** return *src ? src + 1 : src; ***REMOVED***

    // Match word boundary (zero-width lookahead).
    const char* word_boundary(const char* src) ***REMOVED*** return is_character(*src) ? 0 : src; ***REMOVED***

    // Match linefeed /(?:\n|\r\n?)/
    const char* re_linebreak(const char* src)
***REMOVED***
      // end of file or unix linefeed return here
      if (*src == 0 || *src == '\n') return src + 1;
      // a carriage return may optionally be followed by a linefeed
      if (*src == '\r') return *(src + 1) == '\n' ? src + 2 : src + 1;
      // no linefeed
      return 0;
***REMOVED***

    // Assert string boundaries (/\Z|\z|\A/)
    // This is a zero-width positive lookahead
    const char* end_of_line(const char* src)
***REMOVED***
      // end of file or unix linefeed return here
      return *src == 0 || *src == '\n' || *src == '\r' ? src : 0;
***REMOVED***

    // Assert end_of_file boundary (/\z/)
    // This is a zero-width positive lookahead
    const char* end_of_file(const char* src)
***REMOVED***
      // end of file or unix linefeed return here
      return *src == 0 ? src : 0;
***REMOVED***

  ***REMOVED***
***REMOVED***
