#include <vector>

#include "node.hpp"
#include "to_string.hpp"
#include "context.hpp"
#include "parser.hpp"

namespace Sass ***REMOVED***


  Node Node::createCombinator(const Complex_Selector::Combinator& combinator) ***REMOVED***
    NodeDequePtr null;
    return Node(COMBINATOR, combinator, NULL /*pSelector*/, null /*pCollection*/);
  ***REMOVED***


  Node Node::createSelector(Complex_Selector* pSelector, Context& ctx) ***REMOVED***
    NodeDequePtr null;

    Complex_Selector* pStripped = pSelector->clone(ctx);
    pStripped->tail(NULL);
    pStripped->combinator(Complex_Selector::ANCESTOR_OF);

    Node n(SELECTOR, Complex_Selector::ANCESTOR_OF, pStripped, null /*pCollection*/);
    if (pSelector) n.got_line_feed = pSelector->has_line_feed();
    return n;
  ***REMOVED***


  Node Node::createCollection() ***REMOVED***
    NodeDequePtr pEmptyCollection = std::make_shared<NodeDeque>();
    return Node(COLLECTION, Complex_Selector::ANCESTOR_OF, NULL /*pSelector*/, pEmptyCollection);
  ***REMOVED***


  Node Node::createCollection(const NodeDeque& values) ***REMOVED***
    NodeDequePtr pShallowCopiedCollection = std::make_shared<NodeDeque>(values);
    return Node(COLLECTION, Complex_Selector::ANCESTOR_OF, NULL /*pSelector*/, pShallowCopiedCollection);
  ***REMOVED***


  Node Node::createNil() ***REMOVED***
    NodeDequePtr null;
    return Node(NIL, Complex_Selector::ANCESTOR_OF, NULL /*pSelector*/, null /*pCollection*/);
  ***REMOVED***


  Node::Node(const TYPE& type, Complex_Selector::Combinator combinator, Complex_Selector* pSelector, NodeDequePtr& pCollection)
  : got_line_feed(false), mType(type), mCombinator(combinator), mpSelector(pSelector), mpCollection(pCollection)
  ***REMOVED*** if (pSelector) got_line_feed = pSelector->has_line_feed(); ***REMOVED***


  Node Node::clone(Context& ctx) const ***REMOVED***
    NodeDequePtr pNewCollection = std::make_shared<NodeDeque>();
    if (mpCollection) ***REMOVED***
      for (NodeDeque::iterator iter = mpCollection->begin(), iterEnd = mpCollection->end(); iter != iterEnd; iter++) ***REMOVED***
        Node& toClone = *iter;
        pNewCollection->push_back(toClone.clone(ctx));
  ***REMOVED***
***REMOVED***

    Node n(mType, mCombinator, mpSelector ? mpSelector->clone(ctx) : NULL, pNewCollection);
    n.got_line_feed = got_line_feed;
    return n;
  ***REMOVED***


  bool Node::contains(const Node& potentialChild, bool simpleSelectorOrderDependent) const ***REMOVED***
  	bool found = false;

    for (NodeDeque::iterator iter = mpCollection->begin(), iterEnd = mpCollection->end(); iter != iterEnd; iter++) ***REMOVED***
      Node& toTest = *iter;

      if (nodesEqual(toTest, potentialChild, simpleSelectorOrderDependent)) ***REMOVED***
        found = true;
        break;
  ***REMOVED***
***REMOVED***

    return found;
  ***REMOVED***


  bool Node::operator==(const Node& rhs) const ***REMOVED***
  	return nodesEqual(*this, rhs, true /*simpleSelectorOrderDependent*/);
  ***REMOVED***


  bool nodesEqual(const Node& lhs, const Node& rhs, bool simpleSelectorOrderDependent) ***REMOVED***
    if (lhs.type() != rhs.type()) ***REMOVED***
      return false;
***REMOVED***

    if (lhs.isCombinator()) ***REMOVED***

    	return lhs.combinator() == rhs.combinator();

***REMOVED*** else if (lhs.isNil()) ***REMOVED***

      return true; // no state to check

***REMOVED*** else if (lhs.isSelector())***REMOVED***

      return selectors_equal(*lhs.selector(), *rhs.selector(), simpleSelectorOrderDependent);

***REMOVED*** else if (lhs.isCollection()) ***REMOVED***

      if (lhs.collection()->size() != rhs.collection()->size()) ***REMOVED***
        return false;
  ***REMOVED***

      for (NodeDeque::iterator lhsIter = lhs.collection()->begin(), lhsIterEnd = lhs.collection()->end(),
           rhsIter = rhs.collection()->begin(); lhsIter != lhsIterEnd; lhsIter++, rhsIter++) ***REMOVED***

        if (!nodesEqual(*lhsIter, *rhsIter, simpleSelectorOrderDependent)) ***REMOVED***
          return false;
***REMOVED***

  ***REMOVED***

      return true;

***REMOVED***

    // We shouldn't get here.
    throw "Comparing unknown node types. A new type was probably added and this method wasn't implemented for it.";
  ***REMOVED***


  void Node::plus(Node& rhs) ***REMOVED***
  	if (!this->isCollection() || !rhs.isCollection()) ***REMOVED***
    	throw "Both the current node and rhs must be collections.";
***REMOVED***
  	this->collection()->insert(this->collection()->end(), rhs.collection()->begin(), rhs.collection()->end());
  ***REMOVED***

#ifdef DEBUG
  std::ostream& operator<<(std::ostream& os, const Node& node) ***REMOVED***

    if (node.isCombinator()) ***REMOVED***

      switch (node.combinator()) ***REMOVED***
        case Complex_Selector::ANCESTOR_OF: os << "\" \""; break;
        case Complex_Selector::PARENT_OF:   os << "\">\""; break;
        case Complex_Selector::PRECEDES:    os << "\"~\""; break;
        case Complex_Selector::ADJACENT_TO: os << "\"+\""; break;
        case Complex_Selector::REFERENCE: os    << "\"/\""; break;
  ***REMOVED***

***REMOVED*** else if (node.isNil()) ***REMOVED***

      os << "nil";

***REMOVED*** else if (node.isSelector())***REMOVED***

      To_String to_string;
      os << node.selector()->head()->perform(&to_string);

***REMOVED*** else if (node.isCollection()) ***REMOVED***

      os << "[";

      for (NodeDeque::iterator iter = node.collection()->begin(), iterBegin = node.collection()->begin(), iterEnd = node.collection()->end(); iter != iterEnd; iter++) ***REMOVED***
        if (iter != iterBegin) ***REMOVED***
          os << ", ";
***REMOVED***

        os << (*iter);
  ***REMOVED***

      os << "]";

***REMOVED***

    return os;

  ***REMOVED***
#endif


  Node complexSelectorToNode(Complex_Selector* pToConvert, Context& ctx) ***REMOVED***
    if (pToConvert == NULL) ***REMOVED***
      return Node::createNil();
***REMOVED***
    Node node = Node::createCollection();
    node.got_line_feed = pToConvert->has_line_feed();
    bool has_lf = pToConvert->has_line_feed();

    // unwrap the selector from parent ref
    if (pToConvert->head() && pToConvert->head()->has_parent_ref()) ***REMOVED***
      Complex_Selector* tail = pToConvert->tail();
      if (tail) tail->has_line_feed(pToConvert->has_line_feed());
      pToConvert = tail;
***REMOVED***

    while (pToConvert) ***REMOVED***

      bool empty_parent_ref = pToConvert->head() && pToConvert->head()->is_empty_reference();

      if (pToConvert->head() == NULL || empty_parent_ref) ***REMOVED***
  ***REMOVED***

      // the first Complex_Selector may contain a dummy head pointer, skip it.
      if (pToConvert->head() != NULL && !empty_parent_ref) ***REMOVED***
        node.collection()->push_back(Node::createSelector(pToConvert, ctx));
        if (has_lf) node.collection()->back().got_line_feed = has_lf;
        has_lf = false;
  ***REMOVED***

      if (pToConvert->combinator() != Complex_Selector::ANCESTOR_OF) ***REMOVED***
        node.collection()->push_back(Node::createCombinator(pToConvert->combinator()));
        if (has_lf) node.collection()->back().got_line_feed = has_lf;
        has_lf = false;
  ***REMOVED***

      if (pToConvert && empty_parent_ref && pToConvert->tail()) ***REMOVED***
        // pToConvert->tail()->has_line_feed(pToConvert->has_line_feed());
  ***REMOVED***

      pToConvert = pToConvert->tail();
***REMOVED***

    return node;
  ***REMOVED***


  Complex_Selector* nodeToComplexSelector(const Node& toConvert, Context& ctx) ***REMOVED***
    if (toConvert.isNil()) ***REMOVED***
      return NULL;
***REMOVED***


    if (!toConvert.isCollection()) ***REMOVED***
      throw "The node to convert to a Complex_Selector* must be a collection type or nil.";
***REMOVED***


    NodeDeque& childNodes = *toConvert.collection();

    std::string noPath("");
    Position noPosition(-1, -1, -1);
    Complex_Selector* pFirst = SASS_MEMORY_NEW(ctx.mem, Complex_Selector, ParserState("[NODE]"), Complex_Selector::ANCESTOR_OF, NULL, NULL);

    Complex_Selector* pCurrent = pFirst;

    if (toConvert.isSelector()) pFirst->has_line_feed(toConvert.got_line_feed);
    if (toConvert.isCombinator()) pFirst->has_line_feed(toConvert.got_line_feed);

    for (NodeDeque::iterator childIter = childNodes.begin(), childIterEnd = childNodes.end(); childIter != childIterEnd; childIter++) ***REMOVED***

      Node& child = *childIter;

      if (child.isSelector()) ***REMOVED***
        pCurrent->tail(child.selector()->clone(ctx));   // JMA - need to clone the selector, because they can end up getting shared across Node collections, and can result in an infinite loop during the call to parentSuperselector()
        // if (child.got_line_feed) pCurrent->has_line_feed(child.got_line_feed);
        pCurrent = pCurrent->tail();
  ***REMOVED*** else if (child.isCombinator()) ***REMOVED***
        pCurrent->combinator(child.combinator());
        if (child.got_line_feed) pCurrent->has_line_feed(child.got_line_feed);

        // if the next node is also a combinator, create another Complex_Selector to hold it so it doesn't replace the current combinator
        if (childIter+1 != childIterEnd) ***REMOVED***
          Node& nextNode = *(childIter+1);
          if (nextNode.isCombinator()) ***REMOVED***
            pCurrent->tail(SASS_MEMORY_NEW(ctx.mem, Complex_Selector, ParserState("[NODE]"), Complex_Selector::ANCESTOR_OF, NULL, NULL));
            if (nextNode.got_line_feed) pCurrent->tail()->has_line_feed(nextNode.got_line_feed);
            pCurrent = pCurrent->tail();
  ***REMOVED***
***REMOVED***
  ***REMOVED*** else ***REMOVED***
        throw "The node to convert's children must be only combinators or selectors.";
  ***REMOVED***
***REMOVED***

    // Put the dummy Compound_Selector in the first position, for consistency with the rest of libsass
    Compound_Selector* fakeHead = SASS_MEMORY_NEW(ctx.mem, Compound_Selector, ParserState("[NODE]"), 1);
    Parent_Selector* selectorRef = SASS_MEMORY_NEW(ctx.mem, Parent_Selector, ParserState("[NODE]"));
    fakeHead->elements().push_back(selectorRef);
    if (toConvert.got_line_feed) pFirst->has_line_feed(toConvert.got_line_feed);
    // pFirst->has_line_feed(pFirst->has_line_feed() || pFirst->tail()->has_line_feed() || toConvert.got_line_feed);
    pFirst->head(fakeHead);
    return pFirst;
  ***REMOVED***

  // A very naive trim function, which removes duplicates in a node
  // This is only used in Complex_Selector::unify_with for now, may need modifications to fit other needs
  Node Node::naiveTrim(Node& seqses, Context& ctx) ***REMOVED***

    std::vector<Node*> res;
    std::vector<Complex_Selector*> known;

    NodeDeque::reverse_iterator seqsesIter = seqses.collection()->rbegin(),
                                seqsesIterEnd = seqses.collection()->rend();

    for (; seqsesIter != seqsesIterEnd; ++seqsesIter)
***REMOVED***
      Node& seqs1 = *seqsesIter;
      if( seqs1.isSelector() ) ***REMOVED***
        Complex_Selector* sel = seqs1.selector();
        std::vector<Complex_Selector*>::iterator it;
        bool found = false;
        for (it = known.begin(); it != known.end(); ++it) ***REMOVED***
          if (**it == *sel) ***REMOVED*** found = true; break; ***REMOVED***
***REMOVED***
        if( !found ) ***REMOVED***
          known.push_back(seqs1.selector());
          res.push_back(&seqs1);
***REMOVED***
  ***REMOVED*** else ***REMOVED***
        res.push_back(&seqs1);
  ***REMOVED***
***REMOVED***

    Node result = Node::createCollection();

    for (size_t i = res.size() - 1; i != std::string::npos; --i) ***REMOVED***
      result.collection()->push_back(*res[i]);
***REMOVED***

    return result;
  ***REMOVED***
***REMOVED***
