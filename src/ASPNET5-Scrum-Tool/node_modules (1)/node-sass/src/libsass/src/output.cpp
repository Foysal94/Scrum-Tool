#include "ast.hpp"
#include "output.hpp"
#include "to_string.hpp"

namespace Sass ***REMOVED***

  Output::Output(Context* ctx)
  : Inspect(Emitter(ctx)),
    charset(""),
    top_nodes(0)
  ***REMOVED******REMOVED***

  Output::~Output() ***REMOVED*** ***REMOVED***

  void Output::fallback_impl(AST_Node* n)
  ***REMOVED***
    return n->perform(this);
  ***REMOVED***

  void Output::operator()(Number* n)
  ***REMOVED***
    // use values to_string facility
    To_String to_string(ctx);
    std::string res = n->perform(&to_string);
    // check for a valid unit here
    // includes result for reporting
    if (n->numerator_units().size() > 1 ||
        n->denominator_units().size() > 0 ||
        (n->numerator_units().size() && n->numerator_units()[0].find_first_of('/') != std::string::npos) ||
        (n->numerator_units().size() && n->numerator_units()[0].find_first_of('*') != std::string::npos)
    ) ***REMOVED***
      error(res + " isn't a valid CSS value.", n->pstate());
***REMOVED***
    // output the final token
    append_token(res, n);
  ***REMOVED***

  void Output::operator()(Import* imp)
  ***REMOVED***
    top_nodes.push_back(imp);
  ***REMOVED***

  void Output::operator()(Map* m)
  ***REMOVED***
    To_String to_string(ctx);
    std::string dbg(m->perform(&to_string));
    error(dbg + " isn't a valid CSS value.", m->pstate());
  ***REMOVED***

  OutputBuffer Output::get_buffer(void)
  ***REMOVED***

    Emitter emitter(ctx);
    Inspect inspect(emitter);

    size_t size_nodes = top_nodes.size();
    for (size_t i = 0; i < size_nodes; i++) ***REMOVED***
      top_nodes[i]->perform(&inspect);
      inspect.append_mandatory_linefeed();
***REMOVED***

    // flush scheduled outputs
    inspect.finalize();
    // prepend buffer on top
    prepend_output(inspect.output());
    // make sure we end with a linefeed
    if (!ends_with(wbuf.buffer, ctx->linefeed)) ***REMOVED***
      // if the output is not completely empty
      if (!wbuf.buffer.empty()) append_string(ctx->linefeed);
***REMOVED***

    // search for unicode char
    for(const char& chr : wbuf.buffer) ***REMOVED***
      // skip all ascii chars
      if (chr >= 0) continue;
      // declare the charset
      if (output_style() != SASS_STYLE_COMPRESSED)
        charset = "@charset \"UTF-8\";"
                  + ctx->linefeed;
      else charset = "\xEF\xBB\xBF";
      // abort search
      break;
***REMOVED***

    // add charset as first line, before comments and imports
    if (!charset.empty()) prepend_string(charset);

    return wbuf;

  ***REMOVED***

  void Output::operator()(Comment* c)
  ***REMOVED***
    To_String to_string(ctx);
    std::string txt = c->text()->perform(&to_string);
    // if (indentation && txt == "/**/") return;
    bool important = c->is_important();
    if (output_style() != SASS_STYLE_COMPRESSED || important) ***REMOVED***
      if (buffer().size() == 0) ***REMOVED***
        top_nodes.push_back(c);
  ***REMOVED*** else ***REMOVED***
        in_comment = true;
        append_indentation();
        c->text()->perform(this);
        in_comment = false;
        if (indentation == 0) ***REMOVED***
          append_mandatory_linefeed();
***REMOVED*** else ***REMOVED***
          append_optional_linefeed();
***REMOVED***
  ***REMOVED***
***REMOVED***
  ***REMOVED***

  void Output::operator()(Ruleset* r)
  ***REMOVED***
    Selector* s     = r->selector();
    Block*    b     = r->block();
    bool      decls = false;

    // Filter out rulesets that aren't printable (process its children though)
    if (!Util::isPrintable(r, output_style())) ***REMOVED***
      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        if (dynamic_cast<Has_Block*>(stm)) ***REMOVED***
          stm->perform(this);
***REMOVED***
  ***REMOVED***
      return;
***REMOVED***

    if (b->has_non_hoistable()) ***REMOVED***
      decls = true;
      if (output_style() == SASS_STYLE_NESTED) indentation += r->tabs();
      if (ctx && ctx->c_options->source_comments) ***REMOVED***
        std::stringstream ss;
        append_indentation();
        ss << "/* line " << r->pstate().line + 1 << ", " << r->pstate().path << " */";
        append_string(ss.str());
        append_optional_linefeed();
  ***REMOVED***
      s->perform(this);
      append_scope_opener(b);
      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        bool bPrintExpression = true;
        // Check print conditions
        if (typeid(*stm) == typeid(Declaration)) ***REMOVED***
          Declaration* dec = static_cast<Declaration*>(stm);
          if (dec->value()->concrete_type() == Expression::STRING) ***REMOVED***
            String_Constant* valConst = static_cast<String_Constant*>(dec->value());
            std::string val(valConst->value());
            if (auto qstr = dynamic_cast<String_Quoted*>(valConst)) ***REMOVED***
              if (!qstr->quote_mark() && val.empty()) ***REMOVED***
                bPrintExpression = false;
  ***REMOVED***
***REMOVED***
  ***REMOVED***
          else if (dec->value()->concrete_type() == Expression::LIST) ***REMOVED***
            List* list = static_cast<List*>(dec->value());
            bool all_invisible = true;
            for (size_t list_i = 0, list_L = list->length(); list_i < list_L; ++list_i) ***REMOVED***
              Expression* item = (*list)[list_i];
              if (!item->is_invisible()) all_invisible = false;
***REMOVED***
            if (all_invisible) bPrintExpression = false;
  ***REMOVED***
***REMOVED***
        // Print if OK
        if (!stm->is_hoistable() && bPrintExpression) ***REMOVED***
          stm->perform(this);
***REMOVED***
  ***REMOVED***
      if (output_style() == SASS_STYLE_NESTED) indentation -= r->tabs();
      append_scope_closer(b);
***REMOVED***

    if (b->has_hoistable()) ***REMOVED***
      if (decls) ++indentation;
      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        if (stm->is_hoistable()) ***REMOVED***
          stm->perform(this);
***REMOVED***
  ***REMOVED***
      if (decls) --indentation;
***REMOVED***
  ***REMOVED***

  void Output::operator()(Keyframe_Rule* r)
  ***REMOVED***
    Block* b = r->block();
    Selector* v = r->selector();

    if (v) ***REMOVED***
      v->perform(this);
***REMOVED***

    if (!b) ***REMOVED***
      append_colon_separator();
      return;
***REMOVED***

    append_scope_opener();
    for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
      Statement* stm = (*b)[i];
      if (!stm->is_hoistable()) ***REMOVED***
        stm->perform(this);
        if (i < L - 1) append_special_linefeed();
  ***REMOVED***
***REMOVED***

    for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
      Statement* stm = (*b)[i];
      if (stm->is_hoistable()) ***REMOVED***
        stm->perform(this);
  ***REMOVED***
***REMOVED***

    append_scope_closer();
  ***REMOVED***

  void Output::operator()(Supports_Block* f)
  ***REMOVED***
    if (f->is_invisible()) return;

    Supports_Condition* c = f->condition();
    Block* b              = f->block();

    // Filter out feature blocks that aren't printable (process its children though)
    if (!Util::isPrintable(f, output_style())) ***REMOVED***
      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        if (dynamic_cast<Has_Block*>(stm)) ***REMOVED***
          stm->perform(this);
***REMOVED***
  ***REMOVED***
      return;
***REMOVED***

    if (output_style() == SASS_STYLE_NESTED) indentation += f->tabs();
    append_indentation();
    append_token("@supports", f);
    append_mandatory_space();
    c->perform(this);
    append_scope_opener();

    if (b->has_non_hoistable()) ***REMOVED***
      // JMA - hoisted, output the non-hoistable in a nested block, followed by the hoistable
      append_scope_opener();

      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        if (!stm->is_hoistable()) ***REMOVED***
          stm->perform(this);
***REMOVED***
  ***REMOVED***

      append_scope_closer();

      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        if (stm->is_hoistable()) ***REMOVED***
          stm->perform(this);
***REMOVED***
  ***REMOVED***
***REMOVED***
    else ***REMOVED***
      // JMA - not hoisted, just output in order
      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        stm->perform(this);
        if (i < L - 1) append_special_linefeed();
  ***REMOVED***
***REMOVED***

    if (output_style() == SASS_STYLE_NESTED) indentation -= f->tabs();

    append_scope_closer();

  ***REMOVED***

  void Output::operator()(Media_Block* m)
  ***REMOVED***
    if (m->is_invisible()) return;

    List*  q     = m->media_queries();
    Block* b     = m->block();

    // Filter out media blocks that aren't printable (process its children though)
    if (!Util::isPrintable(m, output_style())) ***REMOVED***
      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        if (dynamic_cast<Has_Block*>(stm)) ***REMOVED***
          stm->perform(this);
***REMOVED***
  ***REMOVED***
      return;
***REMOVED***
    if (output_style() == SASS_STYLE_NESTED) indentation += m->tabs();
    append_indentation();
    append_token("@media", m);
    append_mandatory_space();
    in_media_block = true;
    q->perform(this);
    in_media_block = false;
    append_scope_opener();

    for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
      if ((*b)[i]) (*b)[i]->perform(this);
      if (i < L - 1) append_special_linefeed();
***REMOVED***

    if (output_style() == SASS_STYLE_NESTED) indentation -= m->tabs();
    append_scope_closer();
  ***REMOVED***

  void Output::operator()(At_Rule* a)
  ***REMOVED***
    std::string      kwd   = a->keyword();
    Selector*   s     = a->selector();
    Expression* v     = a->value();
    Block*      b     = a->block();

    append_indentation();
    append_token(kwd, a);
    if (s) ***REMOVED***
      append_mandatory_space();
      in_wrapped = true;
      s->perform(this);
      in_wrapped = false;
***REMOVED***
    if (v) ***REMOVED***
      append_mandatory_space();
      v->perform(this);
***REMOVED***
    if (!b) ***REMOVED***
      append_delimiter();
      return;
***REMOVED***

    if (b->is_invisible() || b->length() == 0) ***REMOVED***
      return append_string(" ***REMOVED******REMOVED***");
***REMOVED***

    append_scope_opener();

    bool format = kwd != "@font-face";;

    for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
      Statement* stm = (*b)[i];
      if (!stm->is_hoistable()) ***REMOVED***
        stm->perform(this);
        if (i < L - 1 && format) append_special_linefeed();
  ***REMOVED***
***REMOVED***

    for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
      Statement* stm = (*b)[i];
      if (stm->is_hoistable()) ***REMOVED***
        stm->perform(this);
        if (i < L - 1 && format) append_special_linefeed();
  ***REMOVED***
***REMOVED***

    append_scope_closer();
  ***REMOVED***

  void Output::operator()(String_Quoted* s)
  ***REMOVED***
    if (s->quote_mark()) ***REMOVED***
      append_token(quote(s->value(), s->quote_mark()), s);
***REMOVED*** else if (!in_comment) ***REMOVED***
      append_token(string_to_output(s->value()), s);
***REMOVED*** else ***REMOVED***
      append_token(s->value(), s);
***REMOVED***
  ***REMOVED***

  void Output::operator()(String_Constant* s)
  ***REMOVED***
    std::string value(s->value());
    if (s->can_compress_whitespace() && output_style() == SASS_STYLE_COMPRESSED) ***REMOVED***
      value.erase(std::remove_if(value.begin(), value.end(), ::isspace), value.end());
***REMOVED***
    if (!in_comment) ***REMOVED***
      append_token(string_to_output(value), s);
***REMOVED*** else ***REMOVED***
      append_token(value, s);
***REMOVED***
  ***REMOVED***

***REMOVED***
