#include <cstring>
#include <stdexcept>
#include <sstream>
#include <string>
#include <vector>

#include "sass.h"
#include "file.hpp"
#include "json.hpp"
#include "util.hpp"
#include "context.hpp"
#include "sass_context.hpp"
#include "ast_fwd_decl.hpp"
#include "error_handling.hpp"

#define LFEED "\n"

extern "C" ***REMOVED***
  using namespace Sass;

  static void copy_options(struct Sass_Options* to, struct Sass_Options* from) ***REMOVED*** *to = *from; ***REMOVED***

  #define IMPLEMENT_SASS_OPTION_ACCESSOR(type, option) \
    type ADDCALL sass_option_get_##option (struct Sass_Options* options) ***REMOVED*** return options->option; ***REMOVED*** \
    void ADDCALL sass_option_set_##option (struct Sass_Options* options, type option) ***REMOVED*** options->option = option; ***REMOVED***
  #define IMPLEMENT_SASS_OPTION_STRING_ACCESSOR(type, option, def) \
    type ADDCALL sass_option_get_##option (struct Sass_Options* options) ***REMOVED*** return safe_str(options->option, def); ***REMOVED*** \
    void ADDCALL sass_option_set_##option (struct Sass_Options* options, type option) \
***REMOVED*** free(options->option); options->option = option || def ? sass_strdup(option ? option : def) : 0; ***REMOVED***

  #define IMPLEMENT_SASS_CONTEXT_GETTER(type, option) \
    type ADDCALL sass_context_get_##option (struct Sass_Context* ctx) ***REMOVED*** return ctx->option; ***REMOVED***
  #define IMPLEMENT_SASS_CONTEXT_TAKER(type, option) \
    type sass_context_take_##option (struct Sass_Context* ctx) \
***REMOVED*** type foo = ctx->option; ctx->option = 0; return foo; ***REMOVED***

  static int handle_errors(Sass_Context* c_ctx) ***REMOVED***
    try ***REMOVED***
     throw;
***REMOVED***
    catch (Exception::Base& e) ***REMOVED***
      std::stringstream msg_stream;
      std::string cwd(Sass::File::get_cwd());
      std::string rel_path(Sass::File::abs2rel(e.pstate.path, cwd, cwd));

      std::string msg_prefix("Error: ");
      bool got_newline = false;
      msg_stream << msg_prefix;
      const char* msg = e.what();
      while(msg && *msg) ***REMOVED***
        if (*msg == '\r') ***REMOVED***
          got_newline = true;
***REMOVED*** else if (*msg == '\n') ***REMOVED***
          got_newline = true;
***REMOVED*** else if (got_newline) ***REMOVED***
          msg_stream << std::string(msg_prefix.size(), ' ');
          got_newline = false;
***REMOVED***
        msg_stream << *msg;
        ++ msg;
  ***REMOVED***
      if (!got_newline) msg_stream << "\n";
      msg_stream << std::string(msg_prefix.size(), ' ');
      msg_stream << " on line " << e.pstate.line+1 << " of " << rel_path << "\n";

      // now create the code trace (ToDo: maybe have util functions?)
      if (e.pstate.line != std::string::npos && e.pstate.column != std::string::npos) ***REMOVED***
        size_t line = e.pstate.line;
        const char* line_beg = e.pstate.src;
        while (line_beg && *line_beg && line) ***REMOVED***
          if (*line_beg == '\n') -- line;
          ++ line_beg;
***REMOVED***
        const char* line_end = line_beg;
        while (line_end && *line_end && *line_end != '\n') ***REMOVED***
          if (*line_end == '\n') break;
          if (*line_end == '\r') break;
          line_end ++;
***REMOVED***
        size_t max_left = 42; size_t max_right = 78;
        size_t move_in = e.pstate.column > max_left ? e.pstate.column - max_left : 0;
        size_t shorten = (line_end - line_beg) - move_in > max_right ?
                         (line_end - line_beg) - move_in - max_right : 0;
        msg_stream << ">> " << std::string(line_beg + move_in, line_end - shorten) << "\n";
        msg_stream << "   " << std::string(e.pstate.column - move_in, '-') << "^\n";
  ***REMOVED***

      JsonNode* json_err = json_mkobject();
      json_append_member(json_err, "status", json_mknumber(1));
      json_append_member(json_err, "file", json_mkstring(e.pstate.path));
      json_append_member(json_err, "line", json_mknumber((double)(e.pstate.line+1)));
      json_append_member(json_err, "column", json_mknumber((double)(e.pstate.column+1)));
      json_append_member(json_err, "message", json_mkstring(e.what()));
      json_append_member(json_err, "formatted", json_mkstring(msg_stream.str().c_str()));

      c_ctx->error_json = json_stringify(json_err, "  ");;
      c_ctx->error_message = sass_strdup(msg_stream.str().c_str());
      c_ctx->error_text = sass_strdup(e.what());
      c_ctx->error_status = 1;
      c_ctx->error_file = sass_strdup(e.pstate.path);
      c_ctx->error_line = e.pstate.line+1;
      c_ctx->error_column = e.pstate.column+1;
      c_ctx->error_src = e.pstate.src;
      c_ctx->output_string = 0;
      c_ctx->source_map_string = 0;
      json_delete(json_err);
***REMOVED***
    catch (std::bad_alloc& ba) ***REMOVED***
      std::stringstream msg_stream;
      JsonNode* json_err = json_mkobject();
      msg_stream << "Unable to allocate memory: " << ba.what() << std::endl;
      json_append_member(json_err, "status", json_mknumber(2));
      json_append_member(json_err, "message", json_mkstring(ba.what()));
      c_ctx->error_json = json_stringify(json_err, "  ");;
      c_ctx->error_message = sass_strdup(msg_stream.str().c_str());
      c_ctx->error_text = sass_strdup(ba.what());
      c_ctx->error_status = 2;
      c_ctx->output_string = 0;
      c_ctx->source_map_string = 0;
      json_delete(json_err);
***REMOVED***
    catch (std::exception& e) ***REMOVED***
      std::stringstream msg_stream;
      JsonNode* json_err = json_mkobject();
      msg_stream << "Error: " << e.what() << std::endl;
      json_append_member(json_err, "status", json_mknumber(3));
      json_append_member(json_err, "message", json_mkstring(e.what()));
      c_ctx->error_json = json_stringify(json_err, "  ");;
      c_ctx->error_message = sass_strdup(msg_stream.str().c_str());
      c_ctx->error_text = sass_strdup(e.what());
      c_ctx->error_status = 3;
      c_ctx->output_string = 0;
      c_ctx->source_map_string = 0;
      json_delete(json_err);
***REMOVED***
    catch (std::string& e) ***REMOVED***
      std::stringstream msg_stream;
      JsonNode* json_err = json_mkobject();
      msg_stream << "Error: " << e << std::endl;
      json_append_member(json_err, "status", json_mknumber(4));
      json_append_member(json_err, "message", json_mkstring(e.c_str()));
      c_ctx->error_json = json_stringify(json_err, "  ");;
      c_ctx->error_message = sass_strdup(msg_stream.str().c_str());
      c_ctx->error_text = sass_strdup(e.c_str());
      c_ctx->error_status = 4;
      c_ctx->output_string = 0;
      c_ctx->source_map_string = 0;
      json_delete(json_err);
***REMOVED***
    catch (const char* e) ***REMOVED***
      std::stringstream msg_stream;
      JsonNode* json_err = json_mkobject();
      msg_stream << "Error: " << e << std::endl;
      json_append_member(json_err, "status", json_mknumber(4));
      json_append_member(json_err, "message", json_mkstring(e));
      c_ctx->error_json = json_stringify(json_err, "  ");;
      c_ctx->error_message = sass_strdup(msg_stream.str().c_str());
      c_ctx->error_text = sass_strdup(e);
      c_ctx->error_status = 4;
      c_ctx->output_string = 0;
      c_ctx->source_map_string = 0;
      json_delete(json_err);
***REMOVED***
    catch (...) ***REMOVED***
      std::stringstream msg_stream;
      JsonNode* json_err = json_mkobject();
      msg_stream << "Unknown error occurred" << std::endl;
      json_append_member(json_err, "status", json_mknumber(5));
      json_append_member(json_err, "message", json_mkstring("unknown"));
      c_ctx->error_json = json_stringify(json_err, "  ");;
      c_ctx->error_message = sass_strdup(msg_stream.str().c_str());
      c_ctx->error_text = sass_strdup("unknown");
      c_ctx->error_status = 5;
      c_ctx->output_string = 0;
      c_ctx->source_map_string = 0;
      json_delete(json_err);
***REMOVED***
    return c_ctx->error_status;
  ***REMOVED***

  // generic compilation function (not exported, use file/data compile instead)
  static Sass_Compiler* sass_prepare_context (Sass_Context* c_ctx, Context* cpp_ctx) throw()
  ***REMOVED***
    try ***REMOVED***

      // convert include path linked list to static array
      struct string_list* inc = c_ctx->include_paths;
      // very poor loop to get the length of the linked list
      size_t inc_size = 0; while (inc) ***REMOVED*** inc_size ++; inc = inc->next; ***REMOVED***
      // create char* array to hold all paths plus null terminator
      const char** include_paths = (const char**) calloc(inc_size + 1, sizeof(char*));
      if (include_paths == 0) throw(std::bad_alloc());
      // reset iterator
      inc = c_ctx->include_paths;
      // copy over the paths
      for (size_t i = 0; inc; i++) ***REMOVED***
        include_paths[i] = inc->string;
        inc = inc->next;
  ***REMOVED***

      // convert plugin path linked list to static array
      struct string_list* imp = c_ctx->plugin_paths;
      // very poor loop to get the length of the linked list
      size_t imp_size = 0; while (imp) ***REMOVED*** imp_size ++; imp = imp->next; ***REMOVED***
      // create char* array to hold all paths plus null terminator
      const char** plugin_paths = (const char**) calloc(imp_size + 1, sizeof(char*));
      if (plugin_paths == 0) throw(std::bad_alloc());
      // reset iterator
      imp = c_ctx->plugin_paths;
      // copy over the paths
      for (size_t i = 0; imp; i++) ***REMOVED***
        plugin_paths[i] = imp->string;
        imp = imp->next;
  ***REMOVED***

      // free intermediate data
      free(include_paths);
      free(plugin_paths);

      // register our custom functions
      if (c_ctx->c_functions) ***REMOVED***
        auto this_func_data = c_ctx->c_functions;
        while (this_func_data && *this_func_data) ***REMOVED***
          cpp_ctx->add_c_function(*this_func_data);
          ++this_func_data;
***REMOVED***
  ***REMOVED***

      // register our custom headers
      if (c_ctx->c_headers) ***REMOVED***
        auto this_head_data = c_ctx->c_headers;
        while (this_head_data && *this_head_data) ***REMOVED***
          cpp_ctx->add_c_header(*this_head_data);
          ++this_head_data;
***REMOVED***
  ***REMOVED***

      // register our custom importers
      if (c_ctx->c_importers) ***REMOVED***
        auto this_imp_data = c_ctx->c_importers;
        while (this_imp_data && *this_imp_data) ***REMOVED***
          cpp_ctx->add_c_importer(*this_imp_data);
          ++this_imp_data;
***REMOVED***
  ***REMOVED***

      // reset error status
      c_ctx->error_json = 0;
      c_ctx->error_text = 0;
      c_ctx->error_message = 0;
      c_ctx->error_status = 0;
      // reset error position
      c_ctx->error_src = 0;
      c_ctx->error_file = 0;
      c_ctx->error_line = std::string::npos;
      c_ctx->error_column = std::string::npos;

      // allocate a new compiler instance
      Sass_Compiler* compiler = (struct Sass_Compiler*) calloc(1, sizeof(struct Sass_Compiler));
      compiler->state = SASS_COMPILER_CREATED;

      // store in sass compiler
      compiler->c_ctx = c_ctx;
      compiler->cpp_ctx = cpp_ctx;
      cpp_ctx->c_compiler = compiler;

      // use to parse block
      return compiler;

***REMOVED***
    // pass errors to generic error handler
    catch (...) ***REMOVED*** handle_errors(c_ctx); ***REMOVED***

    // error
    return 0;

  ***REMOVED***

  static Block* sass_parse_block (Sass_Compiler* compiler) throw()
  ***REMOVED***

    // assert valid pointer
    if (compiler == 0) return 0;
    // The cpp context must be set by now
    Context* cpp_ctx = compiler->cpp_ctx;
    Sass_Context* c_ctx = compiler->c_ctx;
    // We will take care to wire up the rest
    compiler->cpp_ctx->c_compiler = compiler;
    compiler->state = SASS_COMPILER_PARSED;

    try ***REMOVED***

      // get input/output path from options
      std::string input_path = safe_str(c_ctx->input_path);
      std::string output_path = safe_str(c_ctx->output_path);

      // parsed root block
      Block* root = 0;

      // maybe skip some entries of included files
      // we do not include stdin for data contexts
      bool skip = c_ctx->type == SASS_CONTEXT_DATA;

      // dispatch parse call
      root = cpp_ctx->parse();
      // abort on errors
      if (!root) return 0;

      // skip all prefixed files? (ToDo: check srcmap)
      // IMO source-maps should point to headers already
      // therefore don't skip it for now. re-enable or
      // remove completely once this is tested
      size_t headers = cpp_ctx->head_imports;

      // copy the included files on to the context (dont forget to free later)
      if (copy_strings(cpp_ctx->get_included_files(skip, headers), &c_ctx->included_files) == NULL)
        throw(std::bad_alloc());

      // return parsed block
      return root;

***REMOVED***
    // pass errors to generic error handler
    catch (...) ***REMOVED*** handle_errors(c_ctx); ***REMOVED***

    // error
    return 0;

  ***REMOVED***

  // generic compilation function (not exported, use file/data compile instead)
  static int sass_compile_context (Sass_Context* c_ctx, Context* cpp_ctx)
  ***REMOVED***

    // prepare sass compiler with context and options
    Sass_Compiler* compiler = sass_prepare_context(c_ctx, cpp_ctx);

    try ***REMOVED***
      // call each compiler step
      sass_compiler_parse(compiler);
      sass_compiler_execute(compiler);
***REMOVED***
    // pass errors to generic error handler
    catch (...) ***REMOVED*** handle_errors(c_ctx); ***REMOVED***

    sass_delete_compiler(compiler);

    return c_ctx->error_status;
  ***REMOVED***

  inline void init_options (struct Sass_Options* options)
  ***REMOVED***
    options->precision = 5;
    options->indent = "  ";
    options->linefeed = LFEED;
  ***REMOVED***

  Sass_Options* ADDCALL sass_make_options (void)
  ***REMOVED***
    struct Sass_Options* options = (struct Sass_Options*) calloc(1, sizeof(struct Sass_Options));
    if (options == 0) ***REMOVED*** std::cerr << "Error allocating memory for options" << std::endl; return 0; ***REMOVED***
    init_options(options);
    return options;
  ***REMOVED***

  Sass_File_Context* ADDCALL sass_make_file_context(const char* input_path)
  ***REMOVED***
    struct Sass_File_Context* ctx = (struct Sass_File_Context*) calloc(1, sizeof(struct Sass_File_Context));
    if (ctx == 0) ***REMOVED*** std::cerr << "Error allocating memory for file context" << std::endl; return 0; ***REMOVED***
    ctx->type = SASS_CONTEXT_FILE;
    init_options(ctx);
    try ***REMOVED***
      if (input_path == 0) ***REMOVED*** throw(std::runtime_error("File context created without an input path")); ***REMOVED***
      if (*input_path == 0) ***REMOVED*** throw(std::runtime_error("File context created with empty input path")); ***REMOVED***
      sass_option_set_input_path(ctx, input_path);
***REMOVED*** catch (...) ***REMOVED***
      handle_errors(ctx);
***REMOVED***
    return ctx;
  ***REMOVED***

  Sass_Data_Context* ADDCALL sass_make_data_context(char* source_string)
  ***REMOVED***
    struct Sass_Data_Context* ctx = (struct Sass_Data_Context*) calloc(1, sizeof(struct Sass_Data_Context));
    if (ctx == 0) ***REMOVED*** std::cerr << "Error allocating memory for data context" << std::endl; return 0; ***REMOVED***
    ctx->type = SASS_CONTEXT_DATA;
    init_options(ctx);
    try ***REMOVED***
      if (source_string == 0) ***REMOVED*** throw(std::runtime_error("Data context created without a source string")); ***REMOVED***
      if (*source_string == 0) ***REMOVED*** throw(std::runtime_error("Data context created with empty source string")); ***REMOVED***
      ctx->source_string = source_string;
***REMOVED*** catch (...) ***REMOVED***
      handle_errors(ctx);
***REMOVED***
    return ctx;
  ***REMOVED***

  struct Sass_Compiler* ADDCALL sass_make_data_compiler (struct Sass_Data_Context* data_ctx)
  ***REMOVED***
    if (data_ctx == 0) return 0;
    Context* cpp_ctx = new Data_Context(data_ctx);
    return sass_prepare_context(data_ctx, cpp_ctx);
  ***REMOVED***

  struct Sass_Compiler* ADDCALL sass_make_file_compiler (struct Sass_File_Context* file_ctx)
  ***REMOVED***
    if (file_ctx == 0) return 0;
    Context* cpp_ctx = new File_Context(file_ctx);
    return sass_prepare_context(file_ctx, cpp_ctx);
  ***REMOVED***

  int ADDCALL sass_compile_data_context(Sass_Data_Context* data_ctx)
  ***REMOVED***
    if (data_ctx == 0) return 1;
    if (data_ctx->error_status)
      return data_ctx->error_status;
    try ***REMOVED***
      if (data_ctx->source_string == 0) ***REMOVED*** throw(std::runtime_error("Data context has no source string")); ***REMOVED***
      if (*data_ctx->source_string == 0) ***REMOVED*** throw(std::runtime_error("Data context has empty source string")); ***REMOVED***
***REMOVED***
    catch (...) ***REMOVED*** return handle_errors(data_ctx) | 1; ***REMOVED***
    Context* cpp_ctx = new Data_Context(data_ctx);
    return sass_compile_context(data_ctx, cpp_ctx);
  ***REMOVED***

  int ADDCALL sass_compile_file_context(Sass_File_Context* file_ctx)
  ***REMOVED***
    if (file_ctx == 0) return 1;
    if (file_ctx->error_status)
      return file_ctx->error_status;
    try ***REMOVED***
      if (file_ctx->input_path == 0) ***REMOVED*** throw(std::runtime_error("File context has no input path")); ***REMOVED***
      if (*file_ctx->input_path == 0) ***REMOVED*** throw(std::runtime_error("File context has empty input path")); ***REMOVED***
***REMOVED***
    catch (...) ***REMOVED*** return handle_errors(file_ctx) | 1; ***REMOVED***
    Context* cpp_ctx = new File_Context(file_ctx);
    return sass_compile_context(file_ctx, cpp_ctx);
  ***REMOVED***

  int ADDCALL sass_compiler_parse(struct Sass_Compiler* compiler)
  ***REMOVED***
    if (compiler == 0) return 1;
    if (compiler->state == SASS_COMPILER_PARSED) return 0;
    if (compiler->state != SASS_COMPILER_CREATED) return -1;
    if (compiler->c_ctx == NULL) return 1;
    if (compiler->cpp_ctx == NULL) return 1;
    if (compiler->c_ctx->error_status)
      return compiler->c_ctx->error_status;
    // parse the context we have set up (file or data)
    compiler->root = sass_parse_block(compiler);
    // success
    return 0;
  ***REMOVED***

  int ADDCALL sass_compiler_execute(struct Sass_Compiler* compiler)
  ***REMOVED***
    if (compiler == 0) return 1;
    if (compiler->state == SASS_COMPILER_EXECUTED) return 0;
    if (compiler->state != SASS_COMPILER_PARSED) return -1;
    if (compiler->c_ctx == NULL) return 1;
    if (compiler->cpp_ctx == NULL) return 1;
    if (compiler->root == NULL) return 1;
    if (compiler->c_ctx->error_status)
      return compiler->c_ctx->error_status;
    compiler->state = SASS_COMPILER_EXECUTED;
    Context* cpp_ctx = compiler->cpp_ctx;
    Block* root = compiler->root;
    // compile the parsed root block
    try ***REMOVED*** compiler->c_ctx->output_string = cpp_ctx->render(root); ***REMOVED***
    // pass catched errors to generic error handler
    catch (...) ***REMOVED*** return handle_errors(compiler->c_ctx) | 1; ***REMOVED***
    // generate source map json and store on context
    compiler->c_ctx->source_map_string = cpp_ctx->render_srcmap();
    // success
    return 0;
  ***REMOVED***

  // helper function, not exported, only accessible locally
  static void sass_clear_options (struct Sass_Options* options)
  ***REMOVED***
    if (options == 0) return;
    // Deallocate custom functions
    if (options->c_functions) ***REMOVED***
      Sass_Function_List this_func_data = options->c_functions;
      while (this_func_data && *this_func_data) ***REMOVED***
        free(*this_func_data);
        ++this_func_data;
  ***REMOVED***
***REMOVED***
    // Deallocate custom headers
    if (options->c_headers) ***REMOVED***
      Sass_Importer_List this_head_data = options->c_headers;
      while (this_head_data && *this_head_data) ***REMOVED***
        free(*this_head_data);
        ++this_head_data;
  ***REMOVED***
***REMOVED***
    // Deallocate custom importers
    if (options->c_importers) ***REMOVED***
      Sass_Importer_List this_imp_data = options->c_importers;
      while (this_imp_data && *this_imp_data) ***REMOVED***
        free(*this_imp_data);
        ++this_imp_data;
  ***REMOVED***
***REMOVED***
    // Deallocate inc paths
    if (options->plugin_paths) ***REMOVED***
      struct string_list* cur;
      struct string_list* next;
      cur = options->plugin_paths;
      while (cur) ***REMOVED***
        next = cur->next;
        free(cur->string);
        free(cur);
        cur = next;
  ***REMOVED***
***REMOVED***
    // Deallocate inc paths
    if (options->include_paths) ***REMOVED***
      struct string_list* cur;
      struct string_list* next;
      cur = options->include_paths;
      while (cur) ***REMOVED***
        next = cur->next;
        free(cur->string);
        free(cur);
        cur = next;
  ***REMOVED***
***REMOVED***
    // Free custom functions
    free(options->c_functions);
    // Free custom importers
    free(options->c_importers);
    free(options->c_headers);
    // Reset our pointers
    options->c_functions = 0;
    options->c_importers = 0;
    options->c_headers = 0;
    options->plugin_paths = 0;
    options->include_paths = 0;
  ***REMOVED***

  // helper function, not exported, only accessible locally
  // sass_free_context is also defined in old sass_interface
  static void sass_clear_context (struct Sass_Context* ctx)
  ***REMOVED***
    if (ctx == 0) return;
    // release the allocated memory (mostly via sass_strdup)
    if (ctx->output_string)     free(ctx->output_string);
    if (ctx->source_map_string) free(ctx->source_map_string);
    if (ctx->error_message)     free(ctx->error_message);
    if (ctx->error_text)        free(ctx->error_text);
    if (ctx->error_json)        free(ctx->error_json);
    if (ctx->error_file)        free(ctx->error_file);
    if (ctx->input_path)        free(ctx->input_path);
    if (ctx->output_path)       free(ctx->output_path);
    if (ctx->plugin_path)       free(ctx->plugin_path);
    if (ctx->include_path)      free(ctx->include_path);
    if (ctx->source_map_file)   free(ctx->source_map_file);
    if (ctx->source_map_root)   free(ctx->source_map_root);
    free_string_array(ctx->included_files);
    // play safe and reset properties
    ctx->output_string = 0;
    ctx->source_map_string = 0;
    ctx->error_message = 0;
    ctx->error_text = 0;
    ctx->error_json = 0;
    ctx->error_file = 0;
    ctx->input_path = 0;
    ctx->output_path = 0;
    ctx->include_path = 0;
    ctx->source_map_file = 0;
    ctx->source_map_root = 0;
    ctx->included_files = 0;
    // now clear the options
    sass_clear_options(ctx);
  ***REMOVED***

  void ADDCALL sass_delete_compiler (struct Sass_Compiler* compiler)
  ***REMOVED***
    if (compiler == 0) ***REMOVED***
      return;
***REMOVED***
    Context* cpp_ctx = compiler->cpp_ctx;
    if (cpp_ctx) delete(cpp_ctx);
    compiler->cpp_ctx = 0;
    free(compiler);
  ***REMOVED***

  // Deallocate all associated memory with file context
  void ADDCALL sass_delete_file_context (struct Sass_File_Context* ctx)
  ***REMOVED***
    // clear the context and free it
    sass_clear_context(ctx); free(ctx);
  ***REMOVED***
  // Deallocate all associated memory with data context
  void ADDCALL sass_delete_data_context (struct Sass_Data_Context* ctx)
  ***REMOVED***
    // clean the source string if it was not passed
    // we reset this member once we start parsing
    if (ctx->source_string) free(ctx->source_string);
    // clear the context and free it
    sass_clear_context(ctx); free(ctx);
  ***REMOVED***

  // Getters for sass context from specific implementations
  struct Sass_Context* ADDCALL sass_file_context_get_context(struct Sass_File_Context* ctx) ***REMOVED*** return ctx; ***REMOVED***
  struct Sass_Context* ADDCALL sass_data_context_get_context(struct Sass_Data_Context* ctx) ***REMOVED*** return ctx; ***REMOVED***

  // Getters for context options from Sass_Context
  struct Sass_Options* ADDCALL sass_context_get_options(struct Sass_Context* ctx) ***REMOVED*** return ctx; ***REMOVED***
  struct Sass_Options* ADDCALL sass_file_context_get_options(struct Sass_File_Context* ctx) ***REMOVED*** return ctx; ***REMOVED***
  struct Sass_Options* ADDCALL sass_data_context_get_options(struct Sass_Data_Context* ctx) ***REMOVED*** return ctx; ***REMOVED***
  void ADDCALL sass_file_context_set_options (struct Sass_File_Context* ctx, struct Sass_Options* opt) ***REMOVED*** copy_options(ctx, opt); ***REMOVED***
  void ADDCALL sass_data_context_set_options (struct Sass_Data_Context* ctx, struct Sass_Options* opt) ***REMOVED*** copy_options(ctx, opt); ***REMOVED***

  // Getters for Sass_Compiler options (get conected sass context)
  enum Sass_Compiler_State ADDCALL sass_compiler_get_state(struct Sass_Compiler* compiler) ***REMOVED*** return compiler->state; ***REMOVED***
  struct Sass_Context* ADDCALL sass_compiler_get_context(struct Sass_Compiler* compiler) ***REMOVED*** return compiler->c_ctx; ***REMOVED***
  struct Sass_Options* ADDCALL sass_compiler_get_options(struct Sass_Compiler* compiler) ***REMOVED*** return compiler->c_ctx; ***REMOVED***
  // Getters for Sass_Compiler options (query import stack)
  size_t ADDCALL sass_compiler_get_import_stack_size(struct Sass_Compiler* compiler) ***REMOVED*** return compiler->cpp_ctx->import_stack.size(); ***REMOVED***
  Sass_Import_Entry ADDCALL sass_compiler_get_last_import(struct Sass_Compiler* compiler) ***REMOVED*** return compiler->cpp_ctx->import_stack.back(); ***REMOVED***
  Sass_Import_Entry ADDCALL sass_compiler_get_import_entry(struct Sass_Compiler* compiler, size_t idx) ***REMOVED*** return compiler->cpp_ctx->import_stack[idx]; ***REMOVED***

  // Calculate the size of the stored null terminated array
  size_t ADDCALL sass_context_get_included_files_size (struct Sass_Context* ctx)
  ***REMOVED*** size_t l = 0; auto i = ctx->included_files; while (i && *i) ***REMOVED*** ++i; ++l; ***REMOVED*** return l; ***REMOVED***

  // Create getter and setters for options
  IMPLEMENT_SASS_OPTION_ACCESSOR(int, precision);
  IMPLEMENT_SASS_OPTION_ACCESSOR(enum Sass_Output_Style, output_style);
  IMPLEMENT_SASS_OPTION_ACCESSOR(bool, source_comments);
  IMPLEMENT_SASS_OPTION_ACCESSOR(bool, source_map_embed);
  IMPLEMENT_SASS_OPTION_ACCESSOR(bool, source_map_contents);
  IMPLEMENT_SASS_OPTION_ACCESSOR(bool, omit_source_map_url);
  IMPLEMENT_SASS_OPTION_ACCESSOR(bool, is_indented_syntax_src);
  IMPLEMENT_SASS_OPTION_ACCESSOR(Sass_Function_List, c_functions);
  IMPLEMENT_SASS_OPTION_ACCESSOR(Sass_Importer_List, c_importers);
  IMPLEMENT_SASS_OPTION_ACCESSOR(Sass_Importer_List, c_headers);
  IMPLEMENT_SASS_OPTION_ACCESSOR(const char*, indent);
  IMPLEMENT_SASS_OPTION_ACCESSOR(const char*, linefeed);
  IMPLEMENT_SASS_OPTION_STRING_ACCESSOR(const char*, input_path, 0);
  IMPLEMENT_SASS_OPTION_STRING_ACCESSOR(const char*, output_path, 0);
  IMPLEMENT_SASS_OPTION_STRING_ACCESSOR(const char*, plugin_path, 0);
  IMPLEMENT_SASS_OPTION_STRING_ACCESSOR(const char*, include_path, 0);
  IMPLEMENT_SASS_OPTION_STRING_ACCESSOR(const char*, source_map_file, 0);
  IMPLEMENT_SASS_OPTION_STRING_ACCESSOR(const char*, source_map_root, 0);

  // Create getter and setters for context
  IMPLEMENT_SASS_CONTEXT_GETTER(int, error_status);
  IMPLEMENT_SASS_CONTEXT_GETTER(const char*, error_json);
  IMPLEMENT_SASS_CONTEXT_GETTER(const char*, error_message);
  IMPLEMENT_SASS_CONTEXT_GETTER(const char*, error_text);
  IMPLEMENT_SASS_CONTEXT_GETTER(const char*, error_file);
  IMPLEMENT_SASS_CONTEXT_GETTER(size_t, error_line);
  IMPLEMENT_SASS_CONTEXT_GETTER(size_t, error_column);
  IMPLEMENT_SASS_CONTEXT_GETTER(const char*, error_src);
  IMPLEMENT_SASS_CONTEXT_GETTER(const char*, output_string);
  IMPLEMENT_SASS_CONTEXT_GETTER(const char*, source_map_string);
  IMPLEMENT_SASS_CONTEXT_GETTER(char**, included_files);

  // Take ownership of memory (value on context is set to 0)
  IMPLEMENT_SASS_CONTEXT_TAKER(char*, error_json);
  IMPLEMENT_SASS_CONTEXT_TAKER(char*, error_message);
  IMPLEMENT_SASS_CONTEXT_TAKER(char*, error_text);
  IMPLEMENT_SASS_CONTEXT_TAKER(char*, error_file);
  IMPLEMENT_SASS_CONTEXT_TAKER(char*, output_string);
  IMPLEMENT_SASS_CONTEXT_TAKER(char*, source_map_string);
  IMPLEMENT_SASS_CONTEXT_TAKER(char**, included_files);

  // Push function for include paths (no manipulation support for now)
  void ADDCALL sass_option_push_include_path(struct Sass_Options* options, const char* path)
  ***REMOVED***

    struct string_list* include_path = (struct string_list*) calloc(1, sizeof(struct string_list));
    if (include_path == 0) return;
    include_path->string = path ? sass_strdup(path) : 0;
    struct string_list* last = options->include_paths;
    if (!options->include_paths) ***REMOVED***
      options->include_paths = include_path;
***REMOVED*** else ***REMOVED***
      while (last->next)
        last = last->next;
      last->next = include_path;
***REMOVED***

  ***REMOVED***

  // Push function for plugin paths (no manipulation support for now)
  void ADDCALL sass_option_push_plugin_path(struct Sass_Options* options, const char* path)
  ***REMOVED***

    struct string_list* plugin_path = (struct string_list*) calloc(1, sizeof(struct string_list));
    if (plugin_path == 0) return;
    plugin_path->string = path ? sass_strdup(path) : 0;
    struct string_list* last = options->plugin_paths;
    if (!options->plugin_paths) ***REMOVED***
      options->plugin_paths = plugin_path;
***REMOVED*** else ***REMOVED***
      while (last->next)
        last = last->next;
      last->next = plugin_path;
***REMOVED***

  ***REMOVED***

***REMOVED***
