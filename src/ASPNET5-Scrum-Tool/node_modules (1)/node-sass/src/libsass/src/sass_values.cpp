#include <cstdlib>
#include <cstring>
#include "util.hpp"
#include "eval.hpp"
#include "values.hpp"
#include "sass/values.h"
#include "sass_values.hpp"

extern "C" ***REMOVED***
  using namespace Sass;

  // Return the sass tag for a generic sass value
  enum Sass_Tag ADDCALL sass_value_get_tag(const union Sass_Value* v) ***REMOVED*** return v->unknown.tag; ***REMOVED***

  // Check value for specified type
  bool ADDCALL sass_value_is_null(const union Sass_Value* v) ***REMOVED*** return v->unknown.tag == SASS_NULL; ***REMOVED***
  bool ADDCALL sass_value_is_number(const union Sass_Value* v) ***REMOVED*** return v->unknown.tag == SASS_NUMBER; ***REMOVED***
  bool ADDCALL sass_value_is_string(const union Sass_Value* v) ***REMOVED*** return v->unknown.tag == SASS_STRING; ***REMOVED***
  bool ADDCALL sass_value_is_boolean(const union Sass_Value* v) ***REMOVED*** return v->unknown.tag == SASS_BOOLEAN; ***REMOVED***
  bool ADDCALL sass_value_is_color(const union Sass_Value* v) ***REMOVED*** return v->unknown.tag == SASS_COLOR; ***REMOVED***
  bool ADDCALL sass_value_is_list(const union Sass_Value* v) ***REMOVED*** return v->unknown.tag == SASS_LIST; ***REMOVED***
  bool ADDCALL sass_value_is_map(const union Sass_Value* v) ***REMOVED*** return v->unknown.tag == SASS_MAP; ***REMOVED***
  bool ADDCALL sass_value_is_error(const union Sass_Value* v) ***REMOVED*** return v->unknown.tag == SASS_ERROR; ***REMOVED***
  bool ADDCALL sass_value_is_warning(const union Sass_Value* v) ***REMOVED*** return v->unknown.tag == SASS_WARNING; ***REMOVED***

  // Getters and setters for Sass_Number
  double ADDCALL sass_number_get_value(const union Sass_Value* v) ***REMOVED*** return v->number.value; ***REMOVED***
  void ADDCALL sass_number_set_value(union Sass_Value* v, double value) ***REMOVED*** v->number.value = value; ***REMOVED***
  const char* ADDCALL sass_number_get_unit(const union Sass_Value* v) ***REMOVED*** return v->number.unit; ***REMOVED***
  void ADDCALL sass_number_set_unit(union Sass_Value* v, char* unit) ***REMOVED*** v->number.unit = unit; ***REMOVED***

  // Getters and setters for Sass_String
  const char* ADDCALL sass_string_get_value(const union Sass_Value* v) ***REMOVED*** return v->string.value; ***REMOVED***
  void ADDCALL sass_string_set_value(union Sass_Value* v, char* value) ***REMOVED*** v->string.value = value; ***REMOVED***
  bool ADDCALL sass_string_is_quoted(const union Sass_Value* v) ***REMOVED*** return v->string.quoted; ***REMOVED***
  void ADDCALL sass_string_set_quoted(union Sass_Value* v, bool quoted) ***REMOVED*** v->string.quoted = quoted; ***REMOVED***

  // Getters and setters for Sass_Boolean
  bool ADDCALL sass_boolean_get_value(const union Sass_Value* v) ***REMOVED*** return v->boolean.value; ***REMOVED***
  void ADDCALL sass_boolean_set_value(union Sass_Value* v, bool value) ***REMOVED*** v->boolean.value = value; ***REMOVED***

  // Getters and setters for Sass_Color
  double ADDCALL sass_color_get_r(const union Sass_Value* v) ***REMOVED*** return v->color.r; ***REMOVED***
  void ADDCALL sass_color_set_r(union Sass_Value* v, double r) ***REMOVED*** v->color.r = r; ***REMOVED***
  double ADDCALL sass_color_get_g(const union Sass_Value* v) ***REMOVED*** return v->color.g; ***REMOVED***
  void ADDCALL sass_color_set_g(union Sass_Value* v, double g) ***REMOVED*** v->color.g = g; ***REMOVED***
  double ADDCALL sass_color_get_b(const union Sass_Value* v) ***REMOVED*** return v->color.b; ***REMOVED***
  void ADDCALL sass_color_set_b(union Sass_Value* v, double b) ***REMOVED*** v->color.b = b; ***REMOVED***
  double ADDCALL sass_color_get_a(const union Sass_Value* v) ***REMOVED*** return v->color.a; ***REMOVED***
  void ADDCALL sass_color_set_a(union Sass_Value* v, double a) ***REMOVED*** v->color.a = a; ***REMOVED***

  // Getters and setters for Sass_List
  size_t ADDCALL sass_list_get_length(const union Sass_Value* v) ***REMOVED*** return v->list.length; ***REMOVED***
  enum Sass_Separator ADDCALL sass_list_get_separator(const union Sass_Value* v) ***REMOVED*** return v->list.separator; ***REMOVED***
  void ADDCALL sass_list_set_separator(union Sass_Value* v, enum Sass_Separator separator) ***REMOVED*** v->list.separator = separator; ***REMOVED***
  // Getters and setters for Sass_List values
  union Sass_Value* ADDCALL sass_list_get_value(const union Sass_Value* v, size_t i) ***REMOVED*** return v->list.values[i]; ***REMOVED***
  void ADDCALL sass_list_set_value(union Sass_Value* v, size_t i, union Sass_Value* value) ***REMOVED*** v->list.values[i] = value; ***REMOVED***

  // Getters and setters for Sass_Map
  size_t ADDCALL sass_map_get_length(const union Sass_Value* v) ***REMOVED*** return v->map.length; ***REMOVED***
  // Getters and setters for Sass_List keys and values
  union Sass_Value* ADDCALL sass_map_get_key(const union Sass_Value* v, size_t i) ***REMOVED*** return v->map.pairs[i].key; ***REMOVED***
  union Sass_Value* ADDCALL sass_map_get_value(const union Sass_Value* v, size_t i) ***REMOVED*** return v->map.pairs[i].value; ***REMOVED***
  void ADDCALL sass_map_set_key(union Sass_Value* v, size_t i, union Sass_Value* key) ***REMOVED*** v->map.pairs[i].key = key; ***REMOVED***
  void ADDCALL sass_map_set_value(union Sass_Value* v, size_t i, union Sass_Value* val) ***REMOVED*** v->map.pairs[i].value = val; ***REMOVED***

  // Getters and setters for Sass_Error
  char* ADDCALL sass_error_get_message(const union Sass_Value* v) ***REMOVED*** return v->error.message; ***REMOVED***;
  void ADDCALL sass_error_set_message(union Sass_Value* v, char* msg) ***REMOVED*** v->error.message = msg; ***REMOVED***;

  // Getters and setters for Sass_Warning
  char* ADDCALL sass_warning_get_message(const union Sass_Value* v) ***REMOVED*** return v->warning.message; ***REMOVED***;
  void ADDCALL sass_warning_set_message(union Sass_Value* v, char* msg) ***REMOVED*** v->warning.message = msg; ***REMOVED***;

  // Creator functions for all value types

  union Sass_Value* ADDCALL sass_make_boolean(bool val)
  ***REMOVED***
    union Sass_Value* v = (Sass_Value*) calloc(1, sizeof(Sass_Value));
    if (v == 0) return 0;
    v->boolean.tag = SASS_BOOLEAN;
    v->boolean.value = val;
    return v;
  ***REMOVED***

  union Sass_Value* ADDCALL sass_make_number(double val, const char* unit)
  ***REMOVED***
    union Sass_Value* v = (Sass_Value*) calloc(1, sizeof(Sass_Value));
    if (v == 0) return 0;
    v->number.tag = SASS_NUMBER;
    v->number.value = val;
    v->number.unit = unit ? sass_strdup(unit) : 0;
    if (v->number.unit == 0) ***REMOVED*** free(v); return 0; ***REMOVED***
    return v;
  ***REMOVED***

  union Sass_Value* ADDCALL sass_make_color(double r, double g, double b, double a)
  ***REMOVED***
    union Sass_Value* v = (Sass_Value*) calloc(1, sizeof(Sass_Value));
    if (v == 0) return 0;
    v->color.tag = SASS_COLOR;
    v->color.r = r;
    v->color.g = g;
    v->color.b = b;
    v->color.a = a;
    return v;
  ***REMOVED***

  union Sass_Value* ADDCALL sass_make_string(const char* val)
  ***REMOVED***
    union Sass_Value* v = (Sass_Value*) calloc(1, sizeof(Sass_Value));
    if (v == 0) return 0;
    v->string.quoted = false;
    v->string.tag = SASS_STRING;
    v->string.value = val ? sass_strdup(val) : 0;
    if (v->string.value == 0) ***REMOVED*** free(v); return 0; ***REMOVED***
    return v;
  ***REMOVED***

  union Sass_Value* ADDCALL sass_make_qstring(const char* val)
  ***REMOVED***
    union Sass_Value* v = (Sass_Value*) calloc(1, sizeof(Sass_Value));
    if (v == 0) return 0;
    v->string.quoted = true;
    v->string.tag = SASS_STRING;
    v->string.value = val ? sass_strdup(val) : 0;
    if (v->string.value == 0) ***REMOVED*** free(v); return 0; ***REMOVED***
    return v;
  ***REMOVED***

  union Sass_Value* ADDCALL sass_make_list(size_t len, enum Sass_Separator sep)
  ***REMOVED***
    union Sass_Value* v = (Sass_Value*) calloc(1, sizeof(Sass_Value));
    if (v == 0) return 0;
    v->list.tag = SASS_LIST;
    v->list.length = len;
    v->list.separator = sep;
    v->list.values = (union Sass_Value**) calloc(len, sizeof(union Sass_Value*));
    if (v->list.values == 0) ***REMOVED*** free(v); return 0; ***REMOVED***
    return v;
  ***REMOVED***

  union Sass_Value* ADDCALL sass_make_map(size_t len)
  ***REMOVED***
    union Sass_Value* v = (Sass_Value*) calloc(1, sizeof(Sass_Value));
    if (v == 0) return 0;
    v->map.tag = SASS_MAP;
    v->map.length = len;
    v->map.pairs = (struct Sass_MapPair*) calloc(len, sizeof(struct Sass_MapPair));
    if (v->map.pairs == 0) ***REMOVED*** free(v); return 0; ***REMOVED***
    return v;
  ***REMOVED***

  union Sass_Value* ADDCALL sass_make_null(void)
  ***REMOVED***
    union Sass_Value* v = (Sass_Value*) calloc(1, sizeof(Sass_Value));
    if (v == 0) return 0;
    v->null.tag = SASS_NULL;
    return v;
  ***REMOVED***

  union Sass_Value* ADDCALL sass_make_error(const char* msg)
  ***REMOVED***
    union Sass_Value* v = (Sass_Value*) calloc(1, sizeof(Sass_Value));
    if (v == 0) return 0;
    v->error.tag = SASS_ERROR;
    v->error.message = msg ? sass_strdup(msg) : 0;
    if (v->error.message == 0) ***REMOVED*** free(v); return 0; ***REMOVED***
    return v;
  ***REMOVED***

  union Sass_Value* ADDCALL sass_make_warning(const char* msg)
  ***REMOVED***
    union Sass_Value* v = (Sass_Value*) calloc(1, sizeof(Sass_Value));
    if (v == 0) return 0;
    v->warning.tag = SASS_WARNING;
    v->warning.message = msg ? sass_strdup(msg) : 0;
    if (v->warning.message == 0) ***REMOVED*** free(v); return 0; ***REMOVED***
    return v;
  ***REMOVED***

  // will free all associated sass values
  void ADDCALL sass_delete_value(union Sass_Value* val) ***REMOVED***

    size_t i;
    if (val == 0) return;
    switch(val->unknown.tag) ***REMOVED***
        case SASS_NULL: ***REMOVED***
***REMOVED***   break;
        case SASS_BOOLEAN: ***REMOVED***
***REMOVED***   break;
        case SASS_NUMBER: ***REMOVED***
                free(val->number.unit);
***REMOVED***   break;
        case SASS_COLOR: ***REMOVED***
***REMOVED***   break;
        case SASS_STRING: ***REMOVED***
                free(val->string.value);
***REMOVED***   break;
        case SASS_LIST: ***REMOVED***
                for (i=0; i<val->list.length; i++) ***REMOVED***
                    sass_delete_value(val->list.values[i]);
***REMOVED***
                free(val->list.values);
***REMOVED***   break;
        case SASS_MAP: ***REMOVED***
                for (i=0; i<val->map.length; i++) ***REMOVED***
                    sass_delete_value(val->map.pairs[i].key);
                    sass_delete_value(val->map.pairs[i].value);
***REMOVED***
                free(val->map.pairs);
***REMOVED***   break;
        case SASS_ERROR: ***REMOVED***
                free(val->error.message);
***REMOVED***   break;
        case SASS_WARNING: ***REMOVED***
                free(val->error.message);
***REMOVED***   break;
***REMOVED***

    free(val);

***REMOVED***

  // Make a deep cloned copy of the given sass value
  union Sass_Value* ADDCALL sass_clone_value (const union Sass_Value* val)
  ***REMOVED***

    size_t i;
    if (val == 0) return 0;
    switch(val->unknown.tag) ***REMOVED***
        case SASS_NULL: ***REMOVED***
                return sass_make_null();
***REMOVED***   break;
        case SASS_BOOLEAN: ***REMOVED***
                return sass_make_boolean(val->boolean.value);
***REMOVED***   break;
        case SASS_NUMBER: ***REMOVED***
                return sass_make_number(val->number.value, val->number.unit);
***REMOVED***   break;
        case SASS_COLOR: ***REMOVED***
                return sass_make_color(val->color.r, val->color.g, val->color.b, val->color.a);
***REMOVED***   break;
        case SASS_STRING: ***REMOVED***
                return sass_string_is_quoted(val) ? sass_make_qstring(val->string.value) : sass_make_string(val->string.value);
***REMOVED***   break;
        case SASS_LIST: ***REMOVED***
                union Sass_Value* list = sass_make_list(val->list.length, val->list.separator);
                for (i = 0; i < list->list.length; i++) ***REMOVED***
                    list->list.values[i] = sass_clone_value(val->list.values[i]);
***REMOVED***
                return list;
***REMOVED***   break;
        case SASS_MAP: ***REMOVED***
                union Sass_Value* map = sass_make_map(val->map.length);
                for (i = 0; i < val->map.length; i++) ***REMOVED***
                    map->map.pairs[i].key = sass_clone_value(val->map.pairs[i].key);
                    map->map.pairs[i].value = sass_clone_value(val->map.pairs[i].value);
***REMOVED***
                return map;
***REMOVED***   break;
        case SASS_ERROR: ***REMOVED***
                return sass_make_error(val->error.message);
***REMOVED***   break;
        case SASS_WARNING: ***REMOVED***
                return sass_make_warning(val->warning.message);
***REMOVED***   break;
***REMOVED***

    return 0;

  ***REMOVED***

  union Sass_Value* ADDCALL sass_value_stringify (const union Sass_Value* v, bool compressed, int precision)
  ***REMOVED***
    Memory_Manager mem;
    Value* val = sass_value_to_ast_node(mem, v);
    std::string str(val->to_string(compressed, precision));
    return sass_make_qstring(str.c_str());
  ***REMOVED***

  union Sass_Value* ADDCALL sass_value_op (enum Sass_OP op, const union Sass_Value* a, const union Sass_Value* b)
  ***REMOVED***

    Sass::Value* rv = 0;
    Memory_Manager mem;

    try ***REMOVED***

      Value* lhs = sass_value_to_ast_node(mem, a);
      Value* rhs = sass_value_to_ast_node(mem, b);

      // see if it's a relational expression
      switch(op) ***REMOVED***
        case Sass_OP::EQ:  return sass_make_boolean(Eval::eq(lhs, rhs));
        case Sass_OP::NEQ: return sass_make_boolean(!Eval::eq(lhs, rhs));
        case Sass_OP::GT:  return sass_make_boolean(!Eval::lt(lhs, rhs) && !Eval::eq(lhs, rhs));
        case Sass_OP::GTE: return sass_make_boolean(!Eval::lt(lhs, rhs));
        case Sass_OP::LT:  return sass_make_boolean(Eval::lt(lhs, rhs));
        case Sass_OP::LTE: return sass_make_boolean(Eval::lt(lhs, rhs) || Eval::eq(lhs, rhs));
        default:           break;
  ***REMOVED***

      if (sass_value_is_number(a) && sass_value_is_number(b)) ***REMOVED***
        const Number* l_n = dynamic_cast<const Number*>(lhs);
        const Number* r_n = dynamic_cast<const Number*>(rhs);
        rv = Eval::op_numbers(mem, op, *l_n, *r_n);
  ***REMOVED***
      else if (sass_value_is_number(a) && sass_value_is_color(a)) ***REMOVED***
        const Number* l_n = dynamic_cast<const Number*>(lhs);
        const Color* r_c = dynamic_cast<const Color*>(rhs);
        rv = Eval::op_number_color(mem, op, *l_n, *r_c);
  ***REMOVED***
      else if (sass_value_is_color(a) && sass_value_is_number(b)) ***REMOVED***
        const Color* l_c = dynamic_cast<const Color*>(lhs);
        const Number* r_n = dynamic_cast<const Number*>(rhs);
        rv = Eval::op_color_number(mem, op, *l_c, *r_n);
  ***REMOVED***
      else if (sass_value_is_color(a) && sass_value_is_color(b)) ***REMOVED***
        const Color* l_c = dynamic_cast<const Color*>(lhs);
        const Color* r_c = dynamic_cast<const Color*>(rhs);
        rv = Eval::op_colors(mem, op, *l_c, *r_c);
  ***REMOVED***
      else /* convert other stuff to string and apply operation */ ***REMOVED***
        Value* l_v = dynamic_cast<Value*>(lhs);
        Value* r_v = dynamic_cast<Value*>(rhs);
        rv = Eval::op_strings(mem, op, *l_v, *r_v);
  ***REMOVED***

      // ToDo: maybe we should should return null value?
      if (!rv) return sass_make_error("invalid return value");

      // convert result back to ast node
      return ast_node_to_sass_value(rv);

***REMOVED***

    // simply pass the error message back to the caller for now
    catch (Exception::InvalidSass& e) ***REMOVED*** return sass_make_error(e.what()); ***REMOVED***
    catch (std::bad_alloc&) ***REMOVED*** return sass_make_error("memory exhausted"); ***REMOVED***
    catch (std::exception& e) ***REMOVED*** return sass_make_error(e.what()); ***REMOVED***
    catch (std::string& e) ***REMOVED*** return sass_make_error(e.c_str()); ***REMOVED***
    catch (const char* e) ***REMOVED*** return sass_make_error(e); ***REMOVED***
    catch (...) ***REMOVED*** return sass_make_error("unknown"); ***REMOVED***

    return 0;

  ***REMOVED***

***REMOVED***
