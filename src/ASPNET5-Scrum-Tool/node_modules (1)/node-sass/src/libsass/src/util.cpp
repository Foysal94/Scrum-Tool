#include "sass.h"
#include "ast.hpp"
#include "util.hpp"
#include "lexer.hpp"
#include "prelexer.hpp"
#include "constants.hpp"
#include "utf8/checked.h"

#include <cmath>
#include <stdint.h>

namespace Sass ***REMOVED***

  #define out_of_memory() do ***REMOVED***            \
      std::cerr << "Out of memory.\n";    \
      exit(EXIT_FAILURE);                 \
***REMOVED*** while (0)

  double round(double val)
  ***REMOVED***
    // work around some compiler issue
    // cygwin has it not defined in std
    using namespace std;

    // This was later repatched in 3.4.20
    // which is as yet unreleased.
    // https://github.com/sass/sass/commit/4e3e1d5684cc29073a507578fc977434ff488c93
    if (fmod(val, 1) - 0.5 > -0.00001) return std::ceil(val);
    return ::round(val);

    // Use this version once sass-spec is at 3.4.20
    // if (fmod(val, 1) - 0.5 > -0.00001) return ::round(val);
    // return value > 0 ? std::ceil(val) : std::floor(val);
  ***REMOVED***

  /* Sadly, sass_strdup is not portable. */
  char *sass_strdup(const char *str)
  ***REMOVED***
    char *ret = (char*) malloc(strlen(str) + 1);
    if (ret == NULL)
      out_of_memory();
    strcpy(ret, str);
    return ret;
  ***REMOVED***

  /* Locale unspecific atof function. */
  double sass_atof(const char *str)
  ***REMOVED***
    char separator = *(localeconv()->decimal_point);
    if(separator != '.')***REMOVED***
      // The current locale specifies another
      // separator. convert the separator to the
      // one understood by the locale if needed
      const char *found = strchr(str, '.');
      if(found != NULL)***REMOVED***
        // substitution is required. perform the substitution on a copy
        // of the string. This is slower but it is thread safe.
        char *copy = sass_strdup(str);
        *(copy + (found - str)) = separator;
        double res = atof(copy);
        free(copy);
        return res;
  ***REMOVED***
***REMOVED***

    return atof(str);
  ***REMOVED***

  // helper for safe access to c_ctx
  const char* safe_str (const char* str, const char* alt) ***REMOVED***
    return str == NULL ? alt : str;
  ***REMOVED***

  void free_string_array(char ** arr) ***REMOVED***
    if(!arr)
        return;

    char **it = arr;
    while (it && (*it)) ***REMOVED***
      free(*it);
      ++it;
***REMOVED***

    free(arr);
  ***REMOVED***

  char **copy_strings(const std::vector<std::string>& strings, char*** array, int skip) ***REMOVED***
    int num = static_cast<int>(strings.size()) - skip;
    char** arr = (char**) calloc(num + 1, sizeof(char*));
    if (arr == 0)
      return *array = (char **)NULL;

    for(int i = 0; i < num; i++) ***REMOVED***
      arr[i] = (char*) malloc(sizeof(char) * (strings[i + skip].size() + 1));
      if (arr[i] == 0) ***REMOVED***
        free_string_array(arr);
        return *array = (char **)NULL;
  ***REMOVED***
      std::copy(strings[i + skip].begin(), strings[i + skip].end(), arr[i]);
      arr[i][strings[i + skip].size()] = '\0';
***REMOVED***

    arr[num] = 0;
    return *array = arr;
  ***REMOVED***

  std::string string_eval_escapes(const std::string& s)
  ***REMOVED***

    std::string out("");
    bool esc = false;
    for (size_t i = 0, L = s.length(); i < L; ++i) ***REMOVED***
      if(s[i] == '\\' && esc == false) ***REMOVED***
        esc = true;

        // escape length
        size_t len = 1;

        // parse as many sequence chars as possible
        // ToDo: Check if ruby aborts after possible max
        while (i + len < L && s[i + len] && isxdigit(s[i + len])) ++ len;

        // hex string?
        if (len > 1) ***REMOVED***

          // convert the extracted hex string to code point value
          // ToDo: Maybe we could do this without creating a substring
          uint32_t cp = strtol(s.substr (i + 1, len - 1).c_str(), NULL, 16);

          if (cp == 0) cp = 0xFFFD;

          // assert invalid code points
          if (cp >= 1) ***REMOVED***

            // use a very simple approach to convert via utf8 lib
            // maybe there is a more elegant way; maybe we shoud
            // convert the whole output from string to a stream!?
            // allocate memory for utf8 char and convert to utf8
            unsigned char u[5] = ***REMOVED***0,0,0,0,0***REMOVED***; utf8::append(cp, u);
            for(size_t m = 0; u[m] && m < 5; m++) out.push_back(u[m]);

            // skip some more chars?
            i += len - 1; esc = false;
            if (cp == 10) out += ' ';

  ***REMOVED***

***REMOVED***

  ***REMOVED***
      else ***REMOVED***
        out += s[i];
        esc = false;
  ***REMOVED***
***REMOVED***
    return out;

  ***REMOVED***

  // double escape every escape sequences
  // escape unescaped quotes and backslashes
  std::string string_escape(const std::string& str)
  ***REMOVED***
    std::string out("");
    for (auto i : str) ***REMOVED***
      // escape some characters
      if (i == '"') out += '\\';
      if (i == '\'') out += '\\';
      if (i == '\\') out += '\\';
      out += i;
***REMOVED***
    return out;
  ***REMOVED***

  // unescape every escape sequence
  // only removes unescaped backslashes
  std::string string_unescape(const std::string& str)
  ***REMOVED***
    std::string out("");
    bool esc = false;
    for (auto i : str) ***REMOVED***
      if (esc || i != '\\') ***REMOVED***
        esc = false;
        out += i;
  ***REMOVED*** else ***REMOVED***
        esc = true;
  ***REMOVED***
***REMOVED***
    // open escape sequence at end
    // maybe it should thow an error
    if (esc) ***REMOVED*** out += '\\'; ***REMOVED***
    return out;
  ***REMOVED***

  // read css string (handle multiline DELIM)
  std::string read_css_string(const std::string& str)
  ***REMOVED***
    std::string out("");
    bool esc = false;
    for (auto i : str) ***REMOVED***
      if (i == '\\') ***REMOVED***
        esc = ! esc;
  ***REMOVED*** else if (esc && i == '\r') ***REMOVED***
        continue;
  ***REMOVED*** else if (esc && i == '\n') ***REMOVED***
        out.resize (out.size () - 1);
        esc = false;
        continue;
  ***REMOVED*** else ***REMOVED***
        esc = false;
  ***REMOVED***
      out.push_back(i);
***REMOVED***
    if (esc) out += '\\';
    return out;
  ***REMOVED***

  // evacuate unescaped quoted
  // leave everything else untouched
  std::string evacuate_quotes(const std::string& str)
  ***REMOVED***
    std::string out("");
    bool esc = false;
    for (auto i : str) ***REMOVED***
      if (!esc) ***REMOVED***
        // ignore next character
        if (i == '\\') esc = true;
        // evacuate unescaped quotes
        else if (i == '"') out += '\\';
        else if (i == '\'') out += '\\';
  ***REMOVED***
      // get escaped char now
      else ***REMOVED*** esc = false; ***REMOVED***
      // remove nothing
      out += i;
***REMOVED***
    return out;
  ***REMOVED***

  // double escape all escape sequences
  // keep unescaped quotes and backslashes
  std::string evacuate_escapes(const std::string& str)
  ***REMOVED***
    std::string out("");
    bool esc = false;
    for (auto i : str) ***REMOVED***
      if (i == '\\' && !esc) ***REMOVED***
        out += '\\';
        out += '\\';
        esc = true;
  ***REMOVED*** else if (esc && i == '"') ***REMOVED***
        out += '\\';
        out += i;
        esc = false;
  ***REMOVED*** else if (esc && i == '\'') ***REMOVED***
        out += '\\';
        out += i;
        esc = false;
  ***REMOVED*** else if (esc && i == '\\') ***REMOVED***
        out += '\\';
        out += i;
        esc = false;
  ***REMOVED*** else ***REMOVED***
        esc = false;
        out += i;
  ***REMOVED***
***REMOVED***
    // happens when parsing does not correctly skip
    // over escaped sequences for ie. interpolations
    // one example: foo\#***REMOVED***interpolate***REMOVED***
    // if (esc) out += '\\';
    return out;
  ***REMOVED***

  // bell character is replaces with space
  std::string string_to_output(const std::string& str)
  ***REMOVED***
    std::string out("");
    bool lf = false;
    for (auto i : str) ***REMOVED***
      if (i == 10) ***REMOVED***
        out += ' ';
        lf = true;
  ***REMOVED*** else if (!(lf && isspace(i))) ***REMOVED***
        out += i;
        lf = false;
  ***REMOVED***
***REMOVED***
    return out;
  ***REMOVED***

  std::string comment_to_string(const std::string& text)
  ***REMOVED***
    std::string str = "";
    size_t has = 0;
    char prev = 0;
    bool clean = false;
    for (auto i : text) ***REMOVED***
      if (clean) ***REMOVED***
        if (i == '\n') ***REMOVED*** has = 0; ***REMOVED***
        else if (i == '\r') ***REMOVED*** has = 0; ***REMOVED***
        else if (i == '\t') ***REMOVED*** ++ has; ***REMOVED***
        else if (i == ' ') ***REMOVED*** ++ has; ***REMOVED***
        else if (i == '*') ***REMOVED******REMOVED***
        else ***REMOVED***
          clean = false;
          str += ' ';
          if (prev == '*' && i == '/') str += "*/";
          else str += i;
***REMOVED***
  ***REMOVED*** else if (i == '\n') ***REMOVED***
        clean = true;
  ***REMOVED*** else if (i == '\r') ***REMOVED***
        clean = true;
  ***REMOVED*** else ***REMOVED***
        str += i;
  ***REMOVED***
      prev = i;
***REMOVED***
    if (has) return str;
    else return text;
  ***REMOVED***

   std::string normalize_wspace(const std::string& str)
  ***REMOVED***
    bool ws = false;
    bool esc = false;
    std::string text = "";
    for(const char& i : str) ***REMOVED***
      if (!esc && i == '\\') ***REMOVED***
        esc = true;
        ws = false;
        text += i;
  ***REMOVED*** else if (esc) ***REMOVED***
        esc = false;
        ws = false;
        text += i;
  ***REMOVED*** else if (
        i == ' ' ||
        i == '\r' ||
        i == '\n' ||
        i == '	'
      ) ***REMOVED***
        // only add one space
        if (!ws) text += ' ';
        ws = true;
  ***REMOVED*** else ***REMOVED***
        ws = false;
        text += i;
  ***REMOVED***
***REMOVED***
    if (esc) text += '\\';
    return text;
  ***REMOVED***

  // find best quote_mark by detecting if the string contains any single
  // or double quotes. When a single quote is found, we not we want a double
  // quote as quote_mark. Otherwise we check if the string cotains any double
  // quotes, which will trigger the use of single quotes as best quote_mark.
  char detect_best_quotemark(const char* s, char qm)
  ***REMOVED***
    // ensure valid fallback quote_mark
    char quote_mark = qm && qm != '*' ? qm : '"';
    while (*s) ***REMOVED***
      // force double quotes as soon
      // as one single quote is found
      if (*s == '\'') ***REMOVED*** return '"'; ***REMOVED***
      // a single does not force quote_mark
      // maybe we see a double quote later
      else if (*s == '"') ***REMOVED*** quote_mark = '\''; ***REMOVED***
      ++ s;
***REMOVED***
    return quote_mark;
  ***REMOVED***

  std::string unquote(const std::string& s, char* qd, bool keep_utf8_sequences)
  ***REMOVED***

    // not enough room for quotes
    // no possibility to unquote
    if (s.length() < 2) return s;

    char q;
    bool skipped = false;

    // this is no guarantee that the unquoting will work
    // what about whitespace before/after the quote_mark?
    if      (*s.begin() == '"'  && *s.rbegin() == '"')  q = '"';
    else if (*s.begin() == '\'' && *s.rbegin() == '\'') q = '\'';
    else                                                return s;

    std::string unq;
    unq.reserve(s.length()-2);

    for (size_t i = 1, L = s.length() - 1; i < L; ++i) ***REMOVED***

      // implement the same strange ruby sass behavior
      // an escape sequence can also mean a unicode char
      if (s[i] == '\\' && !skipped) ***REMOVED***
        // remember
        skipped = true;

        // skip it
        // ++ i;

        // if (i == L) break;

        // escape length
        size_t len = 1;

        // parse as many sequence chars as possible
        // ToDo: Check if ruby aborts after possible max
        while (i + len < L && s[i + len] && isxdigit(s[i + len])) ++ len;

        // hex string?
        if (keep_utf8_sequences) ***REMOVED***
          unq.push_back(s[i]);
***REMOVED*** else if (len > 1) ***REMOVED***

          // convert the extracted hex string to code point value
          // ToDo: Maybe we could do this without creating a substring
          uint32_t cp = strtol(s.substr (i + 1, len - 1).c_str(), NULL, 16);

          if (s[i + len] == ' ') ++ len;

          // assert invalid code points
          if (cp == 0) cp = 0xFFFD;
          // replace bell character
          // if (cp == 10) cp = 32;

          // use a very simple approach to convert via utf8 lib
          // maybe there is a more elegant way; maybe we shoud
          // convert the whole output from string to a stream!?
          // allocate memory for utf8 char and convert to utf8
          unsigned char u[5] = ***REMOVED***0,0,0,0,0***REMOVED***; utf8::append(cp, u);
          for(size_t m = 0; u[m] && m < 5; m++) unq.push_back(u[m]);

          // skip some more chars?
          i += len - 1; skipped = false;

***REMOVED***


  ***REMOVED***
      // check for unexpected delimiter
      // be strict and throw error back
      // else if (!skipped && q == s[i]) ***REMOVED***
      //   // don't be that strict
      //   return s;
      //   // this basically always means an internal error and not users fault
      //   error("Unescaped delimiter in string to unquote found. [" + s + "]", ParserState("[UNQUOTE]"));
      // ***REMOVED***
      else ***REMOVED***
        skipped = false;
        unq.push_back(s[i]);
  ***REMOVED***

***REMOVED***
    if (skipped) ***REMOVED*** return s; ***REMOVED***
    if (qd) *qd = q;
    return unq;

  ***REMOVED***

  std::string quote(const std::string& s, char q, bool keep_linefeed_whitespace)
  ***REMOVED***

    // autodetect with fallback to given quote
    q = detect_best_quotemark(s.c_str(), q);

    // return an empty quoted string
    if (s.empty()) return std::string(2, q ? q : '"');

    std::string quoted;
    quoted.reserve(s.length()+2);
    quoted.push_back(q);

    const char* it = s.c_str();
    const char* end = it + strlen(it) + 1;
    while (*it && it < end) ***REMOVED***
      const char* now = it;

      if (*it == q) ***REMOVED***
        quoted.push_back('\\');
  ***REMOVED*** else if (*it == '\\') ***REMOVED***
        quoted.push_back('\\');
  ***REMOVED***

      int cp = utf8::next(it, end);

      if (cp == '\n') ***REMOVED***
        quoted.push_back('\\');
        quoted.push_back('a');
        // we hope we can remove this flag once we figure out
        // why ruby sass has these different output behaviors
        if (keep_linefeed_whitespace)
          quoted.push_back(' ');
  ***REMOVED*** else if (cp < 127) ***REMOVED***
        quoted.push_back((char) cp);
  ***REMOVED*** else ***REMOVED***
        while (now < it) ***REMOVED***
          quoted.push_back(*now);
          ++ now;
***REMOVED***
  ***REMOVED***
***REMOVED***

    quoted.push_back(q);
    return quoted;
  ***REMOVED***

  bool is_hex_doublet(double n)
  ***REMOVED***
    return n == 0x00 || n == 0x11 || n == 0x22 || n == 0x33 ||
           n == 0x44 || n == 0x55 || n == 0x66 || n == 0x77 ||
           n == 0x88 || n == 0x99 || n == 0xAA || n == 0xBB ||
           n == 0xCC || n == 0xDD || n == 0xEE || n == 0xFF ;
  ***REMOVED***

  bool is_color_doublet(double r, double g, double b)
  ***REMOVED***
    return is_hex_doublet(r) && is_hex_doublet(g) && is_hex_doublet(b);
  ***REMOVED***

  bool peek_linefeed(const char* start)
  ***REMOVED***
    using namespace Prelexer;
    using namespace Constants;
    return sequence <
             zero_plus <
               alternatives <
                 exactly <' '>,
                 exactly <'\t'>,
                 line_comment,
                 block_comment,
                 delimited_by <
                   slash_star,
                   star_slash,
                   false
                 >
               >
             >,
             re_linebreak
           >(start) != 0;
  ***REMOVED***

  namespace Util ***REMOVED***
    using std::string;

    std::string rtrim(const std::string &str) ***REMOVED***
      std::string trimmed = str;
      size_t pos_ws = trimmed.find_last_not_of(" \t\n\v\f\r");
      if (pos_ws != std::string::npos)
  ***REMOVED*** trimmed.erase(pos_ws + 1); ***REMOVED***
      else ***REMOVED*** trimmed.clear(); ***REMOVED***
      return trimmed;
***REMOVED***

    std::string normalize_underscores(const std::string& str) ***REMOVED***
      std::string normalized = str;
      for(size_t i = 0, L = normalized.length(); i < L; ++i) ***REMOVED***
        if(normalized[i] == '_') ***REMOVED***
          normalized[i] = '-';
***REMOVED***
  ***REMOVED***
      return normalized;
***REMOVED***

    std::string normalize_decimals(const std::string& str) ***REMOVED***
      std::string prefix = "0";
      std::string normalized = str;

      return normalized[0] == '.' ? normalized.insert(0, prefix) : normalized;
***REMOVED***

    // compress a color sixtuplet if possible
    // input: "#CC9900" -> output: "#C90"
    std::string normalize_sixtuplet(const std::string& col) ***REMOVED***
      if(
        col.substr(1, 1) == col.substr(2, 1) &&
        col.substr(3, 1) == col.substr(4, 1) &&
        col.substr(5, 1) == col.substr(6, 1)
      ) ***REMOVED***
        return std::string("#" + col.substr(1, 1)
                          + col.substr(3, 1)
                          + col.substr(5, 1));
  ***REMOVED*** else ***REMOVED***
        return std::string(col);
  ***REMOVED***
***REMOVED***

    bool isPrintable(Ruleset* r, Sass_Output_Style style) ***REMOVED***
      if (r == NULL) ***REMOVED***
        return false;
  ***REMOVED***

      Block* b = r->block();

      bool hasSelectors = static_cast<Selector_List*>(r->selector())->length() > 0;

      if (!hasSelectors) ***REMOVED***
        return false;
  ***REMOVED***

      bool hasDeclarations = false;
      bool hasPrintableChildBlocks = false;
      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        if (dynamic_cast<At_Rule*>(stm)) ***REMOVED***
          return true;
***REMOVED*** else if (dynamic_cast<Has_Block*>(stm)) ***REMOVED***
          Block* pChildBlock = ((Has_Block*)stm)->block();
          if (isPrintable(pChildBlock, style)) ***REMOVED***
            hasPrintableChildBlocks = true;
  ***REMOVED***
***REMOVED*** else if (Comment* c = dynamic_cast<Comment*>(stm)) ***REMOVED***
          // keep for uncompressed
          if (style != SASS_STYLE_COMPRESSED) ***REMOVED***
            hasDeclarations = true;
  ***REMOVED***
          // output style compressed
          if (c->is_important()) ***REMOVED***
            hasDeclarations = c->is_important();
  ***REMOVED***
***REMOVED*** else if (Declaration* d = dynamic_cast<Declaration*>(stm)) ***REMOVED***
          return isPrintable(d, style);
***REMOVED*** else ***REMOVED***
          hasDeclarations = true;
***REMOVED***

        if (hasDeclarations || hasPrintableChildBlocks) ***REMOVED***
          return true;
***REMOVED***
  ***REMOVED***

      return false;
***REMOVED***

    bool isPrintable(String_Constant* s, Sass_Output_Style style)
***REMOVED***
      return ! s->value().empty();
***REMOVED***

    bool isPrintable(String_Quoted* s, Sass_Output_Style style)
***REMOVED***
      return true;
***REMOVED***

    bool isPrintable(Declaration* d, Sass_Output_Style style)
***REMOVED***
      Expression* val = d->value();
      if (String_Quoted* sq = dynamic_cast<String_Quoted*>(val)) return isPrintable(sq, style);
      if (String_Constant* sc = dynamic_cast<String_Constant*>(val)) return isPrintable(sc, style);
      return true;
***REMOVED***

    bool isPrintable(Supports_Block* f, Sass_Output_Style style) ***REMOVED***
      if (f == NULL) ***REMOVED***
        return false;
  ***REMOVED***

      Block* b = f->block();

//      bool hasSelectors = f->selector() && static_cast<Selector_List*>(f->selector())->length() > 0;

      bool hasDeclarations = false;
      bool hasPrintableChildBlocks = false;
      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        if (!stm->is_hoistable()) ***REMOVED***
          // If a statement isn't hoistable, the selectors apply to it. If there are no selectors (a selector list of length 0),
          // then those statements aren't considered printable. That means there was a placeholder that was removed. If the selector
          // is NULL, then that means there was never a wrapping selector and it is printable (think of a top level media block with
          // a declaration in it).
***REMOVED***
        else if (typeid(*stm) == typeid(Declaration) || typeid(*stm) == typeid(At_Rule)) ***REMOVED***
          hasDeclarations = true;
***REMOVED***
        else if (dynamic_cast<Has_Block*>(stm)) ***REMOVED***
          Block* pChildBlock = ((Has_Block*)stm)->block();
          if (isPrintable(pChildBlock, style)) ***REMOVED***
            hasPrintableChildBlocks = true;
  ***REMOVED***
***REMOVED***

        if (hasDeclarations || hasPrintableChildBlocks) ***REMOVED***
          return true;
***REMOVED***
  ***REMOVED***

      return false;
***REMOVED***

    bool isPrintable(Media_Block* m, Sass_Output_Style style)
***REMOVED***
      if (m == 0) return false;
      Block* b = m->block();
      if (b == 0) return false;
      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        if (typeid(*stm) == typeid(At_Rule)) return true;
        if (typeid(*stm) == typeid(Declaration)) return true;
        if (Has_Block* child = dynamic_cast<Has_Block*>(stm)) ***REMOVED***
          if (isPrintable(child->block(), style)) return true;
***REMOVED***
  ***REMOVED***
      return false;
***REMOVED***

    bool isPrintable(Block* b, Sass_Output_Style style) ***REMOVED***
      if (b == NULL) ***REMOVED***
        return false;
  ***REMOVED***

      for (size_t i = 0, L = b->length(); i < L; ++i) ***REMOVED***
        Statement* stm = (*b)[i];
        if (typeid(*stm) == typeid(Declaration) || typeid(*stm) == typeid(At_Rule)) ***REMOVED***
          return true;
***REMOVED***
        else if (typeid(*stm) == typeid(Comment)) ***REMOVED***
          Comment* c = (Comment*) stm;
          // keep for uncompressed
          if (style != SASS_STYLE_COMPRESSED) ***REMOVED***
            return true;
  ***REMOVED***
          // output style compressed
          if (c->is_important()) ***REMOVED***
            return true;
  ***REMOVED***
***REMOVED***
        else if (typeid(*stm) == typeid(Ruleset)) ***REMOVED***
          Ruleset* r = (Ruleset*) stm;
          if (isPrintable(r, style)) ***REMOVED***
            return true;
  ***REMOVED***
***REMOVED***
        else if (typeid(*stm) == typeid(Supports_Block)) ***REMOVED***
          Supports_Block* f = (Supports_Block*) stm;
          if (isPrintable(f, style)) ***REMOVED***
            return true;
  ***REMOVED***
***REMOVED***
        else if (typeid(*stm) == typeid(Media_Block)) ***REMOVED***
          Media_Block* m = (Media_Block*) stm;
          if (isPrintable(m, style)) ***REMOVED***
            return true;
  ***REMOVED***
***REMOVED***
        else if (dynamic_cast<Has_Block*>(stm) && isPrintable(((Has_Block*)stm)->block(), style)) ***REMOVED***
          return true;
***REMOVED***
  ***REMOVED***

      return false;
***REMOVED***

    std::string vecJoin(const std::vector<std::string>& vec, const std::string& sep)
***REMOVED***
      switch (vec.size())
  ***REMOVED***
        case 0:
            return std::string("");
        case 1:
            return vec[0];
        default:
            std::ostringstream os;
            os << vec[0];
            for (size_t i = 1; i < vec.size(); i++) ***REMOVED***
              os << sep << vec[i];
***REMOVED***
            return os.str();
  ***REMOVED***
***REMOVED***

     bool isAscii(const char chr) ***REMOVED***
       return unsigned(chr) < 128;
 ***REMOVED***

  ***REMOVED***
***REMOVED***
